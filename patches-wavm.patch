diff --git a/WAVM/.gitignore b/WAVM/.gitignore
new file mode 100644
index 00000000..ea6912cb
--- /dev/null
+++ b/WAVM/.gitignore
@@ -0,0 +1 @@
+mybuild
diff --git a/WAVM/CMakeLists.txt b/WAVM/CMakeLists.txt
index ebebc802..e796ab14 100644
--- a/WAVM/CMakeLists.txt
+++ b/WAVM/CMakeLists.txt
@@ -104,8 +104,13 @@ if(CMAKE_CXX_COMPILER_ID MATCHES "Clang" OR CMAKE_CXX_COMPILER_ID STREQUAL "GNU"
 endif()
 
 if(WAVM_ENABLE_RUNTIME)
-	# Find an installed build of LLVM
-	find_package(LLVM REQUIRED CONFIG)
+    # Find an installed build of LLVM
+	set(ORIG_LLVM_DIR ${LLVM_DIR})
+	find_package(LLVM 11 QUIET CONFIG)
+	if (NOT LLVM_FOUND)
+		set(LLVM_DIR ${ORIG_LLVM_DIR})
+		find_package(LLVM 11.1 REQUIRED CONFIG)
+	endif()
 
 	if(LLVM_VERSION_MAJOR LESS 6)
 		message(FATAL_ERROR "WAVM requires LLVM version 6.0 or newer")
@@ -125,7 +130,7 @@ if(WAVM_ENABLE_RUNTIME)
 	list(REMOVE_ITEM LLVM_DEFINITIONS "-D_CRT_NONSTDC_NO_WARNINGS")
 	list(REMOVE_ITEM LLVM_DEFINITIONS "-D_SCL_SECURE_NO_DEPRECATE")
 	list(REMOVE_ITEM LLVM_DEFINITIONS "-D_SCL_SECURE_NO_WARNINGS")
-	
+
 	option(WAVM_ENABLE_UNWIND "enables printing stack traces" ON)
 else()
 	set(WAVM_ENABLE_UNWIND OFF)
@@ -272,7 +277,7 @@ string(REPLACE "/Ob1" "/Ob2" CMAKE_CXX_FLAGS_RELWITHDEBINFO_LOCAL ${CMAKE_CXX_FL
 set(CMAKE_C_FLAGS_RELWITHDEBINFO ${CMAKE_C_FLAGS_RELWITHDEBINFO_LOCAL} CACHE STRING "" FORCE)
 set(CMAKE_CXX_FLAGS_RELWITHDEBINFO ${CMAKE_CXX_FLAGS_RELWITHDEBINFO_LOCAL} CACHE STRING "" FORCE)
 
-if(CMAKE_CXX_COMPILER_ID MATCHES "Clang" OR CMAKE_CXX_COMPILER_ID STREQUAL "GNU")	
+if(CMAKE_CXX_COMPILER_ID MATCHES "Clang" OR CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
 
 	# Expose the -fuse-ld=<x> option on GCC/Clang through a WAVM_USE_LINKER config variable.
 	set(WAVM_USE_LINKER "" CACHE STRING "If set, overrides the default linker (as the compiler option -fuse-ld=<WAVM_USE_LINKER>)")
@@ -283,7 +288,7 @@ if(CMAKE_CXX_COMPILER_ID MATCHES "Clang" OR CMAKE_CXX_COMPILER_ID STREQUAL "GNU"
 	# Warn if a switch doesn't handle an enum case even if it has a default label.
 	wavm_add_c_cxx_flag_if_supported("-Wswitch-enum")
 	wavm_add_c_cxx_flag_if_supported("-Wswitch-default")
-	
+
 	wavm_add_c_cxx_flag_if_supported("-Wnull-dereference")
 	wavm_add_c_cxx_flag_if_supported("-Wduplicated-cond")
 	wavm_add_c_cxx_flag_if_supported("-Wduplicated-branches")
@@ -383,7 +388,7 @@ function(WAVM_SET_TARGET_LINKER_OPTIONS TARGET_NAME)
 	else()
 		target_link_libraries(${TARGET_NAME} PRIVATE ${WAVM_LINKER_FLAGS})
 	endif()
-	
+
 	if(NOT CMAKE_SYSTEM_NAME STREQUAL "Windows")
 		get_target_property(TARGET_TYPE ${TARGET_NAME} TYPE)
 		if(TARGET_TYPE STREQUAL "STATIC_LIBRARY" AND WAVM_ENABLE_STATIC_LIBRARY_PIC)
@@ -415,7 +420,7 @@ function(WAVM_SET_TARGET_SANITIZER_OPTIONS TARGET_NAME)
 			target_compile_options(${TARGET_NAME} PRIVATE "-fsanitize=thread")
 			target_link_libraries(${TARGET_NAME} PUBLIC -fsanitize=thread)
 		endif()
-		
+
 		# Optionally enable Clang's libfuzzer.
 		if(CMAKE_CXX_COMPILER_ID MATCHES "Clang" AND WAVM_ENABLE_LIBFUZZER)
 			target_compile_options(${TARGET_NAME} PRIVATE "-fsanitize=fuzzer")
@@ -448,12 +453,12 @@ function(WAVM_SET_TARGET_COMPILE_OPTIONS TARGET_NAME)
 			   $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}/Include>
 	)
 
-	# Target C++14.
+	# Target C++11.
 	target_compile_features(${TARGET_NAME} PUBLIC cxx_std_14)
-	
+
 	# Set sanitizer options.
 	WAVM_SET_TARGET_SANITIZER_OPTIONS(${TARGET_NAME})
-	
+
 	if(MSVC)
 		# Compile files in parallel.
 		target_compile_options(${TARGET_NAME} PRIVATE "/MP")
@@ -474,7 +479,7 @@ function(WAVM_SET_TARGET_COMPILE_OPTIONS TARGET_NAME)
 		target_compile_options(${TARGET_NAME} PRIVATE "/wd4251") # struct '' needs to have dll-interface to be used by clients of struct ''
 
 		target_link_libraries(${TARGET_NAME} PRIVATE "-ignore:4199") # /DELAYLOAD:... ignored; no imports found from ...
-		
+
 		if(CMAKE_CXX_COMPILER_ID MATCHES "Clang")
 			target_compile_options(${TARGET_NAME} PRIVATE "-Wno-deprecated-declarations")
 		endif()
@@ -490,14 +495,13 @@ function(WAVM_SET_TARGET_COMPILE_OPTIONS TARGET_NAME)
 		#     behavior.
 		target_compile_definitions(${TARGET_NAME} PRIVATE "_ENABLE_EXTENDED_ALIGNED_STORAGE")
 	elseif(CMAKE_CXX_COMPILER_ID MATCHES "Clang" OR CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
-	
+
 		# Compile with all+extra warnings and fatal warnings
 		target_compile_options(${TARGET_NAME} PRIVATE "-Wall")
 		target_compile_options(${TARGET_NAME} PRIVATE "-Wextra")
-		target_compile_options(${TARGET_NAME} PRIVATE "-Werror")
 
 		# Disable RTTI to allow linking against a build of LLVM that was compiled without it.
-		target_compile_options(${TARGET_NAME} PRIVATE $<$<COMPILE_LANGUAGE:CXX>:-fno-rtti>)
+		# target_compile_options(${TARGET_NAME} PRIVATE $<$<COMPILE_LANGUAGE:CXX>:-fno-rtti>)
 
 		# Don't eliminate frame pointers: this makes thread forking work robustly if one of the
 		# sanitizers requires a frame pointer, and makes ASAN's stack trace on malloc much better
@@ -510,7 +514,7 @@ function(WAVM_SET_TARGET_COMPILE_OPTIONS TARGET_NAME)
 		target_compile_options(${TARGET_NAME} PRIVATE "-pthread")
 		target_link_libraries(${TARGET_NAME} PRIVATE "-pthread")
 	endif()
-	
+
 	# Add the optional flags that the compiler was detected to support.
 	# This needs to happen *AFTER* the above -Wall -Wextra to ensure that those flags don't
 	# re-enable warnings that are being disabled by these flags.
@@ -571,9 +575,9 @@ function(WAVM_ADD_LIB_COMPONENT COMPONENT_NAME)
 	endforeach()
 	foreach(COMPONENT_NONCOMPILED_SOURCE ${COMPONENT_NONCOMPILED_SOURCES})
 		get_filename_component(COMPONENT_NONCOMPILED_SOURCE_ABSOLUTE ${COMPONENT_NONCOMPILED_SOURCE} ABSOLUTE)
-		list(APPEND COMPONENT_NONCOMPILED_SOURCES_ABSOLUTE ${COMPONENT_NONCOMPILED_SOURCE_ABSOLUTE})			
+		list(APPEND COMPONENT_NONCOMPILED_SOURCES_ABSOLUTE ${COMPONENT_NONCOMPILED_SOURCE_ABSOLUTE})
 	endforeach()
-	
+
 	# Directly add the component's source files to the monolithic WAVM library.
 	target_sources(libWAVM PRIVATE ${COMPONENT_SOURCES_ABSOLUTE} ${CMAKE_CURRENT_LIST_FILE})
 
@@ -587,7 +591,7 @@ function(WAVM_ADD_LIB_COMPONENT COMPONENT_NAME)
 	list(APPEND WAVM_MONOLIB_PUBLIC_LIBS ${COMPONENT_PUBLIC_LIBS})
 	set(WAVM_MONOLIB_PRIVATE_LIBS ${WAVM_MONOLIB_PRIVATE_LIBS} CACHE INTERNAL "" FORCE)
 	set(WAVM_MONOLIB_PUBLIC_LIBS ${WAVM_MONOLIB_PUBLIC_LIBS} CACHE INTERNAL "" FORCE)
-	
+
 	# Add the component's include directories and definitions.
 	target_include_directories(libWAVM PRIVATE ${COMPONENT_PRIVATE_INCLUDE_DIRECTORIES})
 	target_include_directories(libWAVM SYSTEM PRIVATE ${COMPONENT_PRIVATE_SYSTEM_INCLUDE_DIRECTORIES})
@@ -631,7 +635,7 @@ function(WAVM_ADD_THIRD_PARTY_LIBRARY LIB_NAME)
 
 	# Create a static library.
 	add_library(${LIB_NAME} STATIC ${LIB_SOURCES} ${LIB_NONCOMPILED_SOURCES})
-	
+
 	# Target C++11.
 	target_compile_features(${LIB_NAME} PRIVATE cxx_std_11)
 
@@ -677,6 +681,11 @@ else()
 endif()
 WAVM_SET_TARGET_COMPILE_OPTIONS(libWAVM)
 WAVM_INSTALL_TARGET(libWAVM)
+if(TARGET Tracy::TracyClient)
+    message(STATUS "Tracy found!")
+    target_link_libraries(libWAVM PRIVATE Tracy::TracyClient)
+    target_compile_definitions(libWAVM PUBLIC WAVM_HAS_TRACY=1)
+endif()
 set_target_properties(libWAVM PROPERTIES
 	FOLDER Libraries
 	INSTALL_RPATH_USE_LINK_PATH TRUE
diff --git a/WAVM/Include/WAVM/IR/FeatureSpec.h b/WAVM/Include/WAVM/IR/FeatureSpec.h
index a228c394..65c042cd 100644
--- a/WAVM/Include/WAVM/IR/FeatureSpec.h
+++ b/WAVM/Include/WAVM/IR/FeatureSpec.h
@@ -53,6 +53,15 @@
 
 namespace WAVM { namespace IR {
 
+enum class BoundsCheckingMechanism {
+	none,
+	clamp,
+	trap,
+	mprotect,
+};
+
+extern BoundsCheckingMechanism boundsCheckingMechanism;
+
 #define VISIT_FEATURE(name, ...) name,
 	enum class Feature
 	{
diff --git a/WAVM/Include/WAVM/Inline/BasicTypes.h b/WAVM/Include/WAVM/Inline/BasicTypes.h
index 06db441f..7c11ece2 100644
--- a/WAVM/Include/WAVM/Inline/BasicTypes.h
+++ b/WAVM/Include/WAVM/Inline/BasicTypes.h
@@ -3,6 +3,7 @@
 #include <inttypes.h>
 #include <stddef.h>
 #include <stdint.h>
+#include <stdexcept>
 #include "WAVM/Platform/Defines.h"
 
 namespace WAVM {
diff --git a/WAVM/Include/WAVM/Inline/Impl/HashSetImpl.h b/WAVM/Include/WAVM/Inline/Impl/HashSetImpl.h
index ff7d712b..0cb9add8 100644
--- a/WAVM/Include/WAVM/Inline/Impl/HashSetImpl.h
+++ b/WAVM/Include/WAVM/Inline/Impl/HashSetImpl.h
@@ -1,14 +1,12 @@
 // IWYU pragma: private, include "WAVM/Inline/HashSet.h"
 // You should only include this file indirectly by including HashMap.h.
 
-template<typename Element>
-bool HashSetIterator<Element>::operator!=(const HashSetIterator& other) const
+template<typename Element> bool HashSetIterator<Element>::operator!=(const HashSetIterator& other) const
 {
 	return bucket != other.bucket;
 }
 
-template<typename Element>
-bool HashSetIterator<Element>::operator==(const HashSetIterator& other) const
+template<typename Element> bool HashSetIterator<Element>::operator==(const HashSetIterator& other) const
 {
 	return bucket == other.bucket;
 }
diff --git a/WAVM/Include/WAVM/Inline/Serialization.h b/WAVM/Include/WAVM/Inline/Serialization.h
index 3a4b9642..1f47ed44 100644
--- a/WAVM/Include/WAVM/Inline/Serialization.h
+++ b/WAVM/Include/WAVM/Inline/Serialization.h
@@ -3,6 +3,7 @@
 #include <string.h>
 #include <algorithm>
 #include <string>
+#include <stdexcept>
 #include <vector>
 #include "WAVM/Inline/Assert.h"
 #include "WAVM/Inline/BasicTypes.h"
@@ -225,6 +226,20 @@ namespace WAVM { namespace Serialization {
 		}
 	}
 
+	template<typename Stream> void serialize(Stream& stream, const std::string& string)
+	{
+		Uptr size = string.size();
+		serializeVarUInt32(stream, size);
+		if(Stream::isInput)
+		{
+			throw std::invalid_argument("Input stream with const string");
+		}
+		else
+		{
+			serializeBytes(stream, (U8*)string.c_str(), size);
+		}
+	}
+
 	template<typename Stream, typename Element, typename Allocator, typename SerializeElement>
 	void serializeArray(Stream& stream,
 						std::vector<Element, Allocator>& vector,
diff --git a/WAVM/Include/WAVM/Platform/Event.h b/WAVM/Include/WAVM/Platform/Event.h
index 13414c22..0208f0cc 100644
--- a/WAVM/Include/WAVM/Platform/Event.h
+++ b/WAVM/Include/WAVM/Platform/Event.h
@@ -43,6 +43,15 @@ namespace WAVM { namespace Platform {
 		{
 			Uptr data[6];
 		} pthreadCond;
+#elif defined(__linux__) && defined(__riscv) && (__riscv_xlen == 64)
+		struct PthreadMutex
+		{
+			Uptr data[5];
+		} pthreadMutex;
+		struct PthreadCond
+		{
+			Uptr data[6];
+		} pthreadCond;
 #elif defined(__APPLE__)
 		struct PthreadMutex
 		{
diff --git a/WAVM/Include/WAVM/Platform/Memory.h b/WAVM/Include/WAVM/Platform/Memory.h
index 84e49584..9b7e4358 100644
--- a/WAVM/Include/WAVM/Platform/Memory.h
+++ b/WAVM/Include/WAVM/Platform/Memory.h
@@ -3,7 +3,10 @@
 #include "WAVM/Inline/BasicTypes.h"
 #include "WAVM/Platform/Defines.h"
 
+#include <memory>
+
 namespace WAVM { namespace Platform {
+
 	// Describes allowed memory accesses.
 	enum class MemoryAccess
 	{
@@ -14,6 +17,58 @@ namespace WAVM { namespace Platform {
 		readWriteExecute
 	};
 
+	struct MemoryOverrideHook
+	{
+		virtual ~MemoryOverrideHook() = default;
+
+		// Allocates virtual addresses without commiting physical pages to them.
+		// Returns the base virtual address of the allocated addresses, or nullptr if the virtual
+		// address space has been exhausted.
+		virtual U8* allocateVirtualPages(Uptr numPages) = 0;
+
+		// Allocates virtual addresses without commiting physical pages to them.
+		// Returns the base virtual address of the allocated addresses, or nullptr if the virtual
+		// address space has been exhausted.
+		virtual U8* allocateAlignedVirtualPages(Uptr numPages,
+												Uptr alignmentLog2,
+												U8*& outUnalignedBaseAddress)
+			= 0;
+
+		// Commits physical memory to the specified virtual pages.
+		// baseVirtualAddress must be a multiple of the preferred page size.
+		// Return true if successful, or false if physical memory has been exhausted.
+		virtual bool commitVirtualPages(U8* baseVirtualAddress,
+										Uptr numPages,
+										MemoryAccess access = MemoryAccess::readWrite)
+			= 0;
+
+		// Changes the allowed access to the specified virtual pages.
+		// baseVirtualAddress must be a multiple of the preferred page size.
+		// Return true if successful, or false if the access-level could not be set.
+		virtual bool setVirtualPageAccess(U8* baseVirtualAddress,
+										  Uptr numPages,
+										  MemoryAccess access)
+			= 0;
+
+		// Decommits the physical memory that was committed to the specified virtual pages.
+		// baseVirtualAddress must be a multiple of the preferred page size.
+		virtual void decommitVirtualPages(U8* baseVirtualAddress, Uptr numPages) = 0;
+
+		// Frees virtual addresses. baseVirtualAddress must also be the address returned by
+		// allocateVirtualPages.
+		virtual void freeVirtualPages(U8* baseVirtualAddress, Uptr numPages) = 0;
+
+		// Frees an aligned virtual address block. unalignedBaseAddress must be the unaligned base
+		// address returned in the outUnalignedBaseAddress parameter of a call to
+		// allocateAlignedVirtualPages.
+		virtual void freeAlignedVirtualPages(U8* unalignedBaseAddress,
+											 Uptr numPages,
+											 Uptr alignmentLog2)
+			= 0;
+	};
+
+	WAVM_API void installMemoryOverrideHook(std::unique_ptr<MemoryOverrideHook> hook);
+
 	// Returns the base 2 logarithm of the number of bytes in the smallest virtual page.
 	WAVM_API Uptr getBytesPerPageLog2();
 
diff --git a/WAVM/Include/WAVM/Platform/Signal.h b/WAVM/Include/WAVM/Platform/Signal.h
index cd42b04b..9df3aa53 100644
--- a/WAVM/Include/WAVM/Platform/Signal.h
+++ b/WAVM/Include/WAVM/Platform/Signal.h
@@ -12,7 +12,8 @@ namespace WAVM { namespace Platform {
 			invalid = 0,
 			accessViolation,
 			stackOverflow,
-			intDivideByZeroOrOverflow
+			intDivideByZeroOrOverflow,
+			timeout
 		};
 
 		Type type = Type::invalid;
diff --git a/WAVM/Include/WAVM/Runtime/Runtime.h b/WAVM/Include/WAVM/Runtime/Runtime.h
index a4285323..d017a26d 100644
--- a/WAVM/Include/WAVM/Runtime/Runtime.h
+++ b/WAVM/Include/WAVM/Runtime/Runtime.h
@@ -172,6 +172,7 @@ namespace WAVM { namespace Runtime {
 		  WAVM::IR::ValueType::i64);                                                               \
 	visit(stackOverflow);                                                                          \
 	visit(integerDivideByZeroOrOverflow);                                                          \
+	visit(timeout);                                                                                \
 	visit(invalidFloatOperation);                                                                  \
 	visit(invokeSignatureMismatch);                                                                \
 	visit(reachedUnreachable);                                                                     \
@@ -319,6 +320,8 @@ namespace WAVM { namespace Runtime {
 	// Returns the type of a Function.
 	WAVM_API IR::FunctionType getFunctionType(const Function* function);
 
+	WAVM_API std::string getFunctionDebugName(const Function* function);
+
 	//
 	// Tables
 	//
@@ -369,9 +372,14 @@ namespace WAVM { namespace Runtime {
 	// Returns the type of a memory.
 	WAVM_API IR::MemoryType getMemoryType(const Memory* memory);
 
-	// Grows or shrinks the size of a memory by numPages. Returns the previous size of the memory.
+	// Grows the size of a memory by numPages. Returns the previous size of the memory.
 	WAVM_API GrowResult growMemory(Memory* memory, Uptr numPages, Uptr* outOldNumPages = nullptr);
 
+	// Shrinks the size of a memory by numPagesToShrink. Returns the new size of the memory.
+	WAVM_API GrowResult shrinkMemory(Memory* memory,
+									 Uptr numPagesToShrink,
+									 Uptr* outNewNumPages = nullptr);
+
 	// Unmaps a range of memory pages within the memory's address-space.
 	WAVM_API void unmapMemoryPages(Memory* memory, Uptr pageIndex, Uptr numPages);
 
@@ -429,6 +437,12 @@ namespace WAVM { namespace Runtime {
 	typedef const std::shared_ptr<Module>& ModuleRefParam;
 	typedef const std::shared_ptr<const Module>& ModuleConstRefParam;
 
+	// Compiles an IR module to object code, skipping the global cache and allowing for
+	// cross-compilation
+	WAVM_API std::vector<U8> precompileModule(const IR::Module& irModule,
+											  const std::string& targetArch,
+											  const std::string& targetCpu);
+
 	// Compiles an IR module to object code.
 	WAVM_API ModuleRef compileModule(const IR::Module& irModule);
 
@@ -509,6 +523,10 @@ namespace WAVM { namespace Runtime {
 
 	WAVM_API Compartment* createCompartment(std::string&& debugName = "");
 
+	WAVM_API void cloneCompartmentInto(Compartment& targetCompartment,
+									   const Compartment* sourceCompartment,
+									   std::string&& debugName = "");
+
 	WAVM_API Compartment* cloneCompartment(const Compartment* compartment,
 										   std::string&& debugName = "");
 
diff --git a/WAVM/LICENSE.txt b/WAVM/LICENSE.txt
index 8ff0f5a7..039a6ae4 100644
--- a/WAVM/LICENSE.txt
+++ b/WAVM/LICENSE.txt
@@ -7,3 +7,23 @@ Redistribution and use in source and binary forms, with or without modification,
 * Neither the name of WAVM nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 
 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+Third Party Software
+====================
+
+Parts of the I128 code are derived from LLVM's compiler-rt library (https://github.com/llvm/llvm-project/tree/master/compiler-rt), which is covered by the license in https://github.com/WAVM/WAVM/blob/master/Include/WAVM/Inline/Impl/I128Impl.LICENSE.
+
+The WebAssembly spec test suite (https://github.com/WAVM/WAVM/tree/master/Test/WebAssembly) are covered by the license in https://github.com/WAVM/WAVM/blob/master/Test/WebAssembly/LICENSE.
+
+The libunwind library (https://github.com/WAVM/WAVM/tree/master/ThirdParty/libunwind) is covered by the license in https://github.com/WAVM/WAVM/blob/master/ThirdParty/libunwind/LICENSE.TXT.
+
+The liblmdb library (https://github.com/WAVM/WAVM/tree/master/ThirdParty/liblmdb) is covered by the license in https://github.com/WAVM/WAVM/blob/master/ThirdParty/liblmdb/LICENSE.
+
+The xxhash library (https://github.com/WAVM/WAVM/tree/master/Include/WAVM/Inline/xxhash) is covered by the license in https://github.com/WAVM/WAVM/blob/master/Include/WAVM/Inline/xxhash/LICENSE.
+
+The WASI ABI header (https://github.com/WAVM/WAVM/blob/master/Include/WAVM/WASI/WASIABI.h) is covered by the license in https://github.com/WAVM/WAVM/blob/master/Include/WAVM/WASI/WASIABI.LICENSE.
+
+The WAVM C API (https://github.com/WAVM/WAVM/blob/master/Include/WAVM/wavm-c/wavm-c.h) is based on wasm-c-api (https://github.com/WebAssembly/wasm-c-api), which is covered by the license in https://github.com/WAVM/WAVM/blob/master/Include/WAVM/wavm-c/wasm-c-api.LICENSE.
+
+The BLAKE2 library (https://github.com/WAVM/WAVM/tree/master/ThirdParty/BLAKE2) is covered by the license in https://github.com/WAVM/WAVM/blob/master/ThirdParty/BLAKE2/COPYING.
diff --git a/WAVM/Lib/IR/DisassemblyNames.cpp b/WAVM/Lib/IR/DisassemblyNames.cpp
index 8ea5b127..52f2f133 100644
--- a/WAVM/Lib/IR/DisassemblyNames.cpp
+++ b/WAVM/Lib/IR/DisassemblyNames.cpp
@@ -43,14 +43,11 @@ static void deserializeNameMap(InputStream& stream,
 		Uptr nameIndex = 0;
 		serializeVarUInt32(stream, nameIndex);
 
-		std::string nameString;
-		serialize(stream, nameString);
-
 		if(nameIndex >= maxNames) { throw FatalSerializationException("out-of-bounds name index"); }
 
 		if(nameIndex >= outNames.size()) { outNames.resize(nameIndex + 1); }
 
-		outNames[nameIndex] = std::move(nameString);
+		serialize(stream, outNames[nameIndex]);
 	}
 }
 
@@ -69,8 +66,7 @@ static void serializeNameMap(OutputStream& stream, const std::vector<std::string
 		{
 			serializeVarUInt32(stream, nameIndex);
 
-			std::string nameString = outNames[nameIndex];
-			serialize(stream, nameString);
+			serialize(stream, outNames[nameIndex]);
 		}
 	}
 }
@@ -85,6 +81,8 @@ static void deserializeNameSubsection(const Module& module,
 	U32 numSubsectionBytes = 0;
 	serializeVarUInt32(stream, numSubsectionBytes);
 
+	std::string functionName;
+
 	MemoryInputStream substream(stream.advance(numSubsectionBytes), numSubsectionBytes);
 	switch((NameSubsectionType)subsectionType)
 	{
@@ -100,7 +98,6 @@ static void deserializeNameSubsection(const Module& module,
 			U32 functionIndex = 0;
 			serializeVarUInt32(substream, functionIndex);
 
-			std::string functionName;
 			serialize(substream, functionName);
 
 			if(functionIndex < outNames.functions.size())
@@ -239,6 +236,7 @@ static void deserializeNameSubsection(const Module& module,
 void IR::getDisassemblyNames(const Module& module, DisassemblyNames& outNames)
 {
 	// Fill in the output with the correct number of blank names.
+	outNames.functions.reserve(module.functions.imports.size() + module.functions.defs.size());
 	for(const auto& functionImport : module.functions.imports)
 	{
 		DisassemblyNames::Function functionNames;
@@ -250,10 +248,8 @@ void IR::getDisassemblyNames(const Module& module, DisassemblyNames& outNames)
 	{
 		const FunctionDef& functionDef = module.functions.defs[functionDefIndex];
 		DisassemblyNames::Function functionNames;
-		functionNames.locals.insert(functionNames.locals.begin(),
-									module.types[functionDef.type.index].params().size()
-										+ functionDef.nonParameterLocalTypes.size(),
-									"");
+		functionNames.locals.resize(module.types[functionDef.type.index].params().size()
+										+ functionDef.nonParameterLocalTypes.size());
 		outNames.functions.push_back(std::move(functionNames));
 	}
 
@@ -324,8 +320,7 @@ void IR::setDisassemblyNames(Module& module, const DisassemblyNames& names)
 	// Module name
 	serializeNameSubsection(
 		stream, NameSubsectionType::module, [&names](OutputStream& subsectionStream) {
-			std::string moduleName = names.moduleName;
-			serialize(subsectionStream, moduleName);
+			serialize(subsectionStream, names.moduleName);
 		});
 
 	// Function names
@@ -336,8 +331,7 @@ void IR::setDisassemblyNames(Module& module, const DisassemblyNames& names)
 			for(Uptr functionIndex = 0; functionIndex < names.functions.size(); ++functionIndex)
 			{
 				serializeVarUInt32(subsectionStream, functionIndex);
-				std::string functionName = names.functions[functionIndex].name;
-				serialize(subsectionStream, functionName);
+				serialize(subsectionStream, names.functions[functionIndex].name);
 			}
 		});
 
diff --git a/WAVM/Lib/IR/FeatureSpec.cpp b/WAVM/Lib/IR/FeatureSpec.cpp
index d8ae95d1..2f1d5841 100644
--- a/WAVM/Lib/IR/FeatureSpec.cpp
+++ b/WAVM/Lib/IR/FeatureSpec.cpp
@@ -5,6 +5,8 @@
 using namespace WAVM;
 using namespace WAVM::IR;
 
+BoundsCheckingMechanism WAVM::IR::boundsCheckingMechanism = BoundsCheckingMechanism::mprotect;
+
 void FeatureSpec::setFeatureLevel(FeatureLevel featureLevel)
 {
 #define SET_FEATURE(name, ...) name = true;
diff --git a/WAVM/Lib/LLVMJIT/CMakeLists.txt b/WAVM/Lib/LLVMJIT/CMakeLists.txt
index 66f10070..408e547a 100644
--- a/WAVM/Lib/LLVMJIT/CMakeLists.txt
+++ b/WAVM/Lib/LLVMJIT/CMakeLists.txt
@@ -21,7 +21,13 @@ set(Sources
 set(PublicHeaders
 	${WAVM_INCLUDE_DIR}/LLVMJIT/LLVMJIT.h)
 
+if(${WAVM_PERF_LIBS})
+message(STATUS "Adding WAVM perf events")
+
 # Find the LLVM libraries to link with.
+# This is a bit lazy, should find only what's needed
+llvm_map_components_to_libnames(LLVM_LIBS all)
+else()
 llvm_map_components_to_libnames(LLVM_LIBS
 	support
 	core
@@ -31,6 +37,7 @@ llvm_map_components_to_libnames(LLVM_LIBS
 	DebugInfoDWARF
 	AllTargetsAsmParsers
 	${LLVM_TARGETS_TO_BUILD})
+endif()
 
 # Create the LLVMJIT target.
 WAVM_ADD_LIB_COMPONENT(LLVMJIT
diff --git a/WAVM/Lib/LLVMJIT/EmitCore.cpp b/WAVM/Lib/LLVMJIT/EmitCore.cpp
index 59214a6f..36029055 100644
--- a/WAVM/Lib/LLVMJIT/EmitCore.cpp
+++ b/WAVM/Lib/LLVMJIT/EmitCore.cpp
@@ -400,6 +400,11 @@ void EmitFunctionContext::call_indirect(CallIndirectImm imm)
 	auto runtimeFunction = irBuilder.CreateIntToPtr(
 		irBuilder.CreateAdd(biasedValueLoad, moduleContext.tableReferenceBias),
 		llvmContext.i8PtrType);
+
+// 24/04/2019 - Some code in CPython is a bit sloppy in its casting of function pointers, so
+// causes type mismatches at runtime. As a temporary hack I'm removing the type check on
+// call_indirect in the generated code.
+
 	auto elementTypeId = loadFromUntypedPointer(
 		irBuilder.CreateInBoundsGEP(
 			runtimeFunction,
diff --git a/WAVM/Lib/LLVMJIT/EmitMem.cpp b/WAVM/Lib/LLVMJIT/EmitMem.cpp
index 8ccb6006..e34c43f4 100644
--- a/WAVM/Lib/LLVMJIT/EmitMem.cpp
+++ b/WAVM/Lib/LLVMJIT/EmitMem.cpp
@@ -92,6 +92,20 @@ static llvm::Value* getOffsetAndBoundedAddress(EmitFunctionContext& functionCont
 		numBytes = irBuilder.CreateZExt(numBytes, functionContext.moduleContext.iptrType);
 	}
 
+	/// Only do zero-extension when no bounds checking is requested
+	if(boundsCheckingMechanism == BoundsCheckingMechanism::none)
+	{
+		llvm::Constant* offsetConstant
+			= emitLiteralIptr(offset, functionContext.moduleContext.iptrType);
+		if(offset != 0) { address = irBuilder.CreateAdd(address, offsetConstant); }
+		return address;
+	}
+
+	if(boundsCheckingMechanism == BoundsCheckingMechanism::trap)
+	{
+		boundsCheckOp = BoundsCheckOp::trapOnOutOfBounds;
+	}
+
 	// If the offset is greater than the size of the guard region, add it before bounds checking,
 	// and check for overflow.
 	if(offset && offset >= Runtime::memoryNumGuardBytes)
@@ -106,6 +120,7 @@ static llvm::Value* getOffsetAndBoundedAddress(EmitFunctionContext& functionCont
 		}
 		else
 		{
+			throw std::runtime_error("Unsupported !is32bitMemoryOn64bitHost");
 			llvm::Value* addressPlusOffsetAndOverflow
 				= functionContext.callLLVMIntrinsic({functionContext.moduleContext.iptrType},
 													llvm::Intrinsic::uadd_with_overflow,
@@ -146,6 +161,18 @@ static llvm::Value* getOffsetAndBoundedAddress(EmitFunctionContext& functionCont
 			 memoryNumBytes,
 			 emitLiteralIptr(memoryIndex, functionContext.moduleContext.iptrType)});
 	}
+	else if(boundsCheckingMechanism == BoundsCheckingMechanism::clamp)
+	{
+		llvm::Value* memoryNumBytes = getMemoryNumBytes(functionContext, memoryIndex);
+		llvm::Value* memoryNumBytesMinusNumBytes = irBuilder.CreateSub(memoryNumBytes, numBytes);
+		llvm::Value* numBytesWasGreaterThanMemoryNumBytes
+			= irBuilder.CreateICmpUGT(memoryNumBytesMinusNumBytes, memoryNumBytes);
+		address = irBuilder.CreateSelect(
+			irBuilder.CreateOr(numBytesWasGreaterThanMemoryNumBytes,
+							   irBuilder.CreateICmpUGT(address, memoryNumBytesMinusNumBytes)),
+			memoryNumBytesMinusNumBytes,
+			address);
+	}
 	else if(is32bitMemoryOn64bitHost)
 	{
 		// For 32-bit addresses on 64-bit targets, the runtime will reserve the full range of
diff --git a/WAVM/Lib/LLVMJIT/LLVMCompile.cpp b/WAVM/Lib/LLVMJIT/LLVMCompile.cpp
index b456940b..2ab9b164 100644
--- a/WAVM/Lib/LLVMJIT/LLVMCompile.cpp
+++ b/WAVM/Lib/LLVMJIT/LLVMCompile.cpp
@@ -14,6 +14,10 @@
 #include "WAVM/Logging/Logging.h"
 #include "WAVM/Platform/Defines.h"
 
+#ifdef WAVM_HAS_TRACY
+#include <Tracy.hpp>
+#endif
+
 PUSH_DISABLE_WARNINGS_FOR_LLVM_HEADERS
 #include <llvm-c/Disassembler.h>
 #include <llvm/ADT/SmallVector.h>
@@ -86,6 +90,9 @@ private:
 
 static void optimizeLLVMModule(llvm::Module& llvmModule, bool shouldLogMetrics)
 {
+	#ifdef WAVM_HAS_TRACY
+	ZoneScopedN("optimizeLLVMModule");
+	#endif
 	// Run some optimization on the module's functions.
 	Timing::Timer optimizationTimer;
 
@@ -124,6 +131,9 @@ std::vector<U8> LLVMJIT::compileLLVMModule(LLVMContext& llvmContext,
 										   bool shouldLogMetrics,
 										   llvm::TargetMachine* targetMachine)
 {
+	#ifdef WAVM_HAS_TRACY
+	ZoneScopedN("compileLLVMModule");
+	#endif
 	// Verify the module.
 	if(WAVM_ENABLE_ASSERTS)
 	{
@@ -143,6 +153,9 @@ std::vector<U8> LLVMJIT::compileLLVMModule(LLVMContext& llvmContext,
 	Timing::Timer machineCodeTimer;
 	std::vector<U8> objectBytes;
 	{
+		#ifdef WAVM_HAS_TRACY
+		ZoneNamedN(_zpm, "passManager", true);
+		#endif
 		llvm::legacy::PassManager passManager;
 		llvm::MCContext* mcContext;
 		LLVMArrayOutputStream objectStream;
diff --git a/WAVM/Lib/LLVMJIT/LLVMJIT.cpp b/WAVM/Lib/LLVMJIT/LLVMJIT.cpp
index 935c2a8b..fa4c5b0c 100644
--- a/WAVM/Lib/LLVMJIT/LLVMJIT.cpp
+++ b/WAVM/Lib/LLVMJIT/LLVMJIT.cpp
@@ -187,8 +187,20 @@ std::unique_ptr<llvm::TargetMachine> LLVMJIT::getTargetMachine(const TargetSpec&
 	}
 #endif
 
+	auto cpu = targetSpec.cpu;
+
+	if(triple.getArch() == llvm::Triple::riscv64)
+	{
+		targetAttributes.push_back("+a");
+		targetAttributes.push_back("+c");
+		targetAttributes.push_back("+d");
+		targetAttributes.push_back("+f");
+		targetAttributes.push_back("+m");
+		cpu = "generic-rv64";
+	}
+
 	return std::unique_ptr<llvm::TargetMachine>(
-		llvm::EngineBuilder().selectTarget(triple, "", targetSpec.cpu, targetAttributes));
+		llvm::EngineBuilder().selectTarget(triple, "", cpu, targetAttributes));
 }
 
 TargetValidationResult LLVMJIT::validateTargetMachine(
@@ -211,6 +223,10 @@ TargetValidationResult LLVMJIT::validateTargetMachine(
 
 		return TargetValidationResult::valid;
 	}
+	else if(targetArch == llvm::Triple::riscv64)
+	{
+		return TargetValidationResult::valid;
+	}
 	else
 	{
 		if(featureSpec.simd) { return TargetValidationResult::wavmDoesNotSupportSIMDOnArch; }
diff --git a/WAVM/Lib/LLVMJIT/LLVMModule.cpp b/WAVM/Lib/LLVMJIT/LLVMModule.cpp
index bb0ba92c..3d05eb14 100644
--- a/WAVM/Lib/LLVMJIT/LLVMModule.cpp
+++ b/WAVM/Lib/LLVMJIT/LLVMModule.cpp
@@ -83,6 +83,14 @@ struct LLVMJIT::GlobalModuleState
 	~GlobalModuleState() { delete gdbRegistrationListener; }
 };
 
+#ifdef WAVM_PERF_EVENTS
+static llvm::JITEventListener* perfRegistrationListener = nullptr;
+#endif
+
+// A map from address to loaded JIT symbols.
+static Platform::Mutex addressToModuleMapMutex;
+static std::map<Uptr, LLVMJIT::Module*> addressToModuleMap;
+
 // Allocates memory for the LLVM object loader.
 struct LLVMJIT::ModuleMemoryManager : llvm::RTDyldMemoryManager
 {
@@ -523,6 +531,14 @@ Module::Module(const std::vector<U8>& objectBytes,
 #else
 		globalModuleState->gdbRegistrationListener->NotifyObjectEmitted(*object, *loadedObject);
 #endif
+
+#ifdef WAVM_PERF_EVENTS
+        if(!perfRegistrationListener) {
+            perfRegistrationListener = llvm::JITEventListener::createPerfJITEventListener();
+        }
+
+        perfRegistrationListener->notifyObjectLoaded(reinterpret_cast<Uptr>(this), *object, *loadedObject);
+#endif
 	}
 
 	// Create a DWARF context to interpret the debug information in this compilation unit.
@@ -629,6 +645,10 @@ Module::~Module()
 #else
 		globalModuleState->gdbRegistrationListener->NotifyFreeingObject(*object);
 #endif
+
+#ifdef WAVM_PERF_EVENTS
+    perfRegistrationListener->notifyFreeingObject(reinterpret_cast<Uptr>(this));
+#endif
 	}
 
 	// Remove the module from the global address to module map.
@@ -760,15 +780,15 @@ std::shared_ptr<LLVMJIT::Module> LLVMJIT::loadModule(
 #if !USE_WINDOWS_SEH
 	// Use __cxxabiv1::__cxa_current_exception_type to get a reference to the std::type_info for
 	// Runtime::Exception* without enabling RTTI.
-	std::type_info* runtimeExceptionPointerTypeInfo = nullptr;
-	try
+	const std::type_info* runtimeExceptionPointerTypeInfo = &typeid(Runtime::Exception*);
+	/*try
 	{
 		throw(Runtime::Exception*) nullptr;
 	}
 	catch(Runtime::Exception*)
 	{
 		runtimeExceptionPointerTypeInfo = __cxxabiv1::__cxa_current_exception_type();
-	}
+	}*/
 
 	// Bind the std::type_info for Runtime::Exception.
 	importedSymbolMap.addOrFail("runtimeExceptionTypeInfo",
diff --git a/WAVM/Lib/Logging/Logging.cpp b/WAVM/Lib/Logging/Logging.cpp
index 6f01180d..27986419 100644
--- a/WAVM/Lib/Logging/Logging.cpp
+++ b/WAVM/Lib/Logging/Logging.cpp
@@ -60,7 +60,7 @@ void Log::vprintf(Category category, const char* format, va_list argList)
 
 		const Uptr numBufferBytes = numChars + 1;
 		static constexpr Uptr maxAllocaBytes = 4096;
-		char* buffer = (char*)(numBufferBytes > maxAllocaBytes ? malloc(numBufferBytes)
+		char* buffer = (char*)(numBufferBytes > maxAllocaBytes ? operator new(numBufferBytes)
 															   : alloca(numBufferBytes));
 		vsnprintf(buffer, numBufferBytes, format, argList);
 
@@ -77,7 +77,7 @@ void Log::vprintf(Category category, const char* format, va_list argList)
 			WAVM_ERROR_UNLESS(numBytesWritten == U32(numChars));
 		}
 
-		if(numBufferBytes > maxAllocaBytes) { free(buffer); }
+		if(numBufferBytes > maxAllocaBytes) { operator delete(buffer); }
 	}
 }
 
diff --git a/WAVM/Lib/Platform/CMakeLists.txt b/WAVM/Lib/Platform/CMakeLists.txt
index f495e542..162ce42f 100644
--- a/WAVM/Lib/Platform/CMakeLists.txt
+++ b/WAVM/Lib/Platform/CMakeLists.txt
@@ -65,12 +65,14 @@ else()
 	endif()
 
 	# futimens/utimensat isn't available on MacOS until 10.13.
-	check_symbol_exists(futimens sys/stat.h HAS_FUTIMENS)
+	#check_symbol_exists(futimens sys/stat.h HAS_FUTIMENS)
+	set(HAS_FUTIMENS ON)
 	if(HAS_FUTIMENS)
 		list(APPEND PLATFORM_PRIVATE_DEFINITIONS "HAS_FUTIMENS")
 	endif()
-	check_symbol_exists(utimensat sys/stat.h HAS_UTIMENSAT)
-	if(HAS_FUTIMENS)
+	#check_symbol_exists(utimensat sys/stat.h HAS_UTIMENSAT)
+	set(HAS_UTIMENSAT ON)
+	if(HAS_UTIMENSAT)
 		list(APPEND PLATFORM_PRIVATE_DEFINITIONS "HAS_UTIMENSAT")
 	endif()
 
diff --git a/WAVM/Lib/Platform/POSIX/DiagnosticsPOSIX.cpp b/WAVM/Lib/Platform/POSIX/DiagnosticsPOSIX.cpp
index 9975de2f..097699a4 100644
--- a/WAVM/Lib/Platform/POSIX/DiagnosticsPOSIX.cpp
+++ b/WAVM/Lib/Platform/POSIX/DiagnosticsPOSIX.cpp
@@ -70,20 +70,19 @@ bool Platform::getInstructionSourceByAddress(Uptr ip, InstructionSource& outSour
 		}
 		else
 		{
+			char demangledBuffer[1024];
+			const char* demangledSymbolName = symbolInfo.dli_sname;
 			if(symbolInfo.dli_sname[0] == '_')
 			{
-				int demangleStatus = 0;
-				if(char* demangledBuffer
-				   = abi::__cxa_demangle(symbolInfo.dli_sname, nullptr, nullptr, &demangleStatus))
-				{
-					outSource.function = demangledBuffer;
-					free(demangledBuffer);
-				}
-			}
-			else
-			{
-				outSource.function = symbolInfo.dli_sname;
+				Uptr numDemangledChars = sizeof(demangledBuffer);
+				I32 demangleStatus = 0;
+				if(abi::__cxa_demangle(symbolInfo.dli_sname,
+									   demangledBuffer,
+									   (size_t*)&numDemangledChars,
+									   &demangleStatus))
+				{ demangledSymbolName = demangledBuffer; }
 			}
+			outSource.function = demangledSymbolName;
 			outSource.instructionOffset = ip - reinterpret_cast<Uptr>(symbolInfo.dli_saddr);
 		}
 		return true;
diff --git a/WAVM/Lib/Platform/POSIX/MemoryPOSIX.cpp b/WAVM/Lib/Platform/POSIX/MemoryPOSIX.cpp
index 50dd2a3f..c6f5aed3 100644
--- a/WAVM/Lib/Platform/POSIX/MemoryPOSIX.cpp
+++ b/WAVM/Lib/Platform/POSIX/MemoryPOSIX.cpp
@@ -3,6 +3,7 @@
 #include <sys/mman.h>
 #include <sys/resource.h>
 #include <unistd.h>
+#include <exception>
 #include "POSIXPrivate.h"
 #include "WAVM/Inline/Assert.h"
 #include "WAVM/Inline/BasicTypes.h"
@@ -11,6 +12,10 @@
 #include "WAVM/Platform/Memory.h"
 #include "WAVM/Platform/Mutex.h"
 
+#ifdef WAVM_HAS_TRACY
+#include <Tracy.hpp>
+#endif
+
 #ifdef __APPLE__
 #define MAP_ANONYMOUS MAP_ANON
 #endif
@@ -50,8 +55,22 @@ static bool isPageAligned(U8* address)
 	return (addressBits & (getBytesPerPage() - 1)) == 0;
 }
 
+std::unique_ptr<MemoryOverrideHook> memoryOverrideHook = nullptr;
+
+void Platform::installMemoryOverrideHook(std::unique_ptr<MemoryOverrideHook> hook)
+{
+	if(memoryOverrideHook)
+	{
+		fprintf(stderr, "Trying to double-register memory override hook\n");
+		dumpErrorCallStack(0);
+		std::terminate();
+	}
+	memoryOverrideHook = std::move(hook);
+}
+
 U8* Platform::allocateVirtualPages(Uptr numPages)
 {
+	if(memoryOverrideHook) { return memoryOverrideHook->allocateVirtualPages(numPages); }
 	Uptr numBytes = numPages << getBytesPerPageLog2();
 	void* result = mmap(nullptr, numBytes, PROT_NONE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
 	if(result == MAP_FAILED)
@@ -67,6 +86,10 @@ U8* Platform::allocateVirtualPages(Uptr numPages)
 		}
 		return nullptr;
 	}
+	madvise(result, numBytes, MADV_HUGEPAGE);
+#ifdef WAVM_HAS_TRACY
+	TracyAllocNS(result, numBytes, 6, "WAVM");
+#endif
 	return (U8*)result;
 }
 
@@ -74,6 +97,11 @@ U8* Platform::allocateAlignedVirtualPages(Uptr numPages,
 										  Uptr alignmentLog2,
 										  U8*& outUnalignedBaseAddress)
 {
+	if(memoryOverrideHook)
+	{
+		return memoryOverrideHook->allocateAlignedVirtualPages(
+			numPages, alignmentLog2, outUnalignedBaseAddress);
+	}
 	const Uptr pageSizeLog2 = getBytesPerPageLog2();
 	const Uptr numBytes = numPages << pageSizeLog2;
 	if(alignmentLog2 > pageSizeLog2)
@@ -105,13 +133,21 @@ U8* Platform::allocateAlignedVirtualPages(Uptr numPages,
 		// middle.
 		const Uptr numHeadPaddingBytes = alignedAddress - address;
 		if(numHeadPaddingBytes > 0)
-		{ WAVM_ERROR_UNLESS(!munmap(unalignedBaseAddress, numHeadPaddingBytes)); }
+		{
+			WAVM_ERROR_UNLESS(!munmap(unalignedBaseAddress, numHeadPaddingBytes));
+		}
 
 		const Uptr numTailPaddingBytes = alignmentBytes - (alignedAddress - address);
 		if(numTailPaddingBytes > 0)
-		{ WAVM_ERROR_UNLESS(!munmap(result + (numPages << pageSizeLog2), numTailPaddingBytes)); }
+		{
+			WAVM_ERROR_UNLESS(!munmap(result + (numPages << pageSizeLog2), numTailPaddingBytes));
+		}
 
 		outUnalignedBaseAddress = result;
+		madvise(result, numBytes, MADV_HUGEPAGE);
+#ifdef WAVM_HAS_TRACY
+		TracyAllocNS(result, numBytes, 6, "WAVM");
+#endif
 		return result;
 	}
 	else
@@ -124,6 +160,10 @@ U8* Platform::allocateAlignedVirtualPages(Uptr numPages,
 bool Platform::commitVirtualPages(U8* baseVirtualAddress, Uptr numPages, MemoryAccess access)
 {
 	WAVM_ERROR_UNLESS(isPageAligned(baseVirtualAddress));
+	if(memoryOverrideHook)
+	{
+		return memoryOverrideHook->commitVirtualPages(baseVirtualAddress, numPages, access);
+	}
 	int result = mprotect(
 		baseVirtualAddress, numPages << getBytesPerPageLog2(), memoryAccessAsPOSIXFlag(access));
 	if(result != 0)
@@ -142,6 +182,10 @@ bool Platform::commitVirtualPages(U8* baseVirtualAddress, Uptr numPages, MemoryA
 bool Platform::setVirtualPageAccess(U8* baseVirtualAddress, Uptr numPages, MemoryAccess access)
 {
 	WAVM_ERROR_UNLESS(isPageAligned(baseVirtualAddress));
+	if(memoryOverrideHook)
+	{
+		return memoryOverrideHook->setVirtualPageAccess(baseVirtualAddress, numPages, access);
+	}
 	int result = mprotect(
 		baseVirtualAddress, numPages << getBytesPerPageLog2(), memoryAccessAsPOSIXFlag(access));
 	if(result != 0)
@@ -160,21 +204,37 @@ bool Platform::setVirtualPageAccess(U8* baseVirtualAddress, Uptr numPages, Memor
 void Platform::decommitVirtualPages(U8* baseVirtualAddress, Uptr numPages)
 {
 	WAVM_ERROR_UNLESS(isPageAligned(baseVirtualAddress));
+	if(memoryOverrideHook)
+	{
+		return memoryOverrideHook->decommitVirtualPages(baseVirtualAddress, numPages);
+	}
 	auto numBytes = numPages << getBytesPerPageLog2();
-	if(mmap(baseVirtualAddress, numBytes, PROT_NONE, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
-	   == MAP_FAILED)
+	if(madvise(baseVirtualAddress, numBytes, MADV_DONTNEED) < 0)
 	{
-		Errors::fatalf("mmap(0x%" WAVM_PRIxPTR ", %" WAVM_PRIuPTR
-					   ", PROT_NONE, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0) failed: %s",
+		Errors::fatalf("madvise(0x%" WAVM_PRIxPTR ", %" WAVM_PRIuPTR ", MADV_DONTNEED) failed: %s",
 					   reinterpret_cast<Uptr>(baseVirtualAddress),
 					   numBytes,
 					   strerror(errno));
 	}
+	int result = mprotect(baseVirtualAddress, numBytes, PROT_NONE);
+	if(result != 0)
+	{
+		fprintf(stderr,
+				"mprotect(0x%" WAVM_PRIxPTR ", %" WAVM_PRIuPTR ", PROT_NONE) failed: %s\n",
+				reinterpret_cast<Uptr>(baseVirtualAddress),
+				numPages << getBytesPerPageLog2(),
+				strerror(errno));
+		dumpErrorCallStack(0);
+	}
 }
 
 void Platform::freeVirtualPages(U8* baseVirtualAddress, Uptr numPages)
 {
 	WAVM_ERROR_UNLESS(isPageAligned(baseVirtualAddress));
+	if(memoryOverrideHook)
+	{
+		return memoryOverrideHook->freeVirtualPages(baseVirtualAddress, numPages);
+	}
 	if(munmap(baseVirtualAddress, numPages << getBytesPerPageLog2()))
 	{
 		Errors::fatalf("munmap(0x%" WAVM_PRIxPTR ", %u) failed: %s",
@@ -182,11 +242,19 @@ void Platform::freeVirtualPages(U8* baseVirtualAddress, Uptr numPages)
 					   numPages << getBytesPerPageLog2(),
 					   strerror(errno));
 	}
+#ifdef WAVM_HAS_TRACY
+	TracyFreeNS(baseVirtualAddress, 6, "WAVM");
+#endif
 }
 
 void Platform::freeAlignedVirtualPages(U8* unalignedBaseAddress, Uptr numPages, Uptr alignmentLog2)
 {
 	WAVM_ERROR_UNLESS(isPageAligned(unalignedBaseAddress));
+	if(memoryOverrideHook)
+	{
+		return memoryOverrideHook->freeAlignedVirtualPages(
+			unalignedBaseAddress, numPages, alignmentLog2);
+	}
 	if(munmap(unalignedBaseAddress, numPages << getBytesPerPageLog2()))
 	{
 		Errors::fatalf("munmap(0x%" WAVM_PRIxPTR ", %u) failed: %s",
@@ -194,6 +262,9 @@ void Platform::freeAlignedVirtualPages(U8* unalignedBaseAddress, Uptr numPages,
 					   numPages << getBytesPerPageLog2(),
 					   strerror(errno));
 	}
+#ifdef WAVM_HAS_TRACY
+	TracyFreeNS(unalignedBaseAddress, 6, "WAVM");
+#endif
 }
 
 Uptr Platform::getPeakMemoryUsageBytes()
diff --git a/WAVM/Lib/Platform/POSIX/SignalPOSIX.cpp b/WAVM/Lib/Platform/POSIX/SignalPOSIX.cpp
index 592a16b9..769f4869 100644
--- a/WAVM/Lib/Platform/POSIX/SignalPOSIX.cpp
+++ b/WAVM/Lib/Platform/POSIX/SignalPOSIX.cpp
@@ -44,7 +44,8 @@ static void maskSignals(int how)
 	sigemptyset(&set);
 	sigaddset(&set, SIGFPE);
 	sigaddset(&set, SIGSEGV);
-	sigaddset(&set, SIGBUS);
+	sigaddset(&set, SIGALRM);
+	// sigaddset(&set, SIGBUS);
 	pthread_sigmask(how, &set, nullptr);
 }
 
@@ -59,7 +60,9 @@ static void maskSignals(int how)
 	{
 	case SIGFPE:
 		if(signalInfo->si_code != FPE_INTDIV && signalInfo->si_code != FPE_INTOVF)
-		{ Errors::fatalfWithCallStack("unknown SIGFPE code"); }
+		{
+			Errors::fatalfWithCallStack("unknown SIGFPE code");
+		}
 		signal.type = Signal::Type::intDivideByZeroOrOverflow;
 		break;
 	case SIGSEGV:
@@ -75,6 +78,10 @@ static void maskSignals(int how)
 		signal.accessViolation.address = reinterpret_cast<Uptr>(signalInfo->si_addr);
 		break;
 	}
+	case SIGALRM: {
+		signal.type = Signal::Type::timeout;
+		break;
+	}
 	default: Errors::fatalfWithCallStack("unknown signal number: %i", signalNumber); break;
 	};
 
@@ -105,6 +112,7 @@ static void maskSignals(int how)
 	case SIGFPE: Errors::fatalfWithCallStack("unhandled SIGFPE");
 	case SIGSEGV: Errors::fatalfWithCallStack("unhandled SIGSEGV");
 	case SIGBUS: Errors::fatalfWithCallStack("unhandled SIGBUS");
+	case SIGALRM: Errors::fatalfWithCallStack("unhandled SIGALRM");
 	default: WAVM_UNREACHABLE();
 	};
 }
@@ -117,8 +125,9 @@ bool Platform::initGlobalSignalsOnce()
 	signalAction.sa_flags = SA_SIGINFO | SA_ONSTACK | SA_NODEFER;
 	sigemptyset(&signalAction.sa_mask);
 	WAVM_ERROR_UNLESS(!sigaction(SIGSEGV, &signalAction, nullptr));
-	WAVM_ERROR_UNLESS(!sigaction(SIGBUS, &signalAction, nullptr));
+	// WAVM_ERROR_UNLESS(!sigaction(SIGBUS, &signalAction, nullptr));
 	WAVM_ERROR_UNLESS(!sigaction(SIGFPE, &signalAction, nullptr));
+	WAVM_ERROR_UNLESS(!sigaction(SIGALRM, &signalAction, nullptr));
 
 	return true;
 }
@@ -171,8 +180,7 @@ static void visitFDEs(const U8* ehFrames, Uptr numBytes, void (*visitFDE)(const
 {
 	const U8* next = ehFrames;
 	const U8* end = ehFrames + numBytes;
-	do
-	{
+	do {
 		const U8* cfi = next;
 		Uptr numCFIBytes = *((const U32*)next);
 		next += 4;
diff --git a/WAVM/Lib/Platform/POSIX/ThreadPOSIX.cpp b/WAVM/Lib/Platform/POSIX/ThreadPOSIX.cpp
index d3241349..18565632 100644
--- a/WAVM/Lib/Platform/POSIX/ThreadPOSIX.cpp
+++ b/WAVM/Lib/Platform/POSIX/ThreadPOSIX.cpp
@@ -173,7 +173,7 @@ WAVM_NO_ASAN static void touchStackPages(U8* minAddr, Uptr numBytesPerPage)
 		sum += *touchAddr;
 		if(touchAddr < minAddr + numBytesPerPage) { break; }
 	}
-	WAVM_SUPPRESS_UNUSED(sum);
+	(void)sum;
 }
 
 bool Platform::initThreadAndGlobalSignalsOnce()
diff --git a/WAVM/Lib/Runtime/Compartment.cpp b/WAVM/Lib/Runtime/Compartment.cpp
index b202203a..08e76053 100644
--- a/WAVM/Lib/Runtime/Compartment.cpp
+++ b/WAVM/Lib/Runtime/Compartment.cpp
@@ -11,6 +11,10 @@
 #include "WAVM/Runtime/Runtime.h"
 #include "WAVM/RuntimeABI/RuntimeABI.h"
 
+#ifdef WAVM_HAS_TRACY
+#include <Tracy.hpp>
+#endif
+
 using namespace WAVM;
 using namespace WAVM::Runtime;
 
@@ -77,73 +81,178 @@ Compartment* Runtime::createCompartment(std::string&& debugName)
 
 Compartment* Runtime::cloneCompartment(const Compartment* compartment, std::string&& debugName)
 {
-	Timing::Timer timer;
+	Compartment* newCompartment;
 
 	U8* unalignedRuntimeData = nullptr;
 	CompartmentRuntimeData* runtimeData = initCompartmentRuntimeData(unalignedRuntimeData);
 	if(!runtimeData) { return nullptr; }
 
-	Compartment* newCompartment
-		= new Compartment(std::move(debugName), runtimeData, unalignedRuntimeData);
-	if(!newCompartment) { goto error; }
-	else
 	{
-		Platform::RWMutex::ShareableLock compartmentLock(compartment->mutex);
+#ifdef WAVM_HAS_TRACY
+		ZoneNamedN(_zone_nc, "new Compartment", true);
+#endif
+		newCompartment = new Compartment(std::move(debugName), runtimeData, unalignedRuntimeData);
+		;
+	}
+	Runtime::cloneCompartmentInto(*newCompartment, compartment, std::move(debugName));
+	return newCompartment;
+}
 
-		// Clone tables.
-		for(Table* table : compartment->tables)
+namespace {
+	template<class T = Runtime::GCObject*>
+	void clearIndexMap(Runtime::Compartment* ownerCompartment,
+					   WAVM::IndexMap<WAVM::Uptr, T>& indexMap)
+	{
+		Platform::RWMutex::ExclusiveLock lock(ownerCompartment->mutex);
+		for(T p : indexMap)
 		{
-			Table* newTable = cloneTable(table, newCompartment);
-			if(!newTable) { goto error; }
-			WAVM_ASSERT(newTable->id == table->id);
+			Runtime::GCObject* gp = p;
+			if(gp->compartment == ownerCompartment)
+			{
+				if(gp->numRootReferences.load() != 0)
+				{
+					throw std::runtime_error("Removed GCObject still has root references alive");
+				}
+				delete p;
+			}
 		}
+		indexMap = WAVM::IndexMap<WAVM::Uptr, T>(indexMap.getMinIndex(), indexMap.getMaxIndex());
+	}
 
-		// Clone memories.
-		for(Memory* memory : compartment->memories)
+	template<class T = Runtime::GCObject*>
+	void clearRemainingIndexMap(Runtime::Compartment* ownerCompartment,
+								WAVM::IndexMap<WAVM::Uptr, T>& indexMap,
+								const WAVM::HashSet<WAVM::Uptr>& ignoreList,
+								std::vector<WAVM::Uptr>& removeList)
+	{
+		Platform::RWMutex::ExclusiveLock lock(ownerCompartment->mutex);
+		removeList.clear();
+		for(auto it = indexMap.begin(); it != indexMap.end(); ++it)
 		{
-			Memory* newMemory = cloneMemory(memory, newCompartment);
-			if(!newMemory) { goto error; }
-			WAVM_ASSERT(newMemory->id == memory->id);
+			const WAVM::Uptr idx = it.getIndex();
+			if(!ignoreList.contains(idx)) { removeList.push_back(idx); }
 		}
-
-		// Clone globals.
-		newCompartment->globalDataAllocationMask = compartment->globalDataAllocationMask;
-		memcpy(newCompartment->initialContextMutableGlobals,
-			   compartment->initialContextMutableGlobals,
-			   sizeof(newCompartment->initialContextMutableGlobals));
-		for(Global* global : compartment->globals)
+		for(WAVM::Uptr idx : removeList)
 		{
-			Global* newGlobal = cloneGlobal(global, newCompartment);
-			if(!newGlobal) { goto error; }
-			WAVM_ASSERT(newGlobal->id == global->id);
-			WAVM_ASSERT(newGlobal->mutableGlobalIndex == global->mutableGlobalIndex);
+			T p = *indexMap.get(idx);
+			Runtime::GCObject* gp = p;
+			if(gp->compartment == ownerCompartment)
+			{
+				if(gp->numRootReferences.load() != 0)
+				{
+					throw std::runtime_error("Removed GCObject still has root references alive");
+				}
+				delete p;
+			}
+			indexMap.removeOrFail(idx);
 		}
+	}
+}
+
+WAVM_API void Runtime::cloneCompartmentInto(Compartment& targetCompartment,
+											const Compartment* oldCompartment,
+											std::string&& debugName)
+{
+#ifdef WAVM_HAS_TRACY
+	ZoneNamedNS(_zone_root, "Runtime::cloneCompartmentInto", 6, true);
+#endif
+	Platform::RWMutex::ShareableLock compartmentLock(oldCompartment->mutex);
+	Timing::Timer timer;
+	WAVM::HashSet<WAVM::Uptr> ignoreIndexList(32);
+	std::vector<WAVM::Uptr> removeList;
+	removeList.reserve(32);
 
-		// Clone exception types.
-		for(ExceptionType* exceptionType : compartment->exceptionTypes)
+	// Reset structures
+	clearIndexMap(&targetCompartment, targetCompartment.contexts);
+	clearIndexMap(&targetCompartment, targetCompartment.foreigns);
+
+	// Clone tables.
+	ignoreIndexList.clear();
+	for(auto it = oldCompartment->tables.begin(); it != oldCompartment->tables.end(); ++it)
+	{
+		const WAVM::Uptr idx = it.getIndex();
+		ignoreIndexList.addOrFail(idx);
+		if(targetCompartment.tables.contains(idx))
 		{
-			ExceptionType* newExceptionType = cloneExceptionType(exceptionType, newCompartment);
-			if(!newExceptionType) { goto error; }
-			WAVM_ASSERT(newExceptionType->id == exceptionType->id);
+			const Table* oldTable = *it;
+			Table* newTable = *targetCompartment.tables.get(idx);
+			cloneTableInto(newTable, oldTable, &targetCompartment);
 		}
+		else
+		{
+			Table* newTable = cloneTable(*it, &targetCompartment);
+			WAVM_ASSERT(newTable->id == (*it)->id);
+		}
+	}
+	clearRemainingIndexMap(
+		&targetCompartment, targetCompartment.memories, ignoreIndexList, removeList);
 
-		// Clone instances.
-		for(Instance* instance : compartment->instances)
+	// Clone memories.
+	// for(Memory* memory : oldCompartment->memories)
+	ignoreIndexList.clear();
+	for(auto it = oldCompartment->memories.begin(); it != oldCompartment->memories.end(); ++it)
+	{
+		const WAVM::Uptr idx = it.getIndex();
+		ignoreIndexList.addOrFail(idx);
+		if(targetCompartment.memories.contains(idx))
 		{
-			Instance* newInstance = cloneInstance(instance, newCompartment);
-			if(!newInstance) { goto error; }
-			WAVM_ASSERT(newInstance->id == instance->id);
+			const Memory* oldMemory = *it;
+			Memory* newMemory = *targetCompartment.memories.get(idx);
+			cloneMemoryInto(newMemory, oldMemory, &targetCompartment);
 		}
+		else
+		{
+			Memory* newMemory = cloneMemory(*it, &targetCompartment);
+			WAVM_ASSERT(newMemory->id == (*it)->id);
+		}
+	}
+	clearRemainingIndexMap(
+		&targetCompartment, targetCompartment.memories, ignoreIndexList, removeList);
+
+	// Clone globals.
+	clearIndexMap(&targetCompartment, targetCompartment.globals);
+	{
+#ifdef WAVM_HAS_TRACY
+		ZoneNamedN(_zone_mcg, "memcpy Globals", true);
+#endif
+		targetCompartment.globalDataAllocationMask = oldCompartment->globalDataAllocationMask;
+		memcpy(targetCompartment.initialContextMutableGlobals,
+			   oldCompartment->initialContextMutableGlobals,
+			   sizeof(targetCompartment.initialContextMutableGlobals));
+	}
+	for(Global* global : oldCompartment->globals)
+	{
+#ifdef WAVM_HAS_TRACY
+		ZoneNamedN(_zone_cg, "clone Global", true);
+#endif
+		Global* newGlobal = cloneGlobal(global, &targetCompartment);
+		WAVM_ASSERT(newGlobal->id == global->id);
+		WAVM_ASSERT(newGlobal->mutableGlobalIndex == global->mutableGlobalIndex);
+	}
 
-		Timing::logTimer("Cloned compartment", timer);
-		return newCompartment;
+	// Clone exception types.
+	clearIndexMap(&targetCompartment, targetCompartment.exceptionTypes);
+	for(ExceptionType* exceptionType : oldCompartment->exceptionTypes)
+	{
+#ifdef WAVM_HAS_TRACY
+		ZoneNamedN(_zone_cet, "clone ExceptionType", true);
+#endif
+		ExceptionType* newExceptionType = cloneExceptionType(exceptionType, &targetCompartment);
+		WAVM_ASSERT(newExceptionType->id == exceptionType->id);
+	}
+
+	// Clone instances.
+	clearIndexMap(&targetCompartment, targetCompartment.instances);
+	for(Instance* instance : oldCompartment->instances)
+	{
+#ifdef WAVM_HAS_TRACY
+		ZoneNamedN(_zone_ci, "clone Instance", true);
+#endif
+		Instance* newInstance = cloneInstance(instance, &targetCompartment);
+		WAVM_ASSERT(newInstance->id == instance->id);
 	}
 
-error:
-	// If there was an error, clean up the partially created compartment.
-	if(newCompartment)
-	{ WAVM_ERROR_UNLESS(tryCollectCompartment(GCPointer<Compartment>(newCompartment))); }
-	return nullptr;
+	Timing::logTimer("Cloned compartment", timer);
 }
 
 Object* Runtime::remapToClonedCompartment(const Object* object, const Compartment* newCompartment)
diff --git a/WAVM/Lib/Runtime/Exception.cpp b/WAVM/Lib/Runtime/Exception.cpp
index cd20a4c8..cad2ba7a 100644
--- a/WAVM/Lib/Runtime/Exception.cpp
+++ b/WAVM/Lib/Runtime/Exception.cpp
@@ -333,6 +333,7 @@ static bool isRuntimeException(const Platform::Signal& signal)
 			   || isAddressOwnedByMemory(badPointer, memory, memoryAddress);
 	}
 	case Platform::Signal::Type::stackOverflow:
+	case Platform::Signal::Type::timeout:
 	case Platform::Signal::Type::intDivideByZeroOrOverflow: return true;
 
 	case Platform::Signal::Type::invalid:
@@ -382,6 +383,10 @@ static void translateSignalToRuntimeException(const Platform::Signal& signal,
 		outException = createException(
 			ExceptionTypes::integerDivideByZeroOrOverflow, nullptr, 0, std::move(callStack));
 		break;
+	case Platform::Signal::Type::timeout:
+		outException = createException(
+			ExceptionTypes::timeout, nullptr, 0, std::move(callStack));
+		break;
 
 	case Platform::Signal::Type::invalid:
 	default: WAVM_UNREACHABLE();
diff --git a/WAVM/Lib/Runtime/Global.cpp b/WAVM/Lib/Runtime/Global.cpp
index 3ff1c185..0788a270 100644
--- a/WAVM/Lib/Runtime/Global.cpp
+++ b/WAVM/Lib/Runtime/Global.cpp
@@ -24,7 +24,10 @@ Global* Runtime::createGlobal(Compartment* compartment,
 	if(type.isMutable)
 	{
 		mutableGlobalIndex = compartment->globalDataAllocationMask.getSmallestNonMember();
-		if(mutableGlobalIndex == maxMutableGlobals) { return nullptr; }
+		if(mutableGlobalIndex == maxMutableGlobals) { 
+            printf("ERROR: Hit WAVM maxMutableGlobals: %lu\n", maxMutableGlobals);
+            return nullptr; 
+        }
 		compartment->globalDataAllocationMask.add(mutableGlobalIndex);
 
 		// Zero-initialize the global's mutable value for all current and future contexts.
@@ -40,6 +43,7 @@ Global* Runtime::createGlobal(Compartment* compartment,
 		global->id = compartment->globals.add(UINTPTR_MAX, global);
 		if(global->id == UINTPTR_MAX)
 		{
+            printf("ERROR: WAVM unable to add global\n");
 			delete global;
 			return nullptr;
 		}
diff --git a/WAVM/Lib/Runtime/Instance.cpp b/WAVM/Lib/Runtime/Instance.cpp
index dcabf333..3dc340fa 100644
--- a/WAVM/Lib/Runtime/Instance.cpp
+++ b/WAVM/Lib/Runtime/Instance.cpp
@@ -16,6 +16,10 @@
 #include "WAVM/Runtime/Runtime.h"
 #include "WAVM/WASM/WASM.h"
 
+#ifdef WAVM_HAS_TRACY
+#include <Tracy.hpp>
+#endif
+
 using namespace WAVM;
 using namespace WAVM::IR;
 using namespace WAVM::Runtime;
@@ -156,6 +160,9 @@ Instance* Runtime::instantiateModuleInternal(Compartment* compartment,
 											 std::string&& moduleDebugName,
 											 ResourceQuotaRefParam resourceQuota)
 {
+#ifdef WAVM_HAS_TRACY
+	ZoneNamedN(_zimi, "instantiateModuleInternal", true);
+#endif
 	WAVM_ASSERT(functionImports.size() == module->ir.functions.imports.size());
 	WAVM_ASSERT(tables.size() == module->ir.tables.imports.size());
 	WAVM_ASSERT(memories.size() == module->ir.memories.imports.size());
@@ -243,20 +250,26 @@ Instance* Runtime::instantiateModuleInternal(Compartment* compartment,
 	}
 
 	// Set up the values to bind to the symbols in the LLVMJIT object code.
-	HashMap<std::string, LLVMJIT::FunctionBinding> wavmIntrinsicsExportMap;
+	auto uninstantiatedFunctions = Intrinsics::getUninstantiatedFunctions(
+		{WAVM_INTRINSIC_MODULE_REF(wavmIntrinsics),
+		 WAVM_INTRINSIC_MODULE_REF(wavmIntrinsicsAtomics),
+		 WAVM_INTRINSIC_MODULE_REF(wavmIntrinsicsException),
+		 WAVM_INTRINSIC_MODULE_REF(wavmIntrinsicsMemory),
+		 WAVM_INTRINSIC_MODULE_REF(wavmIntrinsicsTable)});
+	HashMap<std::string, LLVMJIT::FunctionBinding> wavmIntrinsicsExportMap(
+		uninstantiatedFunctions.size());
 	for(const HashMapPair<std::string, Intrinsics::Function*>& intrinsicFunctionPair :
-		Intrinsics::getUninstantiatedFunctions({WAVM_INTRINSIC_MODULE_REF(wavmIntrinsics),
-												WAVM_INTRINSIC_MODULE_REF(wavmIntrinsicsAtomics),
-												WAVM_INTRINSIC_MODULE_REF(wavmIntrinsicsException),
-												WAVM_INTRINSIC_MODULE_REF(wavmIntrinsicsMemory),
-												WAVM_INTRINSIC_MODULE_REF(wavmIntrinsicsTable)}))
+		uninstantiatedFunctions)
 	{
 		LLVMJIT::FunctionBinding functionBinding{intrinsicFunctionPair.value->getNativeFunction()};
 		wavmIntrinsicsExportMap.add(intrinsicFunctionPair.key, functionBinding);
 	}
+	uninstantiatedFunctions.clear();
 
 	std::vector<Function*> functions;
+	functions.reserve(module->ir.functions.imports.size());
 	std::vector<LLVMJIT::FunctionBinding> jitFunctionImports;
+	jitFunctionImports.reserve(module->ir.functions.imports.size());
 	for(Uptr importIndex = 0; importIndex < module->ir.functions.imports.size(); ++importIndex)
 	{
 		const FunctionType functionType
@@ -274,12 +287,15 @@ Instance* Runtime::instantiateModuleInternal(Compartment* compartment,
 	}
 
 	std::vector<LLVMJIT::TableBinding> jitTables;
+	jitTables.reserve(tables.size());
 	for(Table* table : tables) { jitTables.push_back({table->id}); }
 
 	std::vector<LLVMJIT::MemoryBinding> jitMemories;
+	jitMemories.reserve(memories.size());
 	for(Memory* memory : memories) { jitMemories.push_back({memory->id}); }
 
 	std::vector<LLVMJIT::GlobalBinding> jitGlobals;
+	jitGlobals.reserve(globals.size());
 	for(Global* global : globals)
 	{
 		LLVMJIT::GlobalBinding globalSpec;
@@ -293,20 +309,38 @@ Instance* Runtime::instantiateModuleInternal(Compartment* compartment,
 	}
 
 	std::vector<LLVMJIT::ExceptionTypeBinding> jitExceptionTypes;
+	jitExceptionTypes.reserve(exceptionTypes.size());
 	for(ExceptionType* exceptionType : exceptionTypes)
-	{ jitExceptionTypes.push_back({exceptionType->id}); }
+	{
+		jitExceptionTypes.push_back({exceptionType->id});
+	}
 
 	// Create a FunctionMutableData for each function definition.
 	std::vector<FunctionMutableData*> functionDefMutableDatas;
+	functionDefMutableDatas.reserve(module->ir.functions.defs.size());
 	for(Uptr functionDefIndex = 0; functionDefIndex < module->ir.functions.defs.size();
 		++functionDefIndex)
 	{
-		std::string debugName
+		const std::string& origDebugName
 			= disassemblyNames.functions[module->ir.functions.imports.size() + functionDefIndex]
 				  .name;
-		if(!debugName.size())
-		{ debugName = "<function #" + std::to_string(functionDefIndex) + ">"; }
-		debugName = "wasm!" + moduleDebugName + '!' + debugName;
+		std::string debugName;
+		debugName.reserve(7 + moduleDebugName.size()
+						  + (origDebugName.empty() ? 16 : debugName.size()));
+		debugName.insert(debugName.size(), "wasm!");
+		debugName.insert(debugName.size(), moduleDebugName);
+		debugName.push_back('!');
+		if(!origDebugName.size())
+		{
+			debugName.reserve(16);
+			debugName.insert(debugName.size(), "<function #");
+			debugName.insert(debugName.size(), std::to_string(functionDefIndex));
+			debugName.push_back('>');
+		}
+		else
+		{
+			debugName.insert(debugName.size(), origDebugName);
+		}
 
 		functionDefMutableDatas.push_back(new FunctionMutableData(std::move(debugName)));
 	}
@@ -331,12 +365,16 @@ Instance* Runtime::instantiateModuleInternal(Compartment* compartment,
 
 	// LLVMJIT::loadModule filled in the functionDefMutableDatas' function pointers with the
 	// compiled functions. Add those functions to the module.
+	functions.reserve(functionDefMutableDatas.size());
 	for(FunctionMutableData* functionMutableData : functionDefMutableDatas)
-	{ functions.push_back(functionMutableData->function); }
+	{
+		functions.push_back(functionMutableData->function);
+	}
 
 	// Set up the instance's exports.
-	HashMap<std::string, Object*> exportMap;
+	HashMap<std::string, Object*> exportMap(module->ir.exports.size());
 	std::vector<Object*> exports;
+	exports.reserve(module->ir.exports.size());
 	for(const Export& exportIt : module->ir.exports)
 	{
 		Object* exportedObject = nullptr;
@@ -362,9 +400,13 @@ Instance* Runtime::instantiateModuleInternal(Compartment* compartment,
 
 	// Copy the module's data and elem segments into the Instance for later use.
 	DataSegmentVector dataSegments;
+	dataSegments.reserve(module->ir.dataSegments.size());
 	ElemSegmentVector elemSegments;
+	elemSegments.reserve(module->ir.elemSegments.size());
 	for(const DataSegment& dataSegment : module->ir.dataSegments)
-	{ dataSegments.push_back(dataSegment.isActive ? nullptr : dataSegment.data); }
+	{
+		dataSegments.push_back(dataSegment.isActive ? nullptr : dataSegment.data);
+	}
 	for(const ElemSegment& elemSegment : module->ir.elemSegments)
 	{
 		elemSegments.push_back(elemSegment.type == ElemSegment::Type::passive ? elemSegment.contents
@@ -477,42 +519,59 @@ Instance* Runtime::instantiateModuleInternal(Compartment* compartment,
 Instance* Runtime::cloneInstance(Instance* instance, Compartment* newCompartment)
 {
 	// Remap the module's references to the cloned compartment.
-	HashMap<std::string, Object*> newExportMap;
+	HashMap<std::string, Object*> newExportMap(instance->exportMap.size());
 	for(const auto& pair : instance->exportMap)
-	{ newExportMap.add(pair.key, remapToClonedCompartment(pair.value, newCompartment)); }
+	{
+		newExportMap.add(pair.key, remapToClonedCompartment(pair.value, newCompartment));
+	}
 	std::vector<Object*> newExports;
+	newExports.reserve(instance->exports.size());
 	for(Object* exportObject : instance->exports)
-	{ newExports.push_back(remapToClonedCompartment(exportObject, newCompartment)); }
+	{
+		newExports.push_back(remapToClonedCompartment(exportObject, newCompartment));
+	}
 
 	std::vector<Function*> newFunctions = instance->functions;
 
 	std::vector<Table*> newTables;
+	newTables.reserve(instance->tables.size());
 	for(Table* table : instance->tables)
-	{ newTables.push_back(remapToClonedCompartment(table, newCompartment)); }
+	{
+		newTables.push_back(remapToClonedCompartment(table, newCompartment));
+	}
 
 	std::vector<Memory*> newMemories;
+	newMemories.reserve(instance->memories.size());
 	for(Memory* memory : instance->memories)
-	{ newMemories.push_back(remapToClonedCompartment(memory, newCompartment)); }
+	{
+		newMemories.push_back(remapToClonedCompartment(memory, newCompartment));
+	}
 
 	std::vector<Global*> newGlobals;
+	newGlobals.reserve(instance->globals.size());
 	for(Global* global : instance->globals)
-	{ newGlobals.push_back(remapToClonedCompartment(global, newCompartment)); }
+	{
+		newGlobals.push_back(remapToClonedCompartment(global, newCompartment));
+	}
 
 	std::vector<ExceptionType*> newExceptionTypes;
+	newExceptionTypes.reserve(instance->exceptionTypes.size());
 	for(ExceptionType* exceptionType : instance->exceptionTypes)
-	{ newExceptionTypes.push_back(remapToClonedCompartment(exceptionType, newCompartment)); }
+	{
+		newExceptionTypes.push_back(remapToClonedCompartment(exceptionType, newCompartment));
+	}
 
 	Function* newStartFunction = remapToClonedCompartment(instance->startFunction, newCompartment);
 
 	DataSegmentVector newDataSegments;
 	{
-		Platform::RWMutex::ExclusiveLock passiveDataSegmentsLock(instance->dataSegmentsMutex);
+		Platform::RWMutex::ShareableLock passiveDataSegmentsLock(instance->dataSegmentsMutex);
 		newDataSegments = instance->dataSegments;
 	}
 
 	ElemSegmentVector newElemSegments;
 	{
-		Platform::RWMutex::ExclusiveLock passiveElemSegmentsLock(instance->elemSegmentsMutex);
+		Platform::RWMutex::ShareableLock passiveElemSegmentsLock(instance->elemSegmentsMutex);
 		newElemSegments = instance->elemSegments;
 	}
 
diff --git a/WAVM/Lib/Runtime/Intrinsics.cpp b/WAVM/Lib/Runtime/Intrinsics.cpp
index 09a5f905..d43b3b25 100644
--- a/WAVM/Lib/Runtime/Intrinsics.cpp
+++ b/WAVM/Lib/Runtime/Intrinsics.cpp
@@ -17,6 +17,10 @@
 #include "WAVM/Platform/RWMutex.h"
 #include "WAVM/Runtime/Runtime.h"
 
+#ifdef WAVM_HAS_TRACY
+#include <Tracy.hpp>
+#endif
+
 namespace WAVM { namespace Intrinsics {
 	struct ModuleImpl
 	{
@@ -50,7 +54,9 @@ Intrinsics::Function::Function(Intrinsics::Module* moduleRef,
 	initializeModule(moduleRef);
 
 	if(moduleRef->impl->functionMap.contains(name))
-	{ Errors::fatalf("Intrinsic function already registered: %s", name); }
+	{
+		Errors::fatalf("Intrinsic function already registered: %s", name);
+	}
 	moduleRef->impl->functionMap.set(name, this);
 }
 
@@ -63,7 +69,9 @@ Intrinsics::Global::Global(Intrinsics::Module* moduleRef,
 	initializeModule(moduleRef);
 
 	if(moduleRef->impl->globalMap.contains(name))
-	{ Errors::fatalf("Intrinsic global already registered: %s", name); }
+	{
+		Errors::fatalf("Intrinsic global already registered: %s", name);
+	}
 	moduleRef->impl->globalMap.set(name, this);
 }
 
@@ -73,7 +81,9 @@ Intrinsics::Table::Table(Intrinsics::Module* moduleRef, const char* inName, cons
 	initializeModule(moduleRef);
 
 	if(moduleRef->impl->tableMap.contains(name))
-	{ Errors::fatalf("Intrinsic table already registered: %s", name); }
+	{
+		Errors::fatalf("Intrinsic table already registered: %s", name);
+	}
 	moduleRef->impl->tableMap.set(name, this);
 }
 
@@ -85,7 +95,9 @@ Intrinsics::Memory::Memory(Intrinsics::Module* moduleRef,
 	initializeModule(moduleRef);
 
 	if(moduleRef->impl->memoryMap.contains(name))
-	{ Errors::fatalf("Intrinsic memory already registered: %s", name); }
+	{
+		Errors::fatalf("Intrinsic memory already registered: %s", name);
+	}
 	moduleRef->impl->memoryMap.set(name, this);
 }
 
@@ -94,6 +106,9 @@ Instance* Intrinsics::instantiateModule(
 	const std::initializer_list<const Intrinsics::Module*>& moduleRefs,
 	std::string&& debugName)
 {
+#ifdef WAVM_HAS_TRACY
+	ZoneScopedN("Intrinsics::instantiateModule");
+#endif
 	Timing::Timer timer;
 
 	IR::Module irModule(FeatureLevel::wavm);
@@ -105,6 +120,13 @@ Instance* Intrinsics::instantiateModule(
 	{
 		if(moduleRef->impl)
 		{
+			size_t reserveSize = moduleRef->impl->functionMap.size();
+			functionImportBindings.reserve(reserveSize);
+			irModule.types.reserve(reserveSize);
+			irModule.types.reserve(reserveSize);
+			irModule.functions.imports.reserve(reserveSize);
+			irModule.imports.reserve(reserveSize);
+			names.functions.reserve(reserveSize);
 			for(const auto& pair : moduleRef->impl->functionMap)
 			{
 				functionImportBindings.push_back({pair.value->getNativeFunction()});
@@ -178,6 +200,13 @@ Instance* Intrinsics::instantiateModule(
 		}
 	}
 
+	{
+		size_t reserveSize = irModule.functions.imports.size();
+		irModule.types.reserve(reserveSize);
+		irModule.functions.defs.reserve(reserveSize);
+		names.functions.reserve(reserveSize);
+		irModule.exports.reserve(reserveSize);
+	}
 	// Generate thunks for the intrinsic functions.
 	for(Uptr functionImportIndex = 0; functionImportIndex < irModule.functions.imports.size();
 		++functionImportIndex)
@@ -194,7 +223,9 @@ Instance* Intrinsics::instantiateModule(
 		Serialization::ArrayOutputStream codeStream;
 		OperatorEncoderStream opEncoder(codeStream);
 		for(Uptr paramIndex = 0; paramIndex < intrinsicFunctionType.params().size(); ++paramIndex)
-		{ opEncoder.local_get({paramIndex}); }
+		{
+			opEncoder.local_get({paramIndex});
+		}
 		opEncoder.call({functionImportIndex});
 		opEncoder.end();
 
@@ -205,7 +236,9 @@ Instance* Intrinsics::instantiateModule(
 			{functionImport.exportName, ExternKind::function, wasmFunctionIndex});
 	}
 
-	setDisassemblyNames(irModule, names);
+	{
+		setDisassemblyNames(irModule, names);
+	}
 
 	if(WAVM_ENABLE_ASSERTS)
 	{
@@ -224,7 +257,13 @@ Instance* Intrinsics::instantiateModule(
 		}
 	}
 
-	ModuleRef module = compileModule(irModule);
+	ModuleRef module;
+	{
+#ifdef WAVM_HAS_TRACY
+		ZoneNamedN(_zc, "compileModule", true);
+#endif
+		module = compileModule(irModule);
+	}
 	Instance* instance = instantiateModuleInternal(compartment,
 												   module,
 												   std::move(functionImportBindings),
@@ -248,7 +287,9 @@ HashMap<std::string, Intrinsics::Function*> Intrinsics::getUninstantiatedFunctio
 		if(moduleRef->impl)
 		{
 			for(const auto& pair : moduleRef->impl->functionMap)
-			{ result.addOrFail(pair.key, pair.value); }
+			{
+				result.addOrFail(pair.key, pair.value);
+			}
 		}
 	}
 
diff --git a/WAVM/Lib/Runtime/Memory.cpp b/WAVM/Lib/Runtime/Memory.cpp
index 89f7a489..9e0fa88b 100644
--- a/WAVM/Lib/Runtime/Memory.cpp
+++ b/WAVM/Lib/Runtime/Memory.cpp
@@ -15,6 +15,11 @@
 #include "WAVM/Platform/RWMutex.h"
 #include "WAVM/Runtime/Runtime.h"
 #include "WAVM/RuntimeABI/RuntimeABI.h"
+#ifdef WAVM_HAS_TRACY
+#include <Tracy.hpp>
+#endif
+
+#include "wasmbounds_rr.hpp"
 
 using namespace WAVM;
 using namespace WAVM::Runtime;
@@ -45,6 +50,9 @@ static Memory* createMemoryImpl(Compartment* compartment,
 								std::string&& debugName,
 								ResourceQuotaRefParam resourceQuota)
 {
+#ifdef WAVM_HAS_TRACY
+	ZoneNamedNS(_zone_root, "Memory::createMemoryImpl", 6, true);
+#endif
 	Memory* memory = new Memory(compartment, type, std::move(debugName), resourceQuota);
 
 	const Uptr pageBytesLog2 = Platform::getBytesPerPageLog2();
@@ -69,7 +77,14 @@ static Memory* createMemoryImpl(Compartment* compartment,
 	}
 
 	const Uptr numGuardPages = memoryNumGuardBytes >> pageBytesLog2;
-	memory->baseAddress = Platform::allocateVirtualPages(memoryMaxPages + numGuardPages);
+	{
+#ifdef WAVM_HAS_TRACY
+		ZoneScopedN("allocateVirtualPages");
+		ZoneValue(memoryMaxPages + numGuardPages);
+#endif
+		memory->baseAddress = resizableRegionAllocator->allocateRegion(
+			0, ((memoryMaxPages << pageBytesLog2) + memoryNumGuardBytes));
+	}
 	memory->numReservedBytes = memoryMaxPages << pageBytesLog2;
 	if(!memory->baseAddress)
 	{
@@ -77,19 +92,28 @@ static Memory* createMemoryImpl(Compartment* compartment,
 		return nullptr;
 	}
 
-	// Grow the memory to the type's minimum size.
-	if(growMemory(memory, type.size.min) != GrowResult::success)
 	{
-		delete memory;
-		return nullptr;
+#ifdef WAVM_HAS_TRACY
+		ZoneNamedN(_zone_gw, "growMemory", true);
+#endif
+		// Grow the memory to the type's minimum size.
+		if(growMemory(memory, type.size.min) != GrowResult::success)
+		{
+			delete memory;
+			return nullptr;
+		}
 	}
 
 	// Add the memory to the global array.
 	{
-		Platform::RWMutex::ExclusiveLock memoriesLock(memoriesMutex);
-		memories.push_back(memory);
+#ifdef WAVM_HAS_TRACY
+		ZoneNamedN(_zone_ata, "addToArray", true);
+#endif
+		{
+			Platform::RWMutex::ExclusiveLock memoriesLock(memoriesMutex);
+			memories.push_back(memory);
+		}
 	}
-
 	return memory;
 }
 
@@ -98,6 +122,9 @@ Memory* Runtime::createMemory(Compartment* compartment,
 							  std::string&& debugName,
 							  ResourceQuotaRefParam resourceQuota)
 {
+#ifdef WAVM_HAS_TRACY
+	ZoneNamedNS(_zone_root, "Runtime::createMemory", 6, true);
+#endif
 	WAVM_ASSERT(type.size.min <= UINTPTR_MAX);
 	Memory* memory = createMemoryImpl(compartment, type, std::move(debugName), resourceQuota);
 	if(!memory) { return nullptr; }
@@ -106,6 +133,9 @@ Memory* Runtime::createMemory(Compartment* compartment,
 	{
 		Platform::RWMutex::ExclusiveLock compartmentLock(compartment->mutex);
 
+#ifdef WAVM_HAS_TRACY
+		ZoneNamedN(_zone_aim, "add to IndexMap", true);
+#endif
 		memory->id = compartment->memories.add(UINTPTR_MAX, memory);
 		if(memory->id == UINTPTR_MAX)
 		{
@@ -124,7 +154,10 @@ Memory* Runtime::createMemory(Compartment* compartment,
 
 Memory* Runtime::cloneMemory(Memory* memory, Compartment* newCompartment)
 {
-	Platform::RWMutex::ExclusiveLock resizingLock(memory->resizingMutex);
+#ifdef WAVM_HAS_TRACY
+	ZoneNamedNS(_zone_root, "Runtime::cloneMemory", 6, true);
+#endif
+	Platform::RWMutex::ShareableLock resizingLock(memory->resizingMutex);
 	const IR::MemoryType memoryType = getMemoryType(memory);
 	std::string debugName = memory->debugName;
 	Memory* newMemory
@@ -139,6 +172,9 @@ Memory* Runtime::cloneMemory(Memory* memory, Compartment* newCompartment)
 	// Insert the memory in the new compartment's memories array with the same index as it had in
 	// the original compartment's memories IndexMap.
 	{
+#ifdef WAVM_HAS_TRACY
+		ZoneNamedN(_zone_iic, "insert into compartment", true);
+#endif
 		Platform::RWMutex::ExclusiveLock compartmentLock(newCompartment->mutex);
 
 		newMemory->id = memory->id;
@@ -153,6 +189,52 @@ Memory* Runtime::cloneMemory(Memory* memory, Compartment* newCompartment)
 	return newMemory;
 }
 
+void Runtime::cloneMemoryInto(Memory* targetMemory,
+							  const Memory* sourceMemory,
+							  Compartment* newCompartment)
+{
+#ifdef WAVM_HAS_TRACY
+	ZoneNamedNS(_zone_root, "Runtime::cloneMemoryInto", 6, true);
+#endif
+	Platform::RWMutex::ShareableLock resizingLock(sourceMemory->resizingMutex);
+	if(targetMemory->indexType != sourceMemory->indexType)
+	{
+		throw std::runtime_error(
+			"Mismatched index types of memories between source and target cloned memory");
+	}
+	targetMemory->debugName = sourceMemory->debugName;
+	targetMemory->resourceQuota = sourceMemory->resourceQuota;
+	const auto targetOriginalPageCount = getMemoryNumPages(targetMemory);
+	const auto sourcePageCount = getMemoryNumPages(sourceMemory);
+	if(targetOriginalPageCount < sourcePageCount)
+	{
+		if(growMemory(targetMemory, sourcePageCount - targetOriginalPageCount, nullptr)
+		   != GrowResult::success)
+		{
+			throw std::runtime_error("Couldn't grow memory for cloning from another module");
+		}
+	}
+	else if(targetOriginalPageCount > sourcePageCount)
+	{
+		if(shrinkMemory(targetMemory, targetOriginalPageCount - sourcePageCount, nullptr)
+		   != GrowResult::success)
+		{
+			throw std::runtime_error("Couldn't shrink memory for cloning from another module");
+		}
+	}
+	{
+#ifdef WAVM_HAS_TRACY
+		ZoneScopedN("memcpy memory content");
+		ZoneValue(sourcePageCount * IR::numBytesPerPage);
+#endif
+		std::copy(reinterpret_cast<const uint64_t*>(sourceMemory->baseAddress),
+				  reinterpret_cast<const uint64_t*>(sourceMemory->baseAddress
+													+ sourcePageCount * IR::numBytesPerPage),
+				  reinterpret_cast<uint64_t*>(targetMemory->baseAddress));
+	}
+	// compartment should already be up to date
+}
+
 Runtime::Memory::~Memory()
 {
 	if(id != UINTPTR_MAX)
@@ -186,10 +268,10 @@ Runtime::Memory::~Memory()
 	const Uptr pageBytesLog2 = Platform::getBytesPerPageLog2();
 	if(baseAddress && numReservedBytes > 0)
 	{
-		Platform::freeVirtualPages(baseAddress,
-								   (numReservedBytes + memoryNumGuardBytes) >> pageBytesLog2);
+		resizableRegionAllocator->freeRegion(
+			baseAddress, (numReservedBytes + memoryNumGuardBytes) >> pageBytesLog2);
 
-		Platform::deregisterVirtualAllocation(numPages >> pageBytesLog2);
+		// Platform::deregisterVirtualAllocation(numPages >> pageBytesLog2);
 	}
 
 	// Free the allocated quota.
@@ -234,7 +316,9 @@ GrowResult Runtime::growMemory(Memory* memory, Uptr numPagesToGrow, Uptr* outOld
 	{
 		// Check the memory page quota.
 		if(memory->resourceQuota && !memory->resourceQuota->memoryPages.allocate(numPagesToGrow))
-		{ return GrowResult::outOfQuota; }
+		{
+			return GrowResult::outOfQuota;
+		}
 
 		Platform::RWMutex::ExclusiveLock resizingLock(memory->resizingMutex);
 		oldNumPages = memory->numPages.load(std::memory_order_acquire);
@@ -252,15 +336,19 @@ GrowResult Runtime::growMemory(Memory* memory, Uptr numPagesToGrow, Uptr* outOld
 		}
 
 		// Try to commit the new pages, and return GrowResult::outOfMemory if the commit fails.
-		if(!Platform::commitVirtualPages(
-			   memory->baseAddress + oldNumPages * IR::numBytesPerPage,
-			   numPagesToGrow << getPlatformPagesPerWebAssemblyPageLog2()))
-		{
-			if(memory->resourceQuota) { memory->resourceQuota->memoryPages.free(numPagesToGrow); }
-			return GrowResult::outOfMemory;
-		}
-		Platform::registerVirtualAllocation(numPagesToGrow
-											<< getPlatformPagesPerWebAssemblyPageLog2());
+		// if(!Platform::commitVirtualPages(
+		// 	   memory->baseAddress + oldNumPages * IR::numBytesPerPage,
+		// 	   numPagesToGrow << getPlatformPagesPerWebAssemblyPageLog2()))
+		// {
+		// 	if(memory->resourceQuota) { memory->resourceQuota->memoryPages.free(numPagesToGrow); }
+		// 	return GrowResult::outOfMemory;
+		// }
+		// Platform::registerVirtualAllocation(numPagesToGrow
+		// 									<< getPlatformPagesPerWebAssemblyPageLog2());
+		resizableRegionAllocator->resizeRegion(
+			memory->baseAddress,
+			oldNumPages * IR::numBytesPerPage,
+			(oldNumPages + numPagesToGrow) * IR::numBytesPerPage);
 
 		const Uptr newNumPages = oldNumPages + numPagesToGrow;
 		memory->numPages.store(newNumPages, std::memory_order_release);
@@ -275,8 +363,52 @@ GrowResult Runtime::growMemory(Memory* memory, Uptr numPagesToGrow, Uptr* outOld
 	return GrowResult::success;
 }
 
+GrowResult Runtime::shrinkMemory(Memory* memory, Uptr numPagesToShrink, Uptr* outNewNumPages)
+{
+	Uptr oldNumPages;
+	if(numPagesToShrink == 0) { oldNumPages = memory->numPages.load(std::memory_order_seq_cst); }
+	else
+	{
+		Platform::RWMutex::ExclusiveLock resizingLock(memory->resizingMutex);
+		oldNumPages = memory->numPages.load(std::memory_order_acquire);
+
+		// Check for freeing more pages than currently allocated
+		if(numPagesToShrink > oldNumPages) { return GrowResult::outOfMaxSize; }
+
+		// Check the memory page quota.
+		if(memory->resourceQuota && !memory->resourceQuota->memoryPages.allocate(-numPagesToShrink))
+		{
+			return GrowResult::outOfQuota;
+		}
+
+		const Uptr newNumPages = oldNumPages - numPagesToShrink;
+
+		// Try to commit the new pages, and return GrowResult::outOfMemory if the commit fails.
+		// Platform::decommitVirtualPages(
+		// 	memory->baseAddress + newNumPages * IR::numBytesPerPage,
+		// 	numPagesToShrink << getPlatformPagesPerWebAssemblyPageLog2());
+		// Platform::deregisterVirtualAllocation(numPagesToShrink
+		// 									  << getPlatformPagesPerWebAssemblyPageLog2());
+		resizableRegionAllocator->resizeRegion(
+			memory->baseAddress,
+			oldNumPages * IR::numBytesPerPage,
+			(oldNumPages - numPagesToShrink) * IR::numBytesPerPage);
+
+		memory->numPages.store(newNumPages, std::memory_order_release);
+		if(memory->id != UINTPTR_MAX)
+		{
+			memory->compartment->runtimeData->memories[memory->id].numPages.store(
+				newNumPages, std::memory_order_release);
+		}
+	}
+
+	if(outNewNumPages) { *outNewNumPages = oldNumPages; }
+	return GrowResult::success;
+}
+
 void Runtime::unmapMemoryPages(Memory* memory, Uptr pageIndex, Uptr numPages)
 {
+	throw std::runtime_error("unmapMemoryPages is unused");
 	WAVM_ASSERT(pageIndex + numPages > pageIndex);
 	WAVM_ASSERT((pageIndex + numPages) * IR::numBytesPerPage <= memory->numReservedBytes);
 
@@ -419,7 +551,9 @@ WAVM_DEFINE_INTRINSIC_FUNCTION(wavmIntrinsicsMemory,
 	Platform::RWMutex::ExclusiveLock dataSegmentsLock(instance->dataSegmentsMutex);
 
 	if(instance->dataSegments[dataSegmentIndex])
-	{ instance->dataSegments[dataSegmentIndex].reset(); }
+	{
+		instance->dataSegments[dataSegmentIndex].reset();
+	}
 }
 
 WAVM_DEFINE_INTRINSIC_FUNCTION(wavmIntrinsics,
diff --git a/WAVM/Lib/Runtime/Module.cpp b/WAVM/Lib/Runtime/Module.cpp
index 5be59f96..62f97435 100644
--- a/WAVM/Lib/Runtime/Module.cpp
+++ b/WAVM/Lib/Runtime/Module.cpp
@@ -30,6 +30,16 @@ static std::shared_ptr<ObjectCacheInterface> getGlobalObjectCache()
 	return globalObjectCache;
 }
 
+std::vector<U8> Runtime::precompileModule(const IR::Module& irModule,
+										  const std::string& targetArch,
+										  const std::string& targetCpu)
+{
+	auto targetSpec = LLVMJIT::getHostTargetSpec();
+	if(!targetCpu.empty()) { targetSpec.cpu = targetCpu; }
+	if(!targetArch.empty()) { targetSpec.triple = targetArch + "-unknown-linux-gnu"; }
+	return LLVMJIT::compileModule(irModule, targetSpec);
+}
+
 ModuleRef Runtime::compileModule(const IR::Module& irModule)
 {
 	// Get a pointer to the global object cache, if there is one.
diff --git a/WAVM/Lib/Runtime/Runtime.cpp b/WAVM/Lib/Runtime/Runtime.cpp
index 8087901a..eb323767 100644
--- a/WAVM/Lib/Runtime/Runtime.cpp
+++ b/WAVM/Lib/Runtime/Runtime.cpp
@@ -143,6 +143,8 @@ ExternType Runtime::getExternType(const Object* object)
 
 FunctionType Runtime::getFunctionType(const Function* function) { return function->encodedType; }
 
+std::string Runtime::getFunctionDebugName(const Function* function) { return function->mutableData->debugName; };
+
 Context* Runtime::getContextFromRuntimeData(ContextRuntimeData* contextRuntimeData)
 {
 	return contextRuntimeData->context;
diff --git a/WAVM/Lib/Runtime/RuntimePrivate.h b/WAVM/Lib/Runtime/RuntimePrivate.h
index 92314cb4..edec401b 100644
--- a/WAVM/Lib/Runtime/RuntimePrivate.h
+++ b/WAVM/Lib/Runtime/RuntimePrivate.h
@@ -336,6 +336,12 @@ namespace WAVM { namespace Runtime {
 	bool isAddressOwnedByTable(U8* address, Table*& outTable, Uptr& outTableIndex);
 	bool isAddressOwnedByMemory(U8* address, Memory*& outMemory, Uptr& outMemoryAddress);
 
+	// Clones objects into pre-allocated (non-null) targets, overwriting what was there before
+	void cloneMemoryInto(Memory* targetMemory,
+						 const Memory* sourceMemory,
+						 Compartment* newCompartment);
+	void cloneTableInto(Table* targetTable, const Table* sourceTable, Compartment* newCompartment);
+
 	// Clones objects into a new compartment with the same ID.
 	Table* cloneTable(Table* memory, Compartment* newCompartment);
 	Memory* cloneMemory(Memory* memory, Compartment* newCompartment);
diff --git a/WAVM/Lib/Runtime/Table.cpp b/WAVM/Lib/Runtime/Table.cpp
index 92a89707..0d7efac2 100644
--- a/WAVM/Lib/Runtime/Table.cpp
+++ b/WAVM/Lib/Runtime/Table.cpp
@@ -1,6 +1,6 @@
 #include <stdint.h>
 #include <string.h>
-#include <algorithm>
+#include <stdexcept>
 #include <vector>
 #include "RuntimePrivate.h"
 #include "WAVM/IR/Types.h"
@@ -108,7 +108,9 @@ static GrowResult growTableImpl(Table* table,
 	{
 		// Check the table element quota.
 		if(table->resourceQuota && !table->resourceQuota->tableElems.allocate(numElementsToGrow))
-		{ return GrowResult::outOfQuota; }
+		{
+			return GrowResult::outOfQuota;
+		}
 
 		Platform::RWMutex::ExclusiveLock resizingLock(table->resizingMutex);
 
@@ -205,9 +207,72 @@ Table* Runtime::createTable(Compartment* compartment,
 	return table;
 }
 
+void Runtime::cloneTableInto(Table* targetTable,
+							 const Table* sourceTable,
+							 Compartment* newCompartment)
+{
+	Platform::RWMutex::ShareableLock resizingLock(sourceTable->resizingMutex);
+
+	// Create the new table.
+	const Uptr numElements = sourceTable->numElements.load(std::memory_order_acquire);
+	if(targetTable->indexType != sourceTable->indexType)
+	{
+		throw std::runtime_error("Mismatched table types when cloning module");
+	}
+	targetTable->debugName = sourceTable->debugName;
+	targetTable->resourceQuota = sourceTable->resourceQuota;
+
+	const Uptr originalTargetSize = targetTable->numElements.load(std::memory_order_acquire);
+	if(originalTargetSize < numElements)
+	{
+		// Grow the table to the same size as the original, without initializing the new elements
+		// since they will be written immediately following this.
+		if(growTableImpl(targetTable, numElements - originalTargetSize, nullptr, false)
+		   != GrowResult::success)
+		{
+			throw std::runtime_error("Error growing table for cloning into");
+		}
+	}
+	else if(originalTargetSize > numElements)
+	{
+		if(targetTable->resourceQuota)
+		{
+			targetTable->resourceQuota->tableElems.free(originalTargetSize - numElements);
+		}
+
+		Platform::RWMutex::ExclusiveLock resizingLock(targetTable->resizingMutex);
+
+		// Try to commit pages for the new elements, and return GrowResult::outOfMemory if the
+		// commit fails.
+		const Uptr newNumElements = numElements;
+		const Uptr previousNumPlatformPages
+			= getNumPlatformPages(originalTargetSize * sizeof(Table::Element));
+		const Uptr newNumPlatformPages
+			= getNumPlatformPages(newNumElements * sizeof(Table::Element));
+		if(newNumPlatformPages != previousNumPlatformPages)
+		{
+			Platform::decommitVirtualPages(
+				(U8*)targetTable->elements + (newNumElements << Platform::getBytesPerPageLog2()),
+				previousNumPlatformPages - newNumPlatformPages);
+		}
+		Platform::deregisterVirtualAllocation((previousNumPlatformPages - newNumPlatformPages)
+											  << Platform::getBytesPerPageLog2());
+
+		targetTable->numElements.store(newNumElements, std::memory_order_release);
+	}
+
+	// Copy the original table's elements to the new table.
+	for(Uptr elementIndex = 0; elementIndex < numElements; ++elementIndex)
+	{
+		targetTable->elements[elementIndex].biasedValue.store(
+			sourceTable->elements[elementIndex].biasedValue.load(std::memory_order_acquire),
+			std::memory_order_release);
+	}
+}
+
 Table* Runtime::cloneTable(Table* table, Compartment* newCompartment)
 {
-	Platform::RWMutex::ExclusiveLock resizingLock(table->resizingMutex);
+	Platform::RWMutex::ShareableLock resizingLock(table->resizingMutex);
 
 	// Create the new table.
 	const IR::TableType tableType = getTableType(table);
@@ -316,7 +381,9 @@ static Object* setTableElementNonNull(Table* table, Uptr index, Object* object)
 
 	// Verify the index is within the table's bounds.
 	if(index >= table->numReservedElements)
-	{ throwException(ExceptionTypes::outOfBoundsTableAccess, {table, U64(index)}); }
+	{
+		throwException(ExceptionTypes::outOfBoundsTableAccess, {table, U64(index)});
+	}
 
 	// Use a saturated index to access the table data to ensure that it's harmless for the CPU to
 	// speculate past the above bounds check.
@@ -331,10 +398,14 @@ static Object* setTableElementNonNull(Table* table, Uptr index, Object* object)
 	while(true)
 	{
 		if(biasedTableElementValueToObject(oldBiasedValue) == getOutOfBoundsElement())
-		{ throwException(ExceptionTypes::outOfBoundsTableAccess, {table, U64(index)}); }
+		{
+			throwException(ExceptionTypes::outOfBoundsTableAccess, {table, U64(index)});
+		}
 		if(table->elements[saturatedIndex].biasedValue.compare_exchange_weak(
 			   oldBiasedValue, biasedValue, std::memory_order_acq_rel))
-		{ break; }
+		{
+			break;
+		}
 	};
 
 	return biasedTableElementValueToObject(oldBiasedValue);
@@ -541,7 +612,9 @@ WAVM_DEFINE_INTRINSIC_FUNCTION(wavmIntrinsicsTable,
 				 &oldNumElements,
 				 initialValue ? initialValue : getUninitializedElement())
 	   != GrowResult::success)
-	{ return -1; }
+	{
+		return -1;
+	}
 	WAVM_ASSERT(oldNumElements <= INTPTR_MAX);
 	return Iptr(oldNumElements);
 }
@@ -621,7 +694,9 @@ WAVM_DEFINE_INTRINSIC_FUNCTION(wavmIntrinsicsTable,
 	Platform::RWMutex::ExclusiveLock elemSegmentsLock(instance->elemSegmentsMutex);
 
 	if(instance->elemSegments[elemSegmentIndex])
-	{ instance->elemSegments[elemSegmentIndex].reset(); }
+	{
+		instance->elemSegments[elemSegmentIndex].reset();
+	}
 }
 
 WAVM_DEFINE_INTRINSIC_FUNCTION(wavmIntrinsicsTable,
@@ -718,7 +793,9 @@ WAVM_DEFINE_INTRINSIC_FUNCTION(wavmIntrinsicsTable,
 		}
 
 		for(Uptr index = 0; index < numElements; ++index)
-		{ setTableElementNonNull(destTable, U64(destOffset) + U64(index), value); }
+		{
+			setTableElementNonNull(destTable, U64(destOffset) + U64(index), value);
+		}
 	});
 }
 
@@ -733,7 +810,9 @@ WAVM_DEFINE_INTRINSIC_FUNCTION(wavmIntrinsicsTable,
 {
 	Table* table = getTableFromRuntimeData(contextRuntimeData, tableId);
 	if(asObject(function) == getOutOfBoundsElement())
-	{ throwException(ExceptionTypes::outOfBoundsTableAccess, {table, U64(index)}); }
+	{
+		throwException(ExceptionTypes::outOfBoundsTableAccess, {table, U64(index)});
+	}
 	else if(asObject(function) == getUninitializedElement())
 	{
 		throwException(ExceptionTypes::uninitializedTableElement, {table, U64(index)});
diff --git a/WAVM/Lib/WASI/WASIDiagnostics.cpp b/WAVM/Lib/WASI/WASIDiagnostics.cpp
index e16977f3..f59dca03 100644
--- a/WAVM/Lib/WASI/WASIDiagnostics.cpp
+++ b/WAVM/Lib/WASI/WASIDiagnostics.cpp
@@ -115,7 +115,7 @@ static void traceSyscallv(const char* syscallName, const char* argFormat, va_lis
 			Log::printf(Log::output, " - Call stack:\n");
 
 			Platform::CallStack callStack = Platform::captureCallStack(4);
-			if(callStack.frames.size() > 4) { callStack.frames.resize(4); }
+			if(callStack.frames.size() > 8) { callStack.frames.resize(8); }
 			std::vector<std::string> callStackFrameDescriptions
 				= Runtime::describeCallStack(callStack);
 			for(const std::string& frameDescription : callStackFrameDescriptions)
diff --git a/WAVM/THIRD-PARTY.md b/WAVM/THIRD-PARTY.md
deleted file mode 100644
index cfcdd0ba..00000000
--- a/WAVM/THIRD-PARTY.md
+++ /dev/null
@@ -1,18 +0,0 @@
-Third Party Software
-====================
-
-Parts of the I128 code are derived from LLVM's compiler-rt library (https://github.com/llvm/llvm-project/tree/master/compiler-rt), which is covered by the license in https://github.com/WAVM/WAVM/blob/master/Include/WAVM/Inline/Impl/I128Impl.LICENSE.
-
-The WebAssembly spec test suite (https://github.com/WAVM/WAVM/tree/master/Test/WebAssembly) are covered by the license in https://github.com/WAVM/WAVM/blob/master/Test/WebAssembly/LICENSE.txt.
-
-The libunwind library (https://github.com/WAVM/WAVM/tree/master/ThirdParty/libunwind) is covered by the license in https://github.com/WAVM/WAVM/blob/master/ThirdParty/libunwind/LICENSE.TXT.
-
-The liblmdb library (https://github.com/WAVM/WAVM/tree/master/ThirdParty/liblmdb) is covered by the license in https://github.com/WAVM/WAVM/blob/master/ThirdParty/liblmdb/LICENSE.
-
-The xxhash library (https://github.com/WAVM/WAVM/tree/master/Include/WAVM/Inline/xxhash) is covered by the license in https://github.com/WAVM/WAVM/blob/master/Include/WAVM/Inline/xxhash/LICENSE.
-
-The WASI ABI header (https://github.com/WAVM/WAVM/blob/master/Include/WAVM/WASI/WASIABI.h) is covered by the license in https://github.com/WAVM/WAVM/blob/master/Include/WAVM/WASI/WASIABI.LICENSE.
-
-The WAVM C API (https://github.com/WAVM/WAVM/blob/master/Include/WAVM/wavm-c/wavm-c.h) is based on wasm-c-api (https://github.com/WebAssembly/wasm-c-api), which is covered by the license in https://github.com/WAVM/WAVM/blob/master/Include/WAVM/wavm-c/wasm-c-api.LICENSE.
-
-The BLAKE2 library (https://github.com/WAVM/WAVM/tree/master/ThirdParty/BLAKE2) is covered by the license in https://github.com/WAVM/WAVM/blob/master/ThirdParty/BLAKE2/COPYING.
diff --git a/WAVM/ThirdParty/libunwind/CMakeLists.txt b/WAVM/ThirdParty/libunwind/CMakeLists.txt
index 54307f29..6a66aa67 100644
--- a/WAVM/ThirdParty/libunwind/CMakeLists.txt
+++ b/WAVM/ThirdParty/libunwind/CMakeLists.txt
@@ -1,16 +1,19 @@
 set(Sources
 	src/AddressSpace.hpp
 	src/assembly.h
+	src/cet_unwind.h
 	src/CompactUnwinder.hpp
 	src/config.h
 	src/dwarf2.h
 	src/DwarfInstructions.hpp
 	src/DwarfParser.hpp
 	src/EHHeaderParser.hpp
+	src/FrameHeaderCache.hpp
 	src/libunwind_ext.h
 	src/libunwind.cpp
 	src/Registers.hpp
 	src/RWMutex.hpp
+	src/Unwind-seh.cpp
 	src/Unwind-sjlj.c
 	src/UnwindCursor.hpp
 	src/UnwindLevel1-gcc-ext.c
@@ -38,7 +41,7 @@ else()
 	if(CMAKE_SYSTEM_NAME STREQUAL "Darwin")
 		set(Sources ${Sources} ${AppleSources})
 	endif()
-	
+
 	set(UNWIND_COMPILER_OPTIONS)
 	if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
 		list(APPEND UNWIND_COMPILER_OPTIONS "-Wno-maybe-uninitialized" "-Wno-unused-but-set-variable")
diff --git a/WAVM/ThirdParty/libunwind/LICENSE.TXT b/WAVM/ThirdParty/libunwind/LICENSE.TXT
index fb77e1b7..1e312062 100644
--- a/WAVM/ThirdParty/libunwind/LICENSE.TXT
+++ b/WAVM/ThirdParty/libunwind/LICENSE.TXT
@@ -1,5 +1,240 @@
 ==============================================================================
-libunwind License
+The LLVM Project is under the Apache License v2.0 with LLVM Exceptions:
+==============================================================================
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+    1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+    2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+    3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+    4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+    5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+    6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+    7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+    8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+    9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+    END OF TERMS AND CONDITIONS
+
+    APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+    Copyright [yyyy] [name of copyright owner]
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+
+---- LLVM Exceptions to the Apache 2.0 License ----
+
+As an exception, if, as a result of your compiling your source code, portions
+of this Software are embedded into an Object form of such source code, you
+may redistribute such embedded portions in such Object form without complying
+with the conditions of Sections 4(a), 4(b) and 4(d) of the License.
+
+In addition, if you combine or link compiled forms of this Software with
+software that is licensed under the GPLv2 ("Combined Software") and if a
+court of competent jurisdiction determines that the patent provision (Section
+3), the indemnity provision (Section 9) or other Section of the License
+conflicts with the conditions of the GPLv2, you may retroactively and
+prospectively choose to deem waived or otherwise exclude such Section(s) of
+the License, but only in their entirety and only with respect to the Combined
+Software.
+
+==============================================================================
+Software from third parties included in the LLVM Project:
+==============================================================================
+The LLVM Project contains third party software which is under different license
+terms. All such code will be identified clearly using at least one of two
+mechanisms:
+1) It will be in a separate directory tree with its own `LICENSE.txt` or
+   `LICENSE` file at the top containing the specific license and restrictions
+   which apply to that software, or
+2) It will contain specific license and restriction terms at the top of every
+   file.
+
+==============================================================================
+Legacy LLVM License (https://llvm.org/docs/DeveloperPolicy.html#legacy):
 ==============================================================================
 
 The libunwind library is dual licensed under both the University of Illinois
@@ -14,7 +249,7 @@ Full text of the relevant licenses is included below.
 University of Illinois/NCSA
 Open Source License
 
-Copyright (c) 2009-2017 by the contributors listed in CREDITS.TXT
+Copyright (c) 2009-2019 by the contributors listed in CREDITS.TXT
 
 All rights reserved.
 
diff --git a/WAVM/ThirdParty/libunwind/cmake/Modules/HandleCompilerRT.cmake b/WAVM/ThirdParty/libunwind/cmake/Modules/HandleCompilerRT.cmake
deleted file mode 100644
index 9bf88bb4..00000000
--- a/WAVM/ThirdParty/libunwind/cmake/Modules/HandleCompilerRT.cmake
+++ /dev/null
@@ -1,58 +0,0 @@
-function(find_compiler_rt_library name dest)
-  if (NOT DEFINED LIBUNWIND_COMPILE_FLAGS)
-    message(FATAL_ERROR "LIBUNWIND_COMPILE_FLAGS must be defined when using this function")
-  endif()
-  set(dest "" PARENT_SCOPE)
-  set(CLANG_COMMAND ${CMAKE_CXX_COMPILER} ${LIBUNWIND_COMPILE_FLAGS}
-      "--rtlib=compiler-rt" "--print-libgcc-file-name")
-  if (CMAKE_CXX_COMPILER_ID MATCHES Clang AND CMAKE_CXX_COMPILER_TARGET)
-    list(APPEND CLANG_COMMAND "--target=${CMAKE_CXX_COMPILER_TARGET}")
-  endif()
-  execute_process(
-      COMMAND ${CLANG_COMMAND}
-      RESULT_VARIABLE HAD_ERROR
-      OUTPUT_VARIABLE LIBRARY_FILE
-  )
-  string(STRIP "${LIBRARY_FILE}" LIBRARY_FILE)
-  string(REPLACE "builtins" "${name}" LIBRARY_FILE "${LIBRARY_FILE}")
-  if (NOT HAD_ERROR AND EXISTS "${LIBRARY_FILE}")
-    message(STATUS "Found compiler-rt library: ${LIBRARY_FILE}")
-    set(${dest} "${LIBRARY_FILE}" PARENT_SCOPE)
-  else()
-    message(STATUS "Failed to find compiler-rt library")
-  endif()
-endfunction()
-
-function(find_compiler_rt_dir dest)
-  if (NOT DEFINED LIBUNWIND_COMPILE_FLAGS)
-    message(FATAL_ERROR "LIBUNWIND_COMPILE_FLAGS must be defined when using this function")
-  endif()
-  set(dest "" PARENT_SCOPE)
-  if (APPLE)
-    set(CLANG_COMMAND ${CMAKE_CXX_COMPILER} ${LIBUNWIND_COMPILE_FLAGS}
-        "-print-file-name=lib")
-    execute_process(
-        COMMAND ${CLANG_COMMAND}
-        RESULT_VARIABLE HAD_ERROR
-        OUTPUT_VARIABLE LIBRARY_DIR
-    )
-    string(STRIP "${LIBRARY_DIR}" LIBRARY_DIR)
-    set(LIBRARY_DIR "${LIBRARY_DIR}/darwin")
-  else()
-    set(CLANG_COMMAND ${CMAKE_CXX_COMPILER} ${LIBUNWIND_COMPILE_FLAGS}
-        "--rtlib=compiler-rt" "--print-libgcc-file-name")
-    execute_process(
-        COMMAND ${CLANG_COMMAND}
-        RESULT_VARIABLE HAD_ERROR
-        OUTPUT_VARIABLE LIBRARY_FILE
-    )
-    string(STRIP "${LIBRARY_FILE}" LIBRARY_FILE)
-    get_filename_component(LIBRARY_DIR "${LIBRARY_FILE}" DIRECTORY)
-  endif()
-  if (NOT HAD_ERROR AND EXISTS "${LIBRARY_DIR}")
-    message(STATUS "Found compiler-rt directory: ${LIBRARY_DIR}")
-    set(${dest} "${LIBRARY_DIR}" PARENT_SCOPE)
-  else()
-    message(STATUS "Failed to find compiler-rt directory")
-  endif()
-endfunction()
diff --git a/WAVM/ThirdParty/libunwind/cmake/Modules/HandleLibunwindFlags.cmake b/WAVM/ThirdParty/libunwind/cmake/Modules/HandleLibunwindFlags.cmake
new file mode 100644
index 00000000..675071f9
--- /dev/null
+++ b/WAVM/ThirdParty/libunwind/cmake/Modules/HandleLibunwindFlags.cmake
@@ -0,0 +1,283 @@
+# HandleLibcxxFlags - A set of macros used to setup the flags used to compile
+# and link libc++abi. These macros add flags to the following CMake variables.
+# - LIBUNWIND_COMPILE_FLAGS: flags used to compile libunwind
+# - LIBUNWIND_LINK_FLAGS: flags used to link libunwind
+# - LIBUNWIND_LIBRARIES: libraries to link libunwind to.
+
+include(CheckCCompilerFlag)
+include(CheckCXXCompilerFlag)
+
+unset(add_flag_if_supported)
+
+# Mangle the name of a compiler flag into a valid CMake identifier.
+# Ex: --std=c++11 -> STD_EQ_CXX11
+macro(mangle_name str output)
+  string(STRIP "${str}" strippedStr)
+  string(REGEX REPLACE "^/" "" strippedStr "${strippedStr}")
+  string(REGEX REPLACE "^-+" "" strippedStr "${strippedStr}")
+  string(REGEX REPLACE "-+$" "" strippedStr "${strippedStr}")
+  string(REPLACE "-" "_" strippedStr "${strippedStr}")
+  string(REPLACE "=" "_EQ_" strippedStr "${strippedStr}")
+  string(REPLACE "+" "X" strippedStr "${strippedStr}")
+  string(TOUPPER "${strippedStr}" ${output})
+endmacro()
+
+# Remove a list of flags from all CMake variables that affect compile flags.
+# This can be used to remove unwanted flags specified on the command line
+# or added in other parts of LLVM's cmake configuration.
+macro(remove_flags)
+  foreach(var ${ARGN})
+    string(REPLACE "${var}" "" CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG}")
+    string(REPLACE "${var}" "" CMAKE_CXX_FLAGS_MINSIZEREL "${CMAKE_CXX_FLAGS_MINSIZEREL}")
+    string(REPLACE "${var}" "" CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE}")
+    string(REPLACE "${var}" "" CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELWITHDEBINFO}")
+    string(REPLACE "${var}" "" CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}")
+    string(REPLACE "${var}" "" CMAKE_C_FLAGS "${CMAKE_C_FLAGS}")
+    string(REPLACE "${var}" "" CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS}")
+    string(REPLACE "${var}" "" CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS}")
+    string(REPLACE "${var}" "" CMAKE_SHARED_MODULE_FLAGS "${CMAKE_SHARED_MODULE_FLAGS}")
+    remove_definitions(${var})
+  endforeach()
+endmacro(remove_flags)
+
+macro(check_flag_supported flag)
+    mangle_name("${flag}" flagname)
+    check_cxx_compiler_flag("${flag}" "LIBUNWIND_SUPPORTS_${flagname}_FLAG")
+endmacro()
+
+macro(append_flags DEST)
+  foreach(value ${ARGN})
+    list(APPEND ${DEST} ${value})
+    list(APPEND ${DEST} ${value})
+  endforeach()
+endmacro()
+
+# If the specified 'condition' is true then append the specified list of flags to DEST
+macro(append_flags_if condition DEST)
+  if (${condition})
+    list(APPEND ${DEST} ${ARGN})
+  endif()
+endmacro()
+
+# Add each flag in the list specified by DEST if that flag is supported by the current compiler.
+macro(append_flags_if_supported DEST)
+  foreach(flag ${ARGN})
+    mangle_name("${flag}" flagname)
+    check_cxx_compiler_flag("${flag}" "LIBUNWIND_SUPPORTS_${flagname}_FLAG")
+    append_flags_if(LIBUNWIND_SUPPORTS_${flagname}_FLAG ${DEST} ${flag})
+  endforeach()
+endmacro()
+
+# Add a macro definition if condition is true.
+macro(define_if condition def)
+  if (${condition})
+    add_definitions(${def})
+  endif()
+endmacro()
+
+# Add a macro definition if condition is not true.
+macro(define_if_not condition def)
+  if (NOT ${condition})
+    add_definitions(${def})
+  endif()
+endmacro()
+
+# Add a macro definition to the __config_site file if the specified condition
+# is 'true'. Note that '-D${def}' is not added. Instead it is expected that
+# the build include the '__config_site' header.
+macro(config_define_if condition def)
+  if (${condition})
+    set(${def} ON)
+    set(LIBUNWIND_NEEDS_SITE_CONFIG ON)
+  endif()
+endmacro()
+
+macro(config_define_if_not condition def)
+  if (NOT ${condition})
+    set(${def} ON)
+    set(LIBUNWIND_NEEDS_SITE_CONFIG ON)
+  endif()
+endmacro()
+
+macro(config_define value def)
+  set(${def} ${value})
+  set(LIBUNWIND_NEEDS_SITE_CONFIG ON)
+endmacro()
+
+# Add a list of flags to all of 'CMAKE_CXX_FLAGS', 'CMAKE_C_FLAGS',
+# 'LIBUNWIND_COMPILE_FLAGS' and 'LIBUNWIND_LINK_FLAGS'.
+macro(add_target_flags)
+  foreach(value ${ARGN})
+    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${value}")
+    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${value}")
+    list(APPEND LIBUNWIND_COMPILE_FLAGS ${value})
+    list(APPEND LIBUNWIND_LINK_FLAGS ${value})
+  endforeach()
+endmacro()
+
+# If the specified 'condition' is true then add a list of flags to
+# all of 'CMAKE_CXX_FLAGS', 'CMAKE_C_FLAGS', 'LIBUNWIND_COMPILE_FLAGS'
+# and 'LIBUNWIND_LINK_FLAGS'.
+macro(add_target_flags_if condition)
+  if (${condition})
+    add_target_flags(${ARGN})
+  endif()
+endmacro()
+
+# Add all the flags supported by the compiler to all of
+# 'CMAKE_CXX_FLAGS', 'CMAKE_C_FLAGS', 'LIBUNWIND_COMPILE_FLAGS'
+# and 'LIBUNWIND_LINK_FLAGS'.
+macro(add_target_flags_if_supported)
+  foreach(flag ${ARGN})
+    mangle_name("${flag}" flagname)
+    check_cxx_compiler_flag("${flag}" "LIBUNWIND_SUPPORTS_${flagname}_FLAG")
+    add_target_flags_if(LIBUNWIND_SUPPORTS_${flagname}_FLAG ${flag})
+  endforeach()
+endmacro()
+
+# Add a specified list of flags to both 'LIBUNWIND_COMPILE_FLAGS' and
+# 'LIBUNWIND_LINK_FLAGS'.
+macro(add_flags)
+  foreach(value ${ARGN})
+    list(APPEND LIBUNWIND_COMPILE_FLAGS ${value})
+    list(APPEND LIBUNWIND_LINK_FLAGS ${value})
+  endforeach()
+endmacro()
+
+# If the specified 'condition' is true then add a list of flags to both
+# 'LIBUNWIND_COMPILE_FLAGS' and 'LIBUNWIND_LINK_FLAGS'.
+macro(add_flags_if condition)
+  if (${condition})
+    add_flags(${ARGN})
+  endif()
+endmacro()
+
+# Add each flag in the list to LIBUNWIND_COMPILE_FLAGS and LIBUNWIND_LINK_FLAGS
+# if that flag is supported by the current compiler.
+macro(add_flags_if_supported)
+  foreach(flag ${ARGN})
+      mangle_name("${flag}" flagname)
+      check_cxx_compiler_flag("${flag}" "LIBUNWIND_SUPPORTS_${flagname}_FLAG")
+      add_flags_if(LIBUNWIND_SUPPORTS_${flagname}_FLAG ${flag})
+  endforeach()
+endmacro()
+
+# Add a list of flags to 'LIBUNWIND_COMPILE_FLAGS'.
+macro(add_compile_flags)
+  foreach(f ${ARGN})
+    list(APPEND LIBUNWIND_COMPILE_FLAGS ${f})
+  endforeach()
+endmacro()
+
+# If 'condition' is true then add the specified list of flags to
+# 'LIBUNWIND_COMPILE_FLAGS'
+macro(add_compile_flags_if condition)
+  if (${condition})
+    add_compile_flags(${ARGN})
+  endif()
+endmacro()
+
+# For each specified flag, add that flag to 'LIBUNWIND_COMPILE_FLAGS' if the
+# flag is supported by the C++ compiler.
+macro(add_compile_flags_if_supported)
+  foreach(flag ${ARGN})
+      mangle_name("${flag}" flagname)
+      check_cxx_compiler_flag("${flag}" "LIBUNWIND_SUPPORTS_${flagname}_FLAG")
+      add_compile_flags_if(LIBUNWIND_SUPPORTS_${flagname}_FLAG ${flag})
+  endforeach()
+endmacro()
+
+# Add a list of flags to 'LIBUNWIND_C_FLAGS'.
+macro(add_c_flags)
+  foreach(f ${ARGN})
+    list(APPEND LIBUNWIND_C_FLAGS ${f})
+  endforeach()
+endmacro()
+
+# If 'condition' is true then add the specified list of flags to
+# 'LIBUNWIND_C_FLAGS'
+macro(add_c_flags_if condition)
+  if (${condition})
+    add_c_flags(${ARGN})
+  endif()
+endmacro()
+
+# For each specified flag, add that flag to 'LIBUNWIND_C_FLAGS' if the
+# flag is supported by the C compiler.
+macro(add_c_compile_flags_if_supported)
+  foreach(flag ${ARGN})
+      mangle_name("${flag}" flagname)
+      check_c_compiler_flag("${flag}" "LIBUNWIND_SUPPORTS_${flagname}_FLAG")
+      add_c_flags_if(LIBUNWIND_SUPPORTS_${flagname}_FLAG ${flag})
+  endforeach()
+endmacro()
+
+# Add a list of flags to 'LIBUNWIND_CXX_FLAGS'.
+macro(add_cxx_flags)
+  foreach(f ${ARGN})
+    list(APPEND LIBUNWIND_CXX_FLAGS ${f})
+  endforeach()
+endmacro()
+
+# If 'condition' is true then add the specified list of flags to
+# 'LIBUNWIND_CXX_FLAGS'
+macro(add_cxx_flags_if condition)
+  if (${condition})
+    add_cxx_flags(${ARGN})
+  endif()
+endmacro()
+
+# For each specified flag, add that flag to 'LIBUNWIND_CXX_FLAGS' if the
+# flag is supported by the C compiler.
+macro(add_cxx_compile_flags_if_supported)
+  foreach(flag ${ARGN})
+      mangle_name("${flag}" flagname)
+      check_cxx_compiler_flag("${flag}" "LIBUNWIND_SUPPORTS_${flagname}_FLAG")
+      add_cxx_flags_if(LIBUNWIND_SUPPORTS_${flagname}_FLAG ${flag})
+  endforeach()
+endmacro()
+
+# Add a list of flags to 'LIBUNWIND_LINK_FLAGS'.
+macro(add_link_flags)
+  foreach(f ${ARGN})
+    list(APPEND LIBUNWIND_LINK_FLAGS ${f})
+  endforeach()
+endmacro()
+
+# If 'condition' is true then add the specified list of flags to
+# 'LIBUNWIND_LINK_FLAGS'
+macro(add_link_flags_if condition)
+  if (${condition})
+    add_link_flags(${ARGN})
+  endif()
+endmacro()
+
+# For each specified flag, add that flag to 'LIBUNWIND_LINK_FLAGS' if the
+# flag is supported by the C++ compiler.
+macro(add_link_flags_if_supported)
+  foreach(flag ${ARGN})
+    mangle_name("${flag}" flagname)
+    check_cxx_compiler_flag("${flag}" "LIBUNWIND_SUPPORTS_${flagname}_FLAG")
+    add_link_flags_if(LIBUNWIND_SUPPORTS_${flagname}_FLAG ${flag})
+  endforeach()
+endmacro()
+
+# Add a list of libraries or link flags to 'LIBUNWIND_LIBRARIES'.
+macro(add_library_flags)
+  foreach(lib ${ARGN})
+    list(APPEND LIBUNWIND_LIBRARIES ${lib})
+  endforeach()
+endmacro()
+
+# if 'condition' is true then add the specified list of libraries and flags
+# to 'LIBUNWIND_LIBRARIES'.
+macro(add_library_flags_if condition)
+  if(${condition})
+    add_library_flags(${ARGN})
+  endif()
+endmacro()
+
+# Turn a comma separated CMake list into a space separated string.
+macro(split_list listname)
+  string(REPLACE ";" " " ${listname} "${${listname}}")
+endmacro()
diff --git a/WAVM/ThirdParty/libunwind/cmake/config-ix.cmake b/WAVM/ThirdParty/libunwind/cmake/config-ix.cmake
index 2d4da649..f78a7931 100644
--- a/WAVM/ThirdParty/libunwind/cmake/config-ix.cmake
+++ b/WAVM/ThirdParty/libunwind/cmake/config-ix.cmake
@@ -1,33 +1,65 @@
-
+include(CMakePushCheckState)
 include(CheckCCompilerFlag)
 include(CheckCXXCompilerFlag)
 include(CheckLibraryExists)
+include(LLVMCheckCompilerLinkerFlag)
+include(CheckSymbolExists)
+include(CheckCSourceCompiles)
+
+# The compiler driver may be implicitly trying to link against libunwind, which
+# might not work if libunwind doesn't exist yet. Try to check if
+# --unwindlib=none is supported, and use that if possible.
+llvm_check_compiler_linker_flag(C "--unwindlib=none" LIBUNWIND_SUPPORTS_UNWINDLIB_NONE_FLAG)
+if (LIBUNWIND_SUPPORTS_UNWINDLIB_NONE_FLAG)
+  set(CMAKE_REQUIRED_FLAGS "${CMAKE_REQUIRED_FLAGS} --unwindlib=none")
+endif()
 
 check_library_exists(c fopen "" LIBUNWIND_HAS_C_LIB)
 
 if (NOT LIBUNWIND_USE_COMPILER_RT)
-  check_library_exists(gcc_s __gcc_personality_v0 "" LIBUNWIND_HAS_GCC_S_LIB)
+  if (ANDROID)
+    check_library_exists(gcc __gcc_personality_v0 "" LIBUNWIND_HAS_GCC_LIB)
+  else ()
+    check_library_exists(gcc_s __gcc_personality_v0 "" LIBUNWIND_HAS_GCC_S_LIB)
+    check_library_exists(gcc __absvdi2 "" LIBUNWIND_HAS_GCC_LIB)
+  endif ()
 endif()
 
-# libunwind is built with -nodefaultlibs, so we want all our checks to also
-# use this option, otherwise we may end up with an inconsistency between
+# libunwind is using -nostdlib++ at the link step when available,
+# otherwise -nodefaultlibs is used. We want all our checks to also
+# use one of these options, otherwise we may end up with an inconsistency between
 # the flags we think we require during configuration (if the checks are
-# performed without -nodefaultlibs) and the flags that are actually
-# required during compilation (which has the -nodefaultlibs). libc is
+# performed without one of those options) and the flags that are actually
+# required during compilation (which has the -nostdlib++ or -nodefaultlibs). libc is
 # required for the link to go through. We remove sanitizers from the
 # configuration checks to avoid spurious link errors.
-check_c_compiler_flag(-nodefaultlibs LIBUNWIND_HAS_NODEFAULTLIBS_FLAG)
-if (LIBUNWIND_HAS_NODEFAULTLIBS_FLAG)
-  set(CMAKE_REQUIRED_FLAGS "${CMAKE_REQUIRED_FLAGS} -nodefaultlibs")
+
+llvm_check_compiler_linker_flag(C "-nostdlib++" LIBUNWIND_SUPPORTS_NOSTDLIBXX_FLAG)
+if (LIBUNWIND_SUPPORTS_NOSTDLIBXX_FLAG)
+  set(CMAKE_REQUIRED_FLAGS "${CMAKE_REQUIRED_FLAGS} -nostdlib++")
+else()
+  llvm_check_compiler_linker_flag(C "-nodefaultlibs" LIBUNWIND_SUPPORTS_NODEFAULTLIBS_FLAG)
+  if (LIBUNWIND_SUPPORTS_NODEFAULTLIBS_FLAG)
+    set(CMAKE_REQUIRED_FLAGS "${CMAKE_REQUIRED_FLAGS} -nodefaultlibs")
+  endif()
+endif()
+
+if (LIBUNWIND_SUPPORTS_NOSTDLIBXX_FLAG OR LIBUNWIND_SUPPORTS_NODEFAULTLIBS_FLAG)
   if (LIBUNWIND_HAS_C_LIB)
     list(APPEND CMAKE_REQUIRED_LIBRARIES c)
   endif ()
   if (LIBUNWIND_USE_COMPILER_RT)
-    list(APPEND CMAKE_REQUIRED_FLAGS -rtlib=compiler-rt)
-    find_compiler_rt_library(builtins LIBUNWIND_BUILTINS_LIBRARY)
+    include(HandleCompilerRT)
+    find_compiler_rt_library(builtins LIBUNWIND_BUILTINS_LIBRARY
+                             FLAGS ${LIBUNWIND_COMPILE_FLAGS})
     list(APPEND CMAKE_REQUIRED_LIBRARIES "${LIBUNWIND_BUILTINS_LIBRARY}")
-  elseif (LIBUNWIND_HAS_GCC_S_LIB)
-    list(APPEND CMAKE_REQUIRED_LIBRARIES gcc_s)
+  else ()
+    if (LIBUNWIND_HAS_GCC_S_LIB)
+      list(APPEND CMAKE_REQUIRED_LIBRARIES gcc_s)
+    endif ()
+    if (LIBUNWIND_HAS_GCC_LIB)
+      list(APPEND CMAKE_REQUIRED_LIBRARIES gcc)
+    endif ()
   endif ()
   if (MINGW)
     # Mingw64 requires quite a few "C" runtime libraries in order for basic
@@ -46,49 +78,39 @@ if (LIBUNWIND_HAS_NODEFAULTLIBS_FLAG)
     set(CMAKE_REQUIRED_FLAGS "${CMAKE_REQUIRED_FLAGS} -fno-sanitize=all")
   endif ()
   if (CMAKE_C_FLAGS MATCHES -fsanitize-coverage OR CMAKE_CXX_FLAGS MATCHES -fsanitize-coverage)
-    set(CMAKE_REQUIRED_FLAGS "${CMAKE_REQUIRED_FLAGS} -fno-sanitize-coverage=edge,trace-cmp,indirect-calls,8bit-counters")
+    set(CMAKE_REQUIRED_FLAGS "${CMAKE_REQUIRED_FLAGS} -fsanitize-coverage=0")
   endif ()
 endif ()
 
+# Check compiler pragmas
+if(CMAKE_CXX_COMPILER_ID MATCHES "Clang")
+  cmake_push_check_state()
+  set(CMAKE_REQUIRED_FLAGS "${CMAKE_REQUIRED_FLAGS} -Werror=unknown-pragmas")
+  check_c_source_compiles("
+#pragma comment(lib, \"c\")
+int main() { return 0; }
+" LIBUNWIND_HAS_COMMENT_LIB_PRAGMA)
+  cmake_pop_check_state()
+endif()
+
 # Check compiler flags
-check_c_compiler_flag(-funwind-tables         LIBUNWIND_HAS_FUNWIND_TABLES)
-check_cxx_compiler_flag(-fno-exceptions       LIBUNWIND_HAS_NO_EXCEPTIONS_FLAG)
-check_cxx_compiler_flag(-fno-rtti             LIBUNWIND_HAS_NO_RTTI_FLAG)
-check_cxx_compiler_flag(-fstrict-aliasing     LIBUNWIND_HAS_FSTRICT_ALIASING_FLAG)
-check_cxx_compiler_flag(-nostdinc++           LIBUNWIND_HAS_NOSTDINCXX_FLAG)
-check_cxx_compiler_flag(-Wall                 LIBUNWIND_HAS_WALL_FLAG)
-check_cxx_compiler_flag(-W                    LIBUNWIND_HAS_W_FLAG)
-check_cxx_compiler_flag(-Wno-unused-function  LIBUNWIND_HAS_WNO_UNUSED_FUNCTION_FLAG)
-check_cxx_compiler_flag(-Wunused-variable     LIBUNWIND_HAS_WUNUSED_VARIABLE_FLAG)
-check_cxx_compiler_flag(-Wunused-parameter    LIBUNWIND_HAS_WUNUSED_PARAMETER_FLAG)
-check_cxx_compiler_flag(-Wstrict-aliasing     LIBUNWIND_HAS_WSTRICT_ALIASING_FLAG)
-check_cxx_compiler_flag(-Wstrict-overflow     LIBUNWIND_HAS_WSTRICT_OVERFLOW_FLAG)
-check_cxx_compiler_flag(-Wwrite-strings       LIBUNWIND_HAS_WWRITE_STRINGS_FLAG)
-check_cxx_compiler_flag(-Wchar-subscripts     LIBUNWIND_HAS_WCHAR_SUBSCRIPTS_FLAG)
-check_cxx_compiler_flag(-Wmismatched-tags     LIBUNWIND_HAS_WMISMATCHED_TAGS_FLAG)
-check_cxx_compiler_flag(-Wmissing-braces      LIBUNWIND_HAS_WMISSING_BRACES_FLAG)
-check_cxx_compiler_flag(-Wshorten-64-to-32    LIBUNWIND_HAS_WSHORTEN_64_TO_32_FLAG)
-check_cxx_compiler_flag(-Wsign-conversion     LIBUNWIND_HAS_WSIGN_CONVERSION_FLAG)
-check_cxx_compiler_flag(-Wsign-compare        LIBUNWIND_HAS_WSIGN_COMPARE_FLAG)
-check_cxx_compiler_flag(-Wshadow              LIBUNWIND_HAS_WSHADOW_FLAG)
-check_cxx_compiler_flag(-Wconversion          LIBUNWIND_HAS_WCONVERSION_FLAG)
-check_cxx_compiler_flag(-Wnewline-eof         LIBUNWIND_HAS_WNEWLINE_EOF_FLAG)
-check_cxx_compiler_flag(-Wundef               LIBUNWIND_HAS_WUNDEF_FLAG)
-check_cxx_compiler_flag(-pedantic             LIBUNWIND_HAS_PEDANTIC_FLAG)
-check_cxx_compiler_flag(-Werror               LIBUNWIND_HAS_WERROR_FLAG)
-check_cxx_compiler_flag(-Wno-error            LIBUNWIND_HAS_WNO_ERROR_FLAG)
-check_cxx_compiler_flag(/WX                   LIBUNWIND_HAS_WX_FLAG)
-check_cxx_compiler_flag(/WX-                  LIBUNWIND_HAS_NO_WX_FLAG)
-check_cxx_compiler_flag(/EHsc                 LIBUNWIND_HAS_EHSC_FLAG)
-check_cxx_compiler_flag(/EHs-                 LIBUNWIND_HAS_NO_EHS_FLAG)
-check_cxx_compiler_flag(/EHa-                 LIBUNWIND_HAS_NO_EHA_FLAG)
-check_cxx_compiler_flag(/GR-                  LIBUNWIND_HAS_NO_GR_FLAG)
-check_cxx_compiler_flag(-std=c++11            LIBUNWIND_HAS_STD_CXX11)
+check_cxx_compiler_flag(-nostdinc++ LIBUNWIND_HAS_NOSTDINCXX_FLAG)
 
-if(LIBUNWIND_HAS_STD_CXX11)
-  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")
-endif()
+# Check symbols
+check_symbol_exists(__arm__ "" LIBUNWIND_TARGET_ARM)
+check_symbol_exists(__USING_SJLJ_EXCEPTIONS__ "" LIBUNWIND_USES_SJLJ_EXCEPTIONS)
+check_symbol_exists(__ARM_DWARF_EH__ "" LIBUNWIND_USES_DWARF_EH)
 
-check_library_exists(dl dladdr "" LIBUNWIND_HAS_DL_LIB)
-check_library_exists(pthread pthread_once "" LIBUNWIND_HAS_PTHREAD_LIB)
+if(LIBUNWIND_TARGET_ARM AND NOT LIBUNWIND_USES_SJLJ_EXCEPTIONS AND NOT LIBUNWIND_USES_DWARF_EH)
+  # This condition is copied from __libunwind_config.h
+  set(LIBUNWIND_USES_ARM_EHABI ON)
+endif()
 
+# Check libraries
+if(FUCHSIA)
+  set(LIBUNWIND_HAS_DL_LIB NO)
+  set(LIBUNWIND_HAS_PTHREAD_LIB NO)
+else()
+  check_library_exists(dl dladdr "" LIBUNWIND_HAS_DL_LIB)
+  check_library_exists(pthread pthread_once "" LIBUNWIND_HAS_PTHREAD_LIB)
+endif()
diff --git a/WAVM/ThirdParty/libunwind/docs/BuildingLibunwind.rst b/WAVM/ThirdParty/libunwind/docs/BuildingLibunwind.rst
index 6aa45561..99e52761 100644
--- a/WAVM/ThirdParty/libunwind/docs/BuildingLibunwind.rst
+++ b/WAVM/ThirdParty/libunwind/docs/BuildingLibunwind.rst
@@ -18,16 +18,10 @@ edge), read on.
 
 The basic steps needed to build libc++ are:
 
-#. Checkout LLVM:
+#. Checkout LLVM, libunwind, and related projects:
 
    * ``cd where-you-want-llvm-to-live``
-   * ``svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm``
-
-#. Checkout libunwind:
-
-   * ``cd where-you-want-llvm-to-live``
-   * ``cd llvm/runtimes``
-   * ``svn co http://llvm.org/svn/llvm-project/libunwind/trunk libunwind``
+   * ``git clone https://github.com/llvm/llvm-project.git``
 
 #. Configure and build libunwind:
 
@@ -38,7 +32,7 @@ The basic steps needed to build libc++ are:
    * ``cd where you want to build llvm``
    * ``mkdir build``
    * ``cd build``
-   * ``cmake -G <generator> [options] <path to llvm sources>``
+   * ``cmake -G <generator> -DLLVM_ENABLE_RUNTIMES=libunwind [options] <llvm-monorepo>/runtimes``
 
    For more information about configuring libunwind see :ref:`CMake Options`.
 
@@ -63,8 +57,8 @@ build would look like this:
 
   $ cd where-you-want-libunwind-to-live
   $ # Check out llvm, and libunwind
-  $ ``svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm``
-  $ ``svn co http://llvm.org/svn/llvm-project/libunwind/trunk libunwind``
+  $ ``svn co https://llvm.org/svn/llvm-project/llvm/trunk llvm``
+  $ ``svn co https://llvm.org/svn/llvm-project/libunwind/trunk libunwind``
   $ cd where-you-want-to-build
   $ mkdir build && cd build
   $ export CC=clang CXX=clang++
@@ -100,12 +94,6 @@ CMake docs or execute ``cmake --help-variable VARIABLE_NAME``.
 libunwind specific options
 --------------------------
 
-.. option:: LIBUNWIND_BUILD_32_BITS:BOOL
-
-  **Default**: Same as LLVM_BUILD_32_BITS
-
-  Toggle whether libunwind should be built with -m32.
-
 .. option:: LIBUNWIND_ENABLE_ASSERTIONS:BOOL
 
   **Default**: ``ON``
@@ -165,3 +153,10 @@ libunwind specific options
 .. option:: LIBUNWIND_SYSROOT
 
   Sysroot for cross compiling
+
+.. option:: LIBUNWIND_INSTALL_LIBRARY_DIR:PATH
+
+  **Default**: ``lib${LIBUNWIND_LIBDIR_SUFFIX}``
+
+  Path where built libunwind libraries should be installed. If a relative path,
+  relative to ``CMAKE_INSTALL_PREFIX``.
diff --git a/WAVM/ThirdParty/libunwind/docs/CMakeLists.txt b/WAVM/ThirdParty/libunwind/docs/CMakeLists.txt
index c226f2f5..79b87eb0 100644
--- a/WAVM/ThirdParty/libunwind/docs/CMakeLists.txt
+++ b/WAVM/ThirdParty/libunwind/docs/CMakeLists.txt
@@ -1,5 +1,5 @@
 include(FindSphinx)
-if (SPHINX_FOUND)
+if (SPHINX_FOUND AND LLVM_ENABLE_SPHINX)
   include(AddSphinxTarget)
   if (${SPHINX_OUTPUT_HTML})
     add_sphinx_target(html libunwind)
diff --git a/WAVM/ThirdParty/libunwind/docs/conf.py b/WAVM/ThirdParty/libunwind/docs/conf.py
index c3b51fcb..bc91d90f 100644
--- a/WAVM/ThirdParty/libunwind/docs/conf.py
+++ b/WAVM/ThirdParty/libunwind/docs/conf.py
@@ -11,6 +11,7 @@
 # serve to show the default.
 
 import sys, os
+from datetime import date
 
 # If extensions (or modules to document with autodoc) are in another directory,
 # add these directories to sys.path here. If the directory is relative to the
@@ -40,16 +41,16 @@ master_doc = 'index'
 
 # General information about the project.
 project = u'libunwind'
-copyright = u'2011-2017, LLVM Project'
+copyright = u'2011-%d, LLVM Project' % date.today().year
 
 # The version info for the project you're documenting, acts as replacement for
 # |version| and |release|, also used in various other places throughout the
 # built documents.
 #
 # The short X.Y version.
-version = '7.0'
+version = '14.0'
 # The full version, including alpha/beta/rc tags.
-release = '7.0'
+release = '14.0'
 
 # The language for content autogenerated by Sphinx. Refer to documentation
 # for a list of supported languages.
diff --git a/WAVM/ThirdParty/libunwind/docs/index.rst b/WAVM/ThirdParty/libunwind/docs/index.rst
index 7e7277e3..3597e757 100644
--- a/WAVM/ThirdParty/libunwind/docs/index.rst
+++ b/WAVM/ThirdParty/libunwind/docs/index.rst
@@ -50,7 +50,7 @@ FreeBSD      i386, x86_64, ARM64      Clang        DWARF CFI
 iOS          ARM                      Clang        SjLj
 Linux        ARM                      Clang, GCC   EHABI
 Linux        i386, x86_64, ARM64      Clang, GCC   DWARF CFI
-Mac OS X     i386, x86_64             Clang, GCC   DWARF CFI
+macOS        i386, x86_64             Clang, GCC   DWARF CFI
 NetBSD       x86_64                   Clang, GCC   DWARF CFI
 Windows      i386, x86_64, ARM, ARM64 Clang        DWARF CFI
 ============ ======================== ============ ========================
@@ -71,8 +71,8 @@ Notes and Known Issues
 Getting Involved
 ================
 
-First please review our `Developer's Policy <http://llvm.org/docs/DeveloperPolicy.html>`__
-and `Getting started with LLVM <http://llvm.org/docs/GettingStarted.html>`__.
+First please review our `Developer's Policy <https://llvm.org/docs/DeveloperPolicy.html>`__
+and `Getting started with LLVM <https://llvm.org/docs/GettingStarted.html>`__.
 
 **Bug Reports**
 
@@ -84,7 +84,7 @@ Please include "libunwind" in your subject.
 **Patches**
 
 If you want to contribute a patch to libunwind, the best place for that is
-`Phabricator <http://llvm.org/docs/Phabricator.html>`_. Please include [libunwind] in the subject and
+`Phabricator <https://llvm.org/docs/Phabricator.html>`_. Please include [libunwind] in the subject and
 add `cfe-commits` as a subscriber. Also make sure you are subscribed to the
 `cfe-commits mailing list <http://lists.llvm.org/mailman/listinfo/cfe-commits>`_.
 
@@ -97,9 +97,8 @@ Please include [libunwind] in the subject.
 
 Quick Links
 ===========
-* `LLVM Homepage <http://llvm.org/>`_
-* `LLVM Bugzilla <https://bugs.llvm.org/>`_
+* `LLVM Homepage <https://llvm.org/>`_
+* `LLVM bug tracker <https://github.com/llvm/llvm-project/labels/libunwind/>`_
 * `cfe-commits Mailing List`_
 * `cfe-dev Mailing List`_
-* `Browse libunwind -- SVN <http://llvm.org/svn/llvm-project/libunwind/trunk/>`_
-* `Browse libunwind -- ViewVC <http://llvm.org/viewvc/llvm-project/libunwind/trunk/>`_
+* `Browse libunwind Sources <https://github.com/llvm/llvm-project/blob/main/libunwind/>`_
diff --git a/WAVM/ThirdParty/libunwind/include/CMakeLists.txt b/WAVM/ThirdParty/libunwind/include/CMakeLists.txt
new file mode 100644
index 00000000..adf1766c
--- /dev/null
+++ b/WAVM/ThirdParty/libunwind/include/CMakeLists.txt
@@ -0,0 +1,31 @@
+set(files
+    __libunwind_config.h
+    libunwind.h
+    mach-o/compact_unwind_encoding.h
+    unwind_arm_ehabi.h
+    unwind_itanium.h
+    unwind.h
+    )
+
+add_library(unwind-headers INTERFACE)
+target_include_directories(unwind-headers INTERFACE ${CMAKE_CURRENT_SOURCE_DIR})
+
+if(LIBUNWIND_INSTALL_HEADERS)
+  foreach(file ${files})
+    get_filename_component(dir ${file} DIRECTORY)
+    install(FILES ${file}
+      DESTINATION "${LIBUNWIND_INSTALL_INCLUDE_DIR}/${dir}"
+      COMPONENT unwind-headers
+      PERMISSIONS OWNER_READ OWNER_WRITE GROUP_READ WORLD_READ
+    )
+  endforeach()
+
+  if(NOT CMAKE_CONFIGURATION_TYPES)
+    add_custom_target(install-unwind-headers
+      DEPENDS unwind-headers
+      COMMAND "${CMAKE_COMMAND}"
+              -DCMAKE_INSTALL_COMPONENT=unwind-headers
+              -P "${LIBUNWIND_BINARY_DIR}/cmake_install.cmake")
+    add_custom_target(install-unwind-headers-stripped DEPENDS install-unwind-headers)
+  endif()
+endif()
diff --git a/WAVM/ThirdParty/libunwind/include/__libunwind_config.h b/WAVM/ThirdParty/libunwind/include/__libunwind_config.h
index 1b75fa9e..e87bcf40 100644
--- a/WAVM/ThirdParty/libunwind/include/__libunwind_config.h
+++ b/WAVM/ThirdParty/libunwind/include/__libunwind_config.h
@@ -1,9 +1,8 @@
-//===------------------------- __libunwind_config.h -----------------------===//
-//
-//                     The LLVM Compiler Infrastructure
+//===----------------------------------------------------------------------===//
 //
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
@@ -21,10 +20,18 @@
 #define _LIBUNWIND_HIGHEST_DWARF_REGISTER_PPC64     116
 #define _LIBUNWIND_HIGHEST_DWARF_REGISTER_ARM64     95
 #define _LIBUNWIND_HIGHEST_DWARF_REGISTER_ARM       287
-#define _LIBUNWIND_HIGHEST_DWARF_REGISTER_OR1K      31
+#define _LIBUNWIND_HIGHEST_DWARF_REGISTER_OR1K      32
 #define _LIBUNWIND_HIGHEST_DWARF_REGISTER_MIPS      65
+#define _LIBUNWIND_HIGHEST_DWARF_REGISTER_SPARC     31
+#define _LIBUNWIND_HIGHEST_DWARF_REGISTER_SPARC64   31
+#define _LIBUNWIND_HIGHEST_DWARF_REGISTER_HEXAGON   34
+#define _LIBUNWIND_HIGHEST_DWARF_REGISTER_RISCV     64
+#define _LIBUNWIND_HIGHEST_DWARF_REGISTER_VE        143
 
 #if defined(_LIBUNWIND_IS_NATIVE_ONLY)
+# if defined(__linux__)
+#  define _LIBUNWIND_TARGET_LINUX 1
+# endif
 # if defined(__i386__)
 #  define _LIBUNWIND_TARGET_I386
 #  define _LIBUNWIND_CONTEXT_SIZE 8
@@ -34,7 +41,11 @@
 #  define _LIBUNWIND_TARGET_X86_64 1
 #  if defined(_WIN64)
 #    define _LIBUNWIND_CONTEXT_SIZE 54
-#    define _LIBUNWIND_CURSOR_SIZE 66
+#    ifdef __SEH__
+#      define _LIBUNWIND_CURSOR_SIZE 204
+#    else
+#      define _LIBUNWIND_CURSOR_SIZE 66
+#    endif
 #  else
 #    define _LIBUNWIND_CONTEXT_SIZE 21
 #    define _LIBUNWIND_CURSOR_SIZE 33
@@ -45,7 +56,7 @@
 #  define _LIBUNWIND_CONTEXT_SIZE 167
 #  define _LIBUNWIND_CURSOR_SIZE 179
 #  define _LIBUNWIND_HIGHEST_DWARF_REGISTER _LIBUNWIND_HIGHEST_DWARF_REGISTER_PPC64
-# elif defined(__ppc__)
+# elif defined(__powerpc__)
 #  define _LIBUNWIND_TARGET_PPC 1
 #  define _LIBUNWIND_CONTEXT_SIZE 117
 #  define _LIBUNWIND_CURSOR_SIZE 124
@@ -53,11 +64,18 @@
 # elif defined(__aarch64__)
 #  define _LIBUNWIND_TARGET_AARCH64 1
 #  define _LIBUNWIND_CONTEXT_SIZE 66
-#  define _LIBUNWIND_CURSOR_SIZE 78
+#  if defined(__SEH__)
+#    define _LIBUNWIND_CURSOR_SIZE 164
+#  else
+#    define _LIBUNWIND_CURSOR_SIZE 78
+#  endif
 #  define _LIBUNWIND_HIGHEST_DWARF_REGISTER _LIBUNWIND_HIGHEST_DWARF_REGISTER_ARM64
 # elif defined(__arm__)
 #  define _LIBUNWIND_TARGET_ARM 1
-#  if defined(__ARM_WMMX)
+#  if defined(__SEH__)
+#    define _LIBUNWIND_CONTEXT_SIZE 42
+#    define _LIBUNWIND_CURSOR_SIZE 80
+#  elif defined(__ARM_WMMX)
 #    define _LIBUNWIND_CONTEXT_SIZE 61
 #    define _LIBUNWIND_CURSOR_SIZE 68
 #  else
@@ -70,23 +88,76 @@
 #  define _LIBUNWIND_CONTEXT_SIZE 16
 #  define _LIBUNWIND_CURSOR_SIZE 24
 #  define _LIBUNWIND_HIGHEST_DWARF_REGISTER _LIBUNWIND_HIGHEST_DWARF_REGISTER_OR1K
+# elif defined(__hexagon__)
+#  define _LIBUNWIND_TARGET_HEXAGON 1
+// Values here change when : Registers.hpp - hexagon_thread_state_t change
+#  define _LIBUNWIND_CONTEXT_SIZE 18
+#  define _LIBUNWIND_CURSOR_SIZE 24
+#  define _LIBUNWIND_HIGHEST_DWARF_REGISTER _LIBUNWIND_HIGHEST_DWARF_REGISTER_HEXAGON
 # elif defined(__mips__)
-#  if defined(_ABIO32) && _MIPS_SIM == _ABIO32 && defined(__mips_soft_float)
+#  if defined(_ABIO32) && _MIPS_SIM == _ABIO32
 #    define _LIBUNWIND_TARGET_MIPS_O32 1
-#    define _LIBUNWIND_CONTEXT_SIZE 18
-#    define _LIBUNWIND_CURSOR_SIZE 24
-#  elif defined(_ABIN32) && _MIPS_SIM == _ABIN32 && defined(__mips_soft_float)
+#    if defined(__mips_hard_float)
+#      define _LIBUNWIND_CONTEXT_SIZE 50
+#      define _LIBUNWIND_CURSOR_SIZE 57
+#    else
+#      define _LIBUNWIND_CONTEXT_SIZE 18
+#      define _LIBUNWIND_CURSOR_SIZE 24
+#    endif
+#  elif defined(_ABIN32) && _MIPS_SIM == _ABIN32
 #    define _LIBUNWIND_TARGET_MIPS_NEWABI 1
-#    define _LIBUNWIND_CONTEXT_SIZE 35
-#    define _LIBUNWIND_CURSOR_SIZE 42
-#  elif defined(_ABI64) && _MIPS_SIM == _ABI64 && defined(__mips_soft_float)
+#    if defined(__mips_hard_float)
+#      define _LIBUNWIND_CONTEXT_SIZE 67
+#      define _LIBUNWIND_CURSOR_SIZE 74
+#    else
+#      define _LIBUNWIND_CONTEXT_SIZE 35
+#      define _LIBUNWIND_CURSOR_SIZE 42
+#    endif
+#  elif defined(_ABI64) && _MIPS_SIM == _ABI64
 #    define _LIBUNWIND_TARGET_MIPS_NEWABI 1
-#    define _LIBUNWIND_CONTEXT_SIZE 35
-#    define _LIBUNWIND_CURSOR_SIZE 47
+#    if defined(__mips_hard_float)
+#      define _LIBUNWIND_CONTEXT_SIZE 67
+#      define _LIBUNWIND_CURSOR_SIZE 79
+#    else
+#      define _LIBUNWIND_CONTEXT_SIZE 35
+#      define _LIBUNWIND_CURSOR_SIZE 47
+#    endif
 #  else
 #    error "Unsupported MIPS ABI and/or environment"
 #  endif
 #  define _LIBUNWIND_HIGHEST_DWARF_REGISTER _LIBUNWIND_HIGHEST_DWARF_REGISTER_MIPS
+#elif defined(__sparc__) && defined(__arch64__)
+#define _LIBUNWIND_TARGET_SPARC64 1
+#define _LIBUNWIND_HIGHEST_DWARF_REGISTER                                      \
+  _LIBUNWIND_HIGHEST_DWARF_REGISTER_SPARC64
+#define _LIBUNWIND_CONTEXT_SIZE 33
+#define _LIBUNWIND_CURSOR_SIZE 45
+# elif defined(__sparc__)
+  #define _LIBUNWIND_TARGET_SPARC 1
+  #define _LIBUNWIND_HIGHEST_DWARF_REGISTER _LIBUNWIND_HIGHEST_DWARF_REGISTER_SPARC
+  #define _LIBUNWIND_CONTEXT_SIZE 16
+  #define _LIBUNWIND_CURSOR_SIZE 23
+# elif defined(__riscv)
+#  define _LIBUNWIND_TARGET_RISCV 1
+#  if defined(__riscv_flen)
+#   define RISCV_FLEN __riscv_flen
+#  else
+#   define RISCV_FLEN 0
+#  endif
+#  define _LIBUNWIND_CONTEXT_SIZE (32 * (__riscv_xlen + RISCV_FLEN) / 64)
+#  if __riscv_xlen == 32
+#   define _LIBUNWIND_CURSOR_SIZE (_LIBUNWIND_CONTEXT_SIZE + 7)
+#  elif __riscv_xlen == 64
+#   define _LIBUNWIND_CURSOR_SIZE (_LIBUNWIND_CONTEXT_SIZE + 12)
+#  else
+#   error "Unsupported RISC-V ABI"
+#  endif
+# define _LIBUNWIND_HIGHEST_DWARF_REGISTER _LIBUNWIND_HIGHEST_DWARF_REGISTER_RISCV
+# elif defined(__ve__)
+#  define _LIBUNWIND_TARGET_VE 1
+#  define _LIBUNWIND_CONTEXT_SIZE 67
+#  define _LIBUNWIND_CURSOR_SIZE 79
+#  define _LIBUNWIND_HIGHEST_DWARF_REGISTER _LIBUNWIND_HIGHEST_DWARF_REGISTER_VE
 # else
 #  error "Unsupported architecture."
 # endif
@@ -100,6 +171,11 @@
 # define _LIBUNWIND_TARGET_OR1K 1
 # define _LIBUNWIND_TARGET_MIPS_O32 1
 # define _LIBUNWIND_TARGET_MIPS_NEWABI 1
+# define _LIBUNWIND_TARGET_SPARC 1
+# define _LIBUNWIND_TARGET_SPARC64 1
+# define _LIBUNWIND_TARGET_HEXAGON 1
+# define _LIBUNWIND_TARGET_RISCV 1
+# define _LIBUNWIND_TARGET_VE 1
 # define _LIBUNWIND_CONTEXT_SIZE 167
 # define _LIBUNWIND_CURSOR_SIZE 179
 # define _LIBUNWIND_HIGHEST_DWARF_REGISTER 287
diff --git a/WAVM/ThirdParty/libunwind/include/libunwind.h b/WAVM/ThirdParty/libunwind/include/libunwind.h
index 04e31e8e..9a74faa4 100644
--- a/WAVM/ThirdParty/libunwind/include/libunwind.h
+++ b/WAVM/ThirdParty/libunwind/include/libunwind.h
@@ -1,9 +1,8 @@
-//===---------------------------- libunwind.h -----------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
+//===----------------------------------------------------------------------===//
 //
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //
 // Compatible with libunwind API documented at:
@@ -44,6 +43,12 @@
   #define LIBUNWIND_AVAIL
 #endif
 
+#if defined(_WIN32) && defined(__SEH__)
+  #define LIBUNWIND_CURSOR_ALIGNMENT_ATTR __attribute__((__aligned__(16)))
+#else
+  #define LIBUNWIND_CURSOR_ALIGNMENT_ATTR
+#endif
+
 /* error codes */
 enum {
   UNW_ESUCCESS      = 0,     /* no error */
@@ -57,6 +62,9 @@ enum {
   UNW_EINVAL        = -6547, /* unsupported operation or bad value */
   UNW_EBADVERSION   = -6548, /* unwind info has unsupported version */
   UNW_ENOINFO       = -6549  /* no unwind info found */
+#if defined(_LIBUNWIND_TARGET_AARCH64) && !defined(_LIBUNWIND_IS_NATIVE_ONLY)
+  , UNW_ECROSSRASIGNING = -6550 /* cross unwind with return address signing */
+#endif
 };
 
 struct unw_context_t {
@@ -66,14 +74,14 @@ typedef struct unw_context_t unw_context_t;
 
 struct unw_cursor_t {
   uint64_t data[_LIBUNWIND_CURSOR_SIZE];
-};
+} LIBUNWIND_CURSOR_ALIGNMENT_ATTR;
 typedef struct unw_cursor_t unw_cursor_t;
 
 typedef struct unw_addr_space *unw_addr_space_t;
 
 typedef int unw_regnum_t;
 typedef uintptr_t unw_word_t;
-#if defined(__arm__)
+#if defined(__arm__) && !defined(__ARM_DWARF_EH__)
 typedef uint64_t unw_fpreg_t;
 #else
 typedef double unw_fpreg_t;
@@ -122,32 +130,6 @@ extern int unw_get_proc_name(unw_cursor_t *, char *, size_t, unw_word_t *) LIBUN
 
 extern unw_addr_space_t unw_local_addr_space;
 
-#ifdef UNW_REMOTE
-/*
- * Mac OS X "remote" API for unwinding other processes on same machine
- *
- */
-extern unw_addr_space_t unw_create_addr_space_for_task(task_t);
-extern void unw_destroy_addr_space(unw_addr_space_t);
-extern int unw_init_remote_thread(unw_cursor_t *, unw_addr_space_t, thread_t *);
-#endif /* UNW_REMOTE */
-
-/*
- * traditional libunwind "remote" API
- *   NOT IMPLEMENTED on Mac OS X
- *
- * extern int               unw_init_remote(unw_cursor_t*, unw_addr_space_t,
- *                                          thread_t*);
- * extern unw_accessors_t   unw_get_accessors(unw_addr_space_t);
- * extern unw_addr_space_t  unw_create_addr_space(unw_accessors_t, int);
- * extern void              unw_flush_cache(unw_addr_space_t, unw_word_t,
- *                                          unw_word_t);
- * extern int               unw_set_caching_policy(unw_addr_space_t,
- *                                                 unw_caching_policy_t);
- * extern void              _U_dyn_register(unw_dyn_info_t*);
- * extern void              _U_dyn_cancel(unw_dyn_info_t*);
- */
-
 #ifdef __cplusplus
 }
 #endif
@@ -511,74 +493,150 @@ enum {
 
 // 64-bit ARM64 registers
 enum {
-  UNW_ARM64_X0  = 0,
-  UNW_ARM64_X1  = 1,
-  UNW_ARM64_X2  = 2,
-  UNW_ARM64_X3  = 3,
-  UNW_ARM64_X4  = 4,
-  UNW_ARM64_X5  = 5,
-  UNW_ARM64_X6  = 6,
-  UNW_ARM64_X7  = 7,
-  UNW_ARM64_X8  = 8,
-  UNW_ARM64_X9  = 9,
-  UNW_ARM64_X10 = 10,
-  UNW_ARM64_X11 = 11,
-  UNW_ARM64_X12 = 12,
-  UNW_ARM64_X13 = 13,
-  UNW_ARM64_X14 = 14,
-  UNW_ARM64_X15 = 15,
-  UNW_ARM64_X16 = 16,
-  UNW_ARM64_X17 = 17,
-  UNW_ARM64_X18 = 18,
-  UNW_ARM64_X19 = 19,
-  UNW_ARM64_X20 = 20,
-  UNW_ARM64_X21 = 21,
-  UNW_ARM64_X22 = 22,
-  UNW_ARM64_X23 = 23,
-  UNW_ARM64_X24 = 24,
-  UNW_ARM64_X25 = 25,
-  UNW_ARM64_X26 = 26,
-  UNW_ARM64_X27 = 27,
-  UNW_ARM64_X28 = 28,
-  UNW_ARM64_X29 = 29,
-  UNW_ARM64_FP  = 29,
-  UNW_ARM64_X30 = 30,
-  UNW_ARM64_LR  = 30,
-  UNW_ARM64_X31 = 31,
-  UNW_ARM64_SP  = 31,
+  UNW_AARCH64_X0 = 0,
+  UNW_AARCH64_X1 = 1,
+  UNW_AARCH64_X2 = 2,
+  UNW_AARCH64_X3 = 3,
+  UNW_AARCH64_X4 = 4,
+  UNW_AARCH64_X5 = 5,
+  UNW_AARCH64_X6 = 6,
+  UNW_AARCH64_X7 = 7,
+  UNW_AARCH64_X8 = 8,
+  UNW_AARCH64_X9 = 9,
+  UNW_AARCH64_X10 = 10,
+  UNW_AARCH64_X11 = 11,
+  UNW_AARCH64_X12 = 12,
+  UNW_AARCH64_X13 = 13,
+  UNW_AARCH64_X14 = 14,
+  UNW_AARCH64_X15 = 15,
+  UNW_AARCH64_X16 = 16,
+  UNW_AARCH64_X17 = 17,
+  UNW_AARCH64_X18 = 18,
+  UNW_AARCH64_X19 = 19,
+  UNW_AARCH64_X20 = 20,
+  UNW_AARCH64_X21 = 21,
+  UNW_AARCH64_X22 = 22,
+  UNW_AARCH64_X23 = 23,
+  UNW_AARCH64_X24 = 24,
+  UNW_AARCH64_X25 = 25,
+  UNW_AARCH64_X26 = 26,
+  UNW_AARCH64_X27 = 27,
+  UNW_AARCH64_X28 = 28,
+  UNW_AARCH64_X29 = 29,
+  UNW_AARCH64_FP = 29,
+  UNW_AARCH64_X30 = 30,
+  UNW_AARCH64_LR = 30,
+  UNW_AARCH64_X31 = 31,
+  UNW_AARCH64_SP = 31,
+  UNW_AARCH64_PC = 32,
+
   // reserved block
-  UNW_ARM64_D0  = 64,
-  UNW_ARM64_D1  = 65,
-  UNW_ARM64_D2  = 66,
-  UNW_ARM64_D3  = 67,
-  UNW_ARM64_D4  = 68,
-  UNW_ARM64_D5  = 69,
-  UNW_ARM64_D6  = 70,
-  UNW_ARM64_D7  = 71,
-  UNW_ARM64_D8  = 72,
-  UNW_ARM64_D9  = 73,
-  UNW_ARM64_D10 = 74,
-  UNW_ARM64_D11 = 75,
-  UNW_ARM64_D12 = 76,
-  UNW_ARM64_D13 = 77,
-  UNW_ARM64_D14 = 78,
-  UNW_ARM64_D15 = 79,
-  UNW_ARM64_D16 = 80,
-  UNW_ARM64_D17 = 81,
-  UNW_ARM64_D18 = 82,
-  UNW_ARM64_D19 = 83,
-  UNW_ARM64_D20 = 84,
-  UNW_ARM64_D21 = 85,
-  UNW_ARM64_D22 = 86,
-  UNW_ARM64_D23 = 87,
-  UNW_ARM64_D24 = 88,
-  UNW_ARM64_D25 = 89,
-  UNW_ARM64_D26 = 90,
-  UNW_ARM64_D27 = 91,
-  UNW_ARM64_D28 = 92,
-  UNW_ARM64_D29 = 93,
-  UNW_ARM64_D30 = 94,
-  UNW_ARM64_D31 = 95,
+  UNW_AARCH64_RA_SIGN_STATE = 34,
+
+  // FP/vector registers
+  UNW_AARCH64_V0 = 64,
+  UNW_AARCH64_V1 = 65,
+  UNW_AARCH64_V2 = 66,
+  UNW_AARCH64_V3 = 67,
+  UNW_AARCH64_V4 = 68,
+  UNW_AARCH64_V5 = 69,
+  UNW_AARCH64_V6 = 70,
+  UNW_AARCH64_V7 = 71,
+  UNW_AARCH64_V8 = 72,
+  UNW_AARCH64_V9 = 73,
+  UNW_AARCH64_V10 = 74,
+  UNW_AARCH64_V11 = 75,
+  UNW_AARCH64_V12 = 76,
+  UNW_AARCH64_V13 = 77,
+  UNW_AARCH64_V14 = 78,
+  UNW_AARCH64_V15 = 79,
+  UNW_AARCH64_V16 = 80,
+  UNW_AARCH64_V17 = 81,
+  UNW_AARCH64_V18 = 82,
+  UNW_AARCH64_V19 = 83,
+  UNW_AARCH64_V20 = 84,
+  UNW_AARCH64_V21 = 85,
+  UNW_AARCH64_V22 = 86,
+  UNW_AARCH64_V23 = 87,
+  UNW_AARCH64_V24 = 88,
+  UNW_AARCH64_V25 = 89,
+  UNW_AARCH64_V26 = 90,
+  UNW_AARCH64_V27 = 91,
+  UNW_AARCH64_V28 = 92,
+  UNW_AARCH64_V29 = 93,
+  UNW_AARCH64_V30 = 94,
+  UNW_AARCH64_V31 = 95,
+
+  // Compatibility aliases
+  UNW_ARM64_X0 = UNW_AARCH64_X0,
+  UNW_ARM64_X1 = UNW_AARCH64_X1,
+  UNW_ARM64_X2 = UNW_AARCH64_X2,
+  UNW_ARM64_X3 = UNW_AARCH64_X3,
+  UNW_ARM64_X4 = UNW_AARCH64_X4,
+  UNW_ARM64_X5 = UNW_AARCH64_X5,
+  UNW_ARM64_X6 = UNW_AARCH64_X6,
+  UNW_ARM64_X7 = UNW_AARCH64_X7,
+  UNW_ARM64_X8 = UNW_AARCH64_X8,
+  UNW_ARM64_X9 = UNW_AARCH64_X9,
+  UNW_ARM64_X10 = UNW_AARCH64_X10,
+  UNW_ARM64_X11 = UNW_AARCH64_X11,
+  UNW_ARM64_X12 = UNW_AARCH64_X12,
+  UNW_ARM64_X13 = UNW_AARCH64_X13,
+  UNW_ARM64_X14 = UNW_AARCH64_X14,
+  UNW_ARM64_X15 = UNW_AARCH64_X15,
+  UNW_ARM64_X16 = UNW_AARCH64_X16,
+  UNW_ARM64_X17 = UNW_AARCH64_X17,
+  UNW_ARM64_X18 = UNW_AARCH64_X18,
+  UNW_ARM64_X19 = UNW_AARCH64_X19,
+  UNW_ARM64_X20 = UNW_AARCH64_X20,
+  UNW_ARM64_X21 = UNW_AARCH64_X21,
+  UNW_ARM64_X22 = UNW_AARCH64_X22,
+  UNW_ARM64_X23 = UNW_AARCH64_X23,
+  UNW_ARM64_X24 = UNW_AARCH64_X24,
+  UNW_ARM64_X25 = UNW_AARCH64_X25,
+  UNW_ARM64_X26 = UNW_AARCH64_X26,
+  UNW_ARM64_X27 = UNW_AARCH64_X27,
+  UNW_ARM64_X28 = UNW_AARCH64_X28,
+  UNW_ARM64_X29 = UNW_AARCH64_X29,
+  UNW_ARM64_FP = UNW_AARCH64_FP,
+  UNW_ARM64_X30 = UNW_AARCH64_X30,
+  UNW_ARM64_LR = UNW_AARCH64_LR,
+  UNW_ARM64_X31 = UNW_AARCH64_X31,
+  UNW_ARM64_SP = UNW_AARCH64_SP,
+  UNW_ARM64_PC = UNW_AARCH64_PC,
+  UNW_ARM64_RA_SIGN_STATE = UNW_AARCH64_RA_SIGN_STATE,
+  UNW_ARM64_D0 = UNW_AARCH64_V0,
+  UNW_ARM64_D1 = UNW_AARCH64_V1,
+  UNW_ARM64_D2 = UNW_AARCH64_V2,
+  UNW_ARM64_D3 = UNW_AARCH64_V3,
+  UNW_ARM64_D4 = UNW_AARCH64_V4,
+  UNW_ARM64_D5 = UNW_AARCH64_V5,
+  UNW_ARM64_D6 = UNW_AARCH64_V6,
+  UNW_ARM64_D7 = UNW_AARCH64_V7,
+  UNW_ARM64_D8 = UNW_AARCH64_V8,
+  UNW_ARM64_D9 = UNW_AARCH64_V9,
+  UNW_ARM64_D10 = UNW_AARCH64_V10,
+  UNW_ARM64_D11 = UNW_AARCH64_V11,
+  UNW_ARM64_D12 = UNW_AARCH64_V12,
+  UNW_ARM64_D13 = UNW_AARCH64_V13,
+  UNW_ARM64_D14 = UNW_AARCH64_V14,
+  UNW_ARM64_D15 = UNW_AARCH64_V15,
+  UNW_ARM64_D16 = UNW_AARCH64_V16,
+  UNW_ARM64_D17 = UNW_AARCH64_V17,
+  UNW_ARM64_D18 = UNW_AARCH64_V18,
+  UNW_ARM64_D19 = UNW_AARCH64_V19,
+  UNW_ARM64_D20 = UNW_AARCH64_V20,
+  UNW_ARM64_D21 = UNW_AARCH64_V21,
+  UNW_ARM64_D22 = UNW_AARCH64_V22,
+  UNW_ARM64_D23 = UNW_AARCH64_V23,
+  UNW_ARM64_D24 = UNW_AARCH64_V24,
+  UNW_ARM64_D25 = UNW_AARCH64_V25,
+  UNW_ARM64_D26 = UNW_AARCH64_V26,
+  UNW_ARM64_D27 = UNW_AARCH64_V27,
+  UNW_ARM64_D28 = UNW_AARCH64_V28,
+  UNW_ARM64_D29 = UNW_AARCH64_V29,
+  UNW_ARM64_D30 = UNW_AARCH64_V30,
+  UNW_ARM64_D31 = UNW_AARCH64_V31,
 };
 
 // 32-bit ARM registers. Numbers match DWARF for ARM spec #3.1 Table 1.
@@ -660,7 +718,8 @@ enum {
   UNW_ARM_WR14 = 126,
   UNW_ARM_WR15 = 127,
   // 128-133 -- SPSR, SPSR_{FIQ|IRQ|ABT|UND|SVC}
-  // 134-143 -- Reserved
+  // 134-142 -- Reserved
+  UNW_ARM_RA_AUTH_CODE = 143,
   // 144-150 -- R8_USR-R14_USR
   // 151-157 -- R8_FIQ-R14_FIQ
   // 158-159 -- R13_IRQ-R14_IRQ
@@ -745,6 +804,7 @@ enum {
   UNW_OR1K_R29 = 29,
   UNW_OR1K_R30 = 30,
   UNW_OR1K_R31 = 31,
+  UNW_OR1K_EPCR = 32,
 };
 
 // MIPS registers
@@ -781,8 +841,337 @@ enum {
   UNW_MIPS_R29 = 29,
   UNW_MIPS_R30 = 30,
   UNW_MIPS_R31 = 31,
+  UNW_MIPS_F0  = 32,
+  UNW_MIPS_F1  = 33,
+  UNW_MIPS_F2  = 34,
+  UNW_MIPS_F3  = 35,
+  UNW_MIPS_F4  = 36,
+  UNW_MIPS_F5  = 37,
+  UNW_MIPS_F6  = 38,
+  UNW_MIPS_F7  = 39,
+  UNW_MIPS_F8  = 40,
+  UNW_MIPS_F9  = 41,
+  UNW_MIPS_F10 = 42,
+  UNW_MIPS_F11 = 43,
+  UNW_MIPS_F12 = 44,
+  UNW_MIPS_F13 = 45,
+  UNW_MIPS_F14 = 46,
+  UNW_MIPS_F15 = 47,
+  UNW_MIPS_F16 = 48,
+  UNW_MIPS_F17 = 49,
+  UNW_MIPS_F18 = 50,
+  UNW_MIPS_F19 = 51,
+  UNW_MIPS_F20 = 52,
+  UNW_MIPS_F21 = 53,
+  UNW_MIPS_F22 = 54,
+  UNW_MIPS_F23 = 55,
+  UNW_MIPS_F24 = 56,
+  UNW_MIPS_F25 = 57,
+  UNW_MIPS_F26 = 58,
+  UNW_MIPS_F27 = 59,
+  UNW_MIPS_F28 = 60,
+  UNW_MIPS_F29 = 61,
+  UNW_MIPS_F30 = 62,
+  UNW_MIPS_F31 = 63,
   UNW_MIPS_HI = 64,
   UNW_MIPS_LO = 65,
 };
 
+// SPARC registers
+enum {
+  UNW_SPARC_G0 = 0,
+  UNW_SPARC_G1 = 1,
+  UNW_SPARC_G2 = 2,
+  UNW_SPARC_G3 = 3,
+  UNW_SPARC_G4 = 4,
+  UNW_SPARC_G5 = 5,
+  UNW_SPARC_G6 = 6,
+  UNW_SPARC_G7 = 7,
+  UNW_SPARC_O0 = 8,
+  UNW_SPARC_O1 = 9,
+  UNW_SPARC_O2 = 10,
+  UNW_SPARC_O3 = 11,
+  UNW_SPARC_O4 = 12,
+  UNW_SPARC_O5 = 13,
+  UNW_SPARC_O6 = 14,
+  UNW_SPARC_O7 = 15,
+  UNW_SPARC_L0 = 16,
+  UNW_SPARC_L1 = 17,
+  UNW_SPARC_L2 = 18,
+  UNW_SPARC_L3 = 19,
+  UNW_SPARC_L4 = 20,
+  UNW_SPARC_L5 = 21,
+  UNW_SPARC_L6 = 22,
+  UNW_SPARC_L7 = 23,
+  UNW_SPARC_I0 = 24,
+  UNW_SPARC_I1 = 25,
+  UNW_SPARC_I2 = 26,
+  UNW_SPARC_I3 = 27,
+  UNW_SPARC_I4 = 28,
+  UNW_SPARC_I5 = 29,
+  UNW_SPARC_I6 = 30,
+  UNW_SPARC_I7 = 31,
+};
+
+// Hexagon register numbers
+enum {
+  UNW_HEXAGON_R0,
+  UNW_HEXAGON_R1,
+  UNW_HEXAGON_R2,
+  UNW_HEXAGON_R3,
+  UNW_HEXAGON_R4,
+  UNW_HEXAGON_R5,
+  UNW_HEXAGON_R6,
+  UNW_HEXAGON_R7,
+  UNW_HEXAGON_R8,
+  UNW_HEXAGON_R9,
+  UNW_HEXAGON_R10,
+  UNW_HEXAGON_R11,
+  UNW_HEXAGON_R12,
+  UNW_HEXAGON_R13,
+  UNW_HEXAGON_R14,
+  UNW_HEXAGON_R15,
+  UNW_HEXAGON_R16,
+  UNW_HEXAGON_R17,
+  UNW_HEXAGON_R18,
+  UNW_HEXAGON_R19,
+  UNW_HEXAGON_R20,
+  UNW_HEXAGON_R21,
+  UNW_HEXAGON_R22,
+  UNW_HEXAGON_R23,
+  UNW_HEXAGON_R24,
+  UNW_HEXAGON_R25,
+  UNW_HEXAGON_R26,
+  UNW_HEXAGON_R27,
+  UNW_HEXAGON_R28,
+  UNW_HEXAGON_R29,
+  UNW_HEXAGON_R30,
+  UNW_HEXAGON_R31,
+  UNW_HEXAGON_P3_0,
+  UNW_HEXAGON_PC,
+};
+
+// RISC-V registers. These match the DWARF register numbers defined by section
+// 4 of the RISC-V ELF psABI specification, which can be found at:
+//
+// https://github.com/riscv/riscv-elf-psabi-doc/blob/master/riscv-elf.md
+enum {
+  UNW_RISCV_X0  = 0,
+  UNW_RISCV_X1  = 1,
+  UNW_RISCV_X2  = 2,
+  UNW_RISCV_X3  = 3,
+  UNW_RISCV_X4  = 4,
+  UNW_RISCV_X5  = 5,
+  UNW_RISCV_X6  = 6,
+  UNW_RISCV_X7  = 7,
+  UNW_RISCV_X8  = 8,
+  UNW_RISCV_X9  = 9,
+  UNW_RISCV_X10 = 10,
+  UNW_RISCV_X11 = 11,
+  UNW_RISCV_X12 = 12,
+  UNW_RISCV_X13 = 13,
+  UNW_RISCV_X14 = 14,
+  UNW_RISCV_X15 = 15,
+  UNW_RISCV_X16 = 16,
+  UNW_RISCV_X17 = 17,
+  UNW_RISCV_X18 = 18,
+  UNW_RISCV_X19 = 19,
+  UNW_RISCV_X20 = 20,
+  UNW_RISCV_X21 = 21,
+  UNW_RISCV_X22 = 22,
+  UNW_RISCV_X23 = 23,
+  UNW_RISCV_X24 = 24,
+  UNW_RISCV_X25 = 25,
+  UNW_RISCV_X26 = 26,
+  UNW_RISCV_X27 = 27,
+  UNW_RISCV_X28 = 28,
+  UNW_RISCV_X29 = 29,
+  UNW_RISCV_X30 = 30,
+  UNW_RISCV_X31 = 31,
+  UNW_RISCV_F0  = 32,
+  UNW_RISCV_F1  = 33,
+  UNW_RISCV_F2  = 34,
+  UNW_RISCV_F3  = 35,
+  UNW_RISCV_F4  = 36,
+  UNW_RISCV_F5  = 37,
+  UNW_RISCV_F6  = 38,
+  UNW_RISCV_F7  = 39,
+  UNW_RISCV_F8  = 40,
+  UNW_RISCV_F9  = 41,
+  UNW_RISCV_F10 = 42,
+  UNW_RISCV_F11 = 43,
+  UNW_RISCV_F12 = 44,
+  UNW_RISCV_F13 = 45,
+  UNW_RISCV_F14 = 46,
+  UNW_RISCV_F15 = 47,
+  UNW_RISCV_F16 = 48,
+  UNW_RISCV_F17 = 49,
+  UNW_RISCV_F18 = 50,
+  UNW_RISCV_F19 = 51,
+  UNW_RISCV_F20 = 52,
+  UNW_RISCV_F21 = 53,
+  UNW_RISCV_F22 = 54,
+  UNW_RISCV_F23 = 55,
+  UNW_RISCV_F24 = 56,
+  UNW_RISCV_F25 = 57,
+  UNW_RISCV_F26 = 58,
+  UNW_RISCV_F27 = 59,
+  UNW_RISCV_F28 = 60,
+  UNW_RISCV_F29 = 61,
+  UNW_RISCV_F30 = 62,
+  UNW_RISCV_F31 = 63,
+};
+
+// VE register numbers
+enum {
+  UNW_VE_S0   = 0,
+  UNW_VE_S1   = 1,
+  UNW_VE_S2   = 2,
+  UNW_VE_S3   = 3,
+  UNW_VE_S4   = 4,
+  UNW_VE_S5   = 5,
+  UNW_VE_S6   = 6,
+  UNW_VE_S7   = 7,
+  UNW_VE_S8   = 8,
+  UNW_VE_S9   = 9,
+  UNW_VE_S10  = 10,
+  UNW_VE_S11  = 11,
+  UNW_VE_S12  = 12,
+  UNW_VE_S13  = 13,
+  UNW_VE_S14  = 14,
+  UNW_VE_S15  = 15,
+  UNW_VE_S16  = 16,
+  UNW_VE_S17  = 17,
+  UNW_VE_S18  = 18,
+  UNW_VE_S19  = 19,
+  UNW_VE_S20  = 20,
+  UNW_VE_S21  = 21,
+  UNW_VE_S22  = 22,
+  UNW_VE_S23  = 23,
+  UNW_VE_S24  = 24,
+  UNW_VE_S25  = 25,
+  UNW_VE_S26  = 26,
+  UNW_VE_S27  = 27,
+  UNW_VE_S28  = 28,
+  UNW_VE_S29  = 29,
+  UNW_VE_S30  = 30,
+  UNW_VE_S31  = 31,
+  UNW_VE_S32  = 32,
+  UNW_VE_S33  = 33,
+  UNW_VE_S34  = 34,
+  UNW_VE_S35  = 35,
+  UNW_VE_S36  = 36,
+  UNW_VE_S37  = 37,
+  UNW_VE_S38  = 38,
+  UNW_VE_S39  = 39,
+  UNW_VE_S40  = 40,
+  UNW_VE_S41  = 41,
+  UNW_VE_S42  = 42,
+  UNW_VE_S43  = 43,
+  UNW_VE_S44  = 44,
+  UNW_VE_S45  = 45,
+  UNW_VE_S46  = 46,
+  UNW_VE_S47  = 47,
+  UNW_VE_S48  = 48,
+  UNW_VE_S49  = 49,
+  UNW_VE_S50  = 50,
+  UNW_VE_S51  = 51,
+  UNW_VE_S52  = 52,
+  UNW_VE_S53  = 53,
+  UNW_VE_S54  = 54,
+  UNW_VE_S55  = 55,
+  UNW_VE_S56  = 56,
+  UNW_VE_S57  = 57,
+  UNW_VE_S58  = 58,
+  UNW_VE_S59  = 59,
+  UNW_VE_S60  = 60,
+  UNW_VE_S61  = 61,
+  UNW_VE_S62  = 62,
+  UNW_VE_S63  = 63,
+  UNW_VE_V0   = 64 + 0,
+  UNW_VE_V1   = 64 + 1,
+  UNW_VE_V2   = 64 + 2,
+  UNW_VE_V3   = 64 + 3,
+  UNW_VE_V4   = 64 + 4,
+  UNW_VE_V5   = 64 + 5,
+  UNW_VE_V6   = 64 + 6,
+  UNW_VE_V7   = 64 + 7,
+  UNW_VE_V8   = 64 + 8,
+  UNW_VE_V9   = 64 + 9,
+  UNW_VE_V10  = 64 + 10,
+  UNW_VE_V11  = 64 + 11,
+  UNW_VE_V12  = 64 + 12,
+  UNW_VE_V13  = 64 + 13,
+  UNW_VE_V14  = 64 + 14,
+  UNW_VE_V15  = 64 + 15,
+  UNW_VE_V16  = 64 + 16,
+  UNW_VE_V17  = 64 + 17,
+  UNW_VE_V18  = 64 + 18,
+  UNW_VE_V19  = 64 + 19,
+  UNW_VE_V20  = 64 + 20,
+  UNW_VE_V21  = 64 + 21,
+  UNW_VE_V22  = 64 + 22,
+  UNW_VE_V23  = 64 + 23,
+  UNW_VE_V24  = 64 + 24,
+  UNW_VE_V25  = 64 + 25,
+  UNW_VE_V26  = 64 + 26,
+  UNW_VE_V27  = 64 + 27,
+  UNW_VE_V28  = 64 + 28,
+  UNW_VE_V29  = 64 + 29,
+  UNW_VE_V30  = 64 + 30,
+  UNW_VE_V31  = 64 + 31,
+  UNW_VE_V32  = 64 + 32,
+  UNW_VE_V33  = 64 + 33,
+  UNW_VE_V34  = 64 + 34,
+  UNW_VE_V35  = 64 + 35,
+  UNW_VE_V36  = 64 + 36,
+  UNW_VE_V37  = 64 + 37,
+  UNW_VE_V38  = 64 + 38,
+  UNW_VE_V39  = 64 + 39,
+  UNW_VE_V40  = 64 + 40,
+  UNW_VE_V41  = 64 + 41,
+  UNW_VE_V42  = 64 + 42,
+  UNW_VE_V43  = 64 + 43,
+  UNW_VE_V44  = 64 + 44,
+  UNW_VE_V45  = 64 + 45,
+  UNW_VE_V46  = 64 + 46,
+  UNW_VE_V47  = 64 + 47,
+  UNW_VE_V48  = 64 + 48,
+  UNW_VE_V49  = 64 + 49,
+  UNW_VE_V50  = 64 + 50,
+  UNW_VE_V51  = 64 + 51,
+  UNW_VE_V52  = 64 + 52,
+  UNW_VE_V53  = 64 + 53,
+  UNW_VE_V54  = 64 + 54,
+  UNW_VE_V55  = 64 + 55,
+  UNW_VE_V56  = 64 + 56,
+  UNW_VE_V57  = 64 + 57,
+  UNW_VE_V58  = 64 + 58,
+  UNW_VE_V59  = 64 + 59,
+  UNW_VE_V60  = 64 + 60,
+  UNW_VE_V61  = 64 + 61,
+  UNW_VE_V62  = 64 + 62,
+  UNW_VE_V63  = 64 + 63,
+  UNW_VE_VM0  = 128 + 0,
+  UNW_VE_VM1  = 128 + 1,
+  UNW_VE_VM2  = 128 + 2,
+  UNW_VE_VM3  = 128 + 3,
+  UNW_VE_VM4  = 128 + 4,
+  UNW_VE_VM5  = 128 + 5,
+  UNW_VE_VM6  = 128 + 6,
+  UNW_VE_VM7  = 128 + 7,
+  UNW_VE_VM8  = 128 + 8,
+  UNW_VE_VM9  = 128 + 9,
+  UNW_VE_VM10 = 128 + 10,
+  UNW_VE_VM11 = 128 + 11,
+  UNW_VE_VM12 = 128 + 12,
+  UNW_VE_VM13 = 128 + 13,
+  UNW_VE_VM14 = 128 + 14,
+  UNW_VE_VM15 = 128 + 15, // = 143
+
+  // Following registers don't have DWARF register numbers.
+  UNW_VE_VIXR = 144,
+  UNW_VE_VL   = 145,
+};
+
 #endif
diff --git a/WAVM/ThirdParty/libunwind/include/mach-o/compact_unwind_encoding.h b/WAVM/ThirdParty/libunwind/include/mach-o/compact_unwind_encoding.h
index de14fd51..68d562ee 100644
--- a/WAVM/ThirdParty/libunwind/include/mach-o/compact_unwind_encoding.h
+++ b/WAVM/ThirdParty/libunwind/include/mach-o/compact_unwind_encoding.h
@@ -1,9 +1,8 @@
-//===------------------ mach-o/compact_unwind_encoding.h ------------------===//
-//
-//                     The LLVM Compiler Infrastructure
+//===----------------------------------------------------------------------===//
 //
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //
 // Darwin's alternative to DWARF based unwind encodings.
diff --git a/WAVM/ThirdParty/libunwind/include/unwind.h b/WAVM/ThirdParty/libunwind/include/unwind.h
index 0ab87dd6..b8d6020a 100644
--- a/WAVM/ThirdParty/libunwind/include/unwind.h
+++ b/WAVM/ThirdParty/libunwind/include/unwind.h
@@ -1,13 +1,12 @@
-//===------------------------------- unwind.h -----------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
+//===----------------------------------------------------------------------===//
 //
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //
 // C++ ABI Level 1 ABI documented at:
-//   http://mentorembedded.github.io/cxx-abi/abi-eh.html
+//   https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html
 //
 //===----------------------------------------------------------------------===//
 
@@ -19,6 +18,11 @@
 #include <stdint.h>
 #include <stddef.h>
 
+#if defined(__SEH__) && !defined(__USING_SJLJ_EXCEPTIONS__) && defined(_WIN32)
+#include <windows.h>
+#include <ntverp.h>
+#endif
+
 #if defined(__APPLE__)
 #define LIBUNWIND_UNAVAIL __attribute__ (( unavailable ))
 #else
@@ -52,211 +56,23 @@ typedef enum {
 typedef struct _Unwind_Context _Unwind_Context;   // opaque
 
 #if defined(_LIBUNWIND_ARM_EHABI)
-typedef uint32_t _Unwind_State;
-
-static const _Unwind_State _US_VIRTUAL_UNWIND_FRAME   = 0;
-static const _Unwind_State _US_UNWIND_FRAME_STARTING  = 1;
-static const _Unwind_State _US_UNWIND_FRAME_RESUME    = 2;
-static const _Unwind_State _US_ACTION_MASK            = 3;
-/* Undocumented flag for force unwinding. */
-static const _Unwind_State _US_FORCE_UNWIND           = 8;
-
-typedef uint32_t _Unwind_EHT_Header;
-
-struct _Unwind_Control_Block;
-typedef struct _Unwind_Control_Block _Unwind_Control_Block;
-typedef struct _Unwind_Control_Block _Unwind_Exception; /* Alias */
-
-struct _Unwind_Control_Block {
-  uint64_t exception_class;
-  void (*exception_cleanup)(_Unwind_Reason_Code, _Unwind_Control_Block*);
-
-  /* Unwinder cache, private fields for the unwinder's use */
-  struct {
-    uint32_t reserved1; /* init reserved1 to 0, then don't touch */
-    uint32_t reserved2;
-    uint32_t reserved3;
-    uint32_t reserved4;
-    uint32_t reserved5;
-  } unwinder_cache;
-
-  /* Propagation barrier cache (valid after phase 1): */
-  struct {
-    uint32_t sp;
-    uint32_t bitpattern[5];
-  } barrier_cache;
-
-  /* Cleanup cache (preserved over cleanup): */
-  struct {
-    uint32_t bitpattern[4];
-  } cleanup_cache;
-
-  /* Pr cache (for pr's benefit): */
-  struct {
-    uint32_t fnstart; /* function start address */
-    _Unwind_EHT_Header* ehtp; /* pointer to EHT entry header word */
-    uint32_t additional;
-    uint32_t reserved1;
-  } pr_cache;
-
-  long long int :0; /* Enforce the 8-byte alignment */
-} __attribute__((__aligned__(8)));
-
-typedef _Unwind_Reason_Code (*_Unwind_Stop_Fn)
-      (_Unwind_State state,
-       _Unwind_Exception* exceptionObject,
-       struct _Unwind_Context* context);
-
-typedef _Unwind_Reason_Code (*__personality_routine)
-      (_Unwind_State state,
-       _Unwind_Exception* exceptionObject,
-       struct _Unwind_Context* context);
+#include "unwind_arm_ehabi.h"
 #else
-struct _Unwind_Context;   // opaque
-struct _Unwind_Exception; // forward declaration
-typedef struct _Unwind_Exception _Unwind_Exception;
-
-struct _Unwind_Exception {
-  uint64_t exception_class;
-  void (*exception_cleanup)(_Unwind_Reason_Code reason,
-                            _Unwind_Exception *exc);
-  uintptr_t private_1; // non-zero means forced unwind
-  uintptr_t private_2; // holds sp that phase1 found for phase2 to use
-#if __SIZEOF_POINTER__ == 4
-  // The implementation of _Unwind_Exception uses an attribute mode on the
-  // above fields which has the side effect of causing this whole struct to
-  // round up to 32 bytes in size. To be more explicit, we add pad fields
-  // added for binary compatibility.
-  uint32_t reserved[3];
+#include "unwind_itanium.h"
 #endif
-  // The Itanium ABI requires that _Unwind_Exception objects are "double-word
-  // aligned".  GCC has interpreted this to mean "use the maximum useful
-  // alignment for the target"; so do we.
-} __attribute__((__aligned__));
 
 typedef _Unwind_Reason_Code (*_Unwind_Stop_Fn)
     (int version,
      _Unwind_Action actions,
-     uint64_t exceptionClass,
+     _Unwind_Exception_Class exceptionClass,
      _Unwind_Exception* exceptionObject,
      struct _Unwind_Context* context,
-     void* stop_parameter );
-
-typedef _Unwind_Reason_Code (*__personality_routine)
-      (int version,
-       _Unwind_Action actions,
-       uint64_t exceptionClass,
-       _Unwind_Exception* exceptionObject,
-       struct _Unwind_Context* context);
-#endif
+     void* stop_parameter);
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-//
-// The following are the base functions documented by the C++ ABI
-//
-#ifdef __USING_SJLJ_EXCEPTIONS__
-extern _Unwind_Reason_Code
-    _Unwind_SjLj_RaiseException(_Unwind_Exception *exception_object);
-extern void _Unwind_SjLj_Resume(_Unwind_Exception *exception_object);
-#else
-extern _Unwind_Reason_Code
-    _Unwind_RaiseException(_Unwind_Exception *exception_object);
-extern void _Unwind_Resume(_Unwind_Exception *exception_object);
-#endif
-extern void _Unwind_DeleteException(_Unwind_Exception *exception_object);
-
-#if defined(_LIBUNWIND_ARM_EHABI)
-typedef enum {
-  _UVRSC_CORE = 0, /* integer register */
-  _UVRSC_VFP = 1, /* vfp */
-  _UVRSC_WMMXD = 3, /* Intel WMMX data register */
-  _UVRSC_WMMXC = 4 /* Intel WMMX control register */
-} _Unwind_VRS_RegClass;
-
-typedef enum {
-  _UVRSD_UINT32 = 0,
-  _UVRSD_VFPX = 1,
-  _UVRSD_UINT64 = 3,
-  _UVRSD_FLOAT = 4,
-  _UVRSD_DOUBLE = 5
-} _Unwind_VRS_DataRepresentation;
-
-typedef enum {
-  _UVRSR_OK = 0,
-  _UVRSR_NOT_IMPLEMENTED = 1,
-  _UVRSR_FAILED = 2
-} _Unwind_VRS_Result;
-
-extern void _Unwind_Complete(_Unwind_Exception* exception_object);
-
-extern _Unwind_VRS_Result
-_Unwind_VRS_Get(_Unwind_Context *context, _Unwind_VRS_RegClass regclass,
-                uint32_t regno, _Unwind_VRS_DataRepresentation representation,
-                void *valuep);
-
-extern _Unwind_VRS_Result
-_Unwind_VRS_Set(_Unwind_Context *context, _Unwind_VRS_RegClass regclass,
-                uint32_t regno, _Unwind_VRS_DataRepresentation representation,
-                void *valuep);
-
-extern _Unwind_VRS_Result
-_Unwind_VRS_Pop(_Unwind_Context *context, _Unwind_VRS_RegClass regclass,
-                uint32_t discriminator,
-                _Unwind_VRS_DataRepresentation representation);
-#endif
-
-#if !defined(_LIBUNWIND_ARM_EHABI)
-
-extern uintptr_t _Unwind_GetGR(struct _Unwind_Context *context, int index);
-extern void _Unwind_SetGR(struct _Unwind_Context *context, int index,
-                          uintptr_t new_value);
-extern uintptr_t _Unwind_GetIP(struct _Unwind_Context *context);
-extern void _Unwind_SetIP(struct _Unwind_Context *, uintptr_t new_value);
-
-#else  // defined(_LIBUNWIND_ARM_EHABI)
-
-#if defined(_LIBUNWIND_UNWIND_LEVEL1_EXTERNAL_LINKAGE)
-#define _LIBUNWIND_EXPORT_UNWIND_LEVEL1 extern
-#else
-#define _LIBUNWIND_EXPORT_UNWIND_LEVEL1 static __inline__
-#endif
-
-// These are de facto helper functions for ARM, which delegate the function
-// calls to _Unwind_VRS_Get/Set().  These are not a part of ARM EHABI
-// specification, thus these function MUST be inlined.  Please don't replace
-// these with the "extern" function declaration; otherwise, the program
-// including this <unwind.h> header won't be ABI compatible and will result in
-// link error when we are linking the program with libgcc.
-
-_LIBUNWIND_EXPORT_UNWIND_LEVEL1
-uintptr_t _Unwind_GetGR(struct _Unwind_Context *context, int index) {
-  uintptr_t value = 0;
-  _Unwind_VRS_Get(context, _UVRSC_CORE, (uint32_t)index, _UVRSD_UINT32, &value);
-  return value;
-}
-
-_LIBUNWIND_EXPORT_UNWIND_LEVEL1
-void _Unwind_SetGR(struct _Unwind_Context *context, int index,
-                   uintptr_t value) {
-  _Unwind_VRS_Set(context, _UVRSC_CORE, (uint32_t)index, _UVRSD_UINT32, &value);
-}
-
-_LIBUNWIND_EXPORT_UNWIND_LEVEL1
-uintptr_t _Unwind_GetIP(struct _Unwind_Context *context) {
-  // remove the thumb-bit before returning
-  return _Unwind_GetGR(context, 15) & (~(uintptr_t)0x1);
-}
-
-_LIBUNWIND_EXPORT_UNWIND_LEVEL1
-void _Unwind_SetIP(struct _Unwind_Context *context, uintptr_t value) {
-  uintptr_t thumb_bit = _Unwind_GetGR(context, 15) & ((uintptr_t)0x1);
-  _Unwind_SetGR(context, 15, value | thumb_bit);
-}
-#endif  // defined(_LIBUNWIND_ARM_EHABI)
-
 extern uintptr_t _Unwind_GetRegionStart(struct _Unwind_Context *context);
 extern uintptr_t
     _Unwind_GetLanguageSpecificData(struct _Unwind_Context *context);
@@ -369,6 +185,21 @@ extern void *__deregister_frame_info(const void *fde)
 extern void *__deregister_frame_info_bases(const void *fde)
     LIBUNWIND_UNAVAIL;
 
+#if defined(__SEH__) && !defined(__USING_SJLJ_EXCEPTIONS__)
+#ifndef _WIN32
+typedef struct _EXCEPTION_RECORD EXCEPTION_RECORD;
+typedef struct _CONTEXT CONTEXT;
+typedef struct _DISPATCHER_CONTEXT DISPATCHER_CONTEXT;
+#elif !defined(__MINGW32__) && VER_PRODUCTBUILD < 8000
+typedef struct _DISPATCHER_CONTEXT DISPATCHER_CONTEXT;
+#endif
+// This is the common wrapper for GCC-style personality functions with SEH.
+extern EXCEPTION_DISPOSITION _GCC_specific_handler(EXCEPTION_RECORD *exc,
+                                                   void *frame, CONTEXT *ctx,
+                                                   DISPATCHER_CONTEXT *disp,
+                                                   _Unwind_Personality_Fn pers);
+#endif
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/WAVM/ThirdParty/libunwind/include/unwind_arm_ehabi.h b/WAVM/ThirdParty/libunwind/include/unwind_arm_ehabi.h
new file mode 100644
index 00000000..6277a145
--- /dev/null
+++ b/WAVM/ThirdParty/libunwind/include/unwind_arm_ehabi.h
@@ -0,0 +1,170 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//
+// C++ ABI Level 1 ABI documented at:
+//   https://github.com/ARM-software/abi-aa/blob/main/ehabi32/ehabi32.rst
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef __ARM_EHABI_UNWIND_H__
+#define __ARM_EHABI_UNWIND_H__
+
+typedef uint32_t _Unwind_State;
+
+static const _Unwind_State _US_VIRTUAL_UNWIND_FRAME   = 0;
+static const _Unwind_State _US_UNWIND_FRAME_STARTING  = 1;
+static const _Unwind_State _US_UNWIND_FRAME_RESUME    = 2;
+static const _Unwind_State _US_ACTION_MASK            = 3;
+/* Undocumented flag for force unwinding. */
+static const _Unwind_State _US_FORCE_UNWIND           = 8;
+
+typedef uint32_t _Unwind_EHT_Header;
+
+struct _Unwind_Control_Block;
+typedef struct _Unwind_Control_Block _Unwind_Control_Block;
+#define _Unwind_Exception _Unwind_Control_Block /* Alias */
+typedef uint8_t _Unwind_Exception_Class[8];
+
+struct _Unwind_Control_Block {
+  _Unwind_Exception_Class exception_class;
+  void (*exception_cleanup)(_Unwind_Reason_Code, _Unwind_Control_Block*);
+
+  /* Unwinder cache, private fields for the unwinder's use */
+  struct {
+    uint32_t reserved1; /* init reserved1 to 0, then don't touch */
+    uint32_t reserved2;
+    uint32_t reserved3;
+    uint32_t reserved4;
+    uint32_t reserved5;
+  } unwinder_cache;
+
+  /* Propagation barrier cache (valid after phase 1): */
+  struct {
+    uint32_t sp;
+    uint32_t bitpattern[5];
+  } barrier_cache;
+
+  /* Cleanup cache (preserved over cleanup): */
+  struct {
+    uint32_t bitpattern[4];
+  } cleanup_cache;
+
+  /* Pr cache (for pr's benefit): */
+  struct {
+    uint32_t fnstart; /* function start address */
+    _Unwind_EHT_Header* ehtp; /* pointer to EHT entry header word */
+    uint32_t additional;
+    uint32_t reserved1;
+  } pr_cache;
+
+  long long int :0; /* Enforce the 8-byte alignment */
+} __attribute__((__aligned__(8)));
+
+typedef _Unwind_Reason_Code (*_Unwind_Personality_Fn)(
+    _Unwind_State state, _Unwind_Exception *exceptionObject,
+    struct _Unwind_Context *context);
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+//
+// The following are the base functions documented by the C++ ABI
+//
+#ifdef __USING_SJLJ_EXCEPTIONS__
+extern _Unwind_Reason_Code
+    _Unwind_SjLj_RaiseException(_Unwind_Exception *exception_object);
+extern void _Unwind_SjLj_Resume(_Unwind_Exception *exception_object);
+#else
+extern _Unwind_Reason_Code
+    _Unwind_RaiseException(_Unwind_Exception *exception_object);
+extern void _Unwind_Resume(_Unwind_Exception *exception_object);
+#endif
+extern void _Unwind_DeleteException(_Unwind_Exception *exception_object);
+
+typedef enum {
+  _UVRSC_CORE = 0,  /* integer register */
+  _UVRSC_VFP = 1,   /* vfp */
+  _UVRSC_WMMXD = 3, /* Intel WMMX data register */
+  _UVRSC_WMMXC = 4, /* Intel WMMX control register */
+  _UVRSC_PSEUDO = 5 /* Special purpose pseudo register */
+} _Unwind_VRS_RegClass;
+
+typedef enum {
+  _UVRSD_UINT32 = 0,
+  _UVRSD_VFPX = 1,
+  _UVRSD_UINT64 = 3,
+  _UVRSD_FLOAT = 4,
+  _UVRSD_DOUBLE = 5
+} _Unwind_VRS_DataRepresentation;
+
+typedef enum {
+  _UVRSR_OK = 0,
+  _UVRSR_NOT_IMPLEMENTED = 1,
+  _UVRSR_FAILED = 2
+} _Unwind_VRS_Result;
+
+extern void _Unwind_Complete(_Unwind_Exception* exception_object);
+
+extern _Unwind_VRS_Result
+_Unwind_VRS_Get(_Unwind_Context *context, _Unwind_VRS_RegClass regclass,
+                uint32_t regno, _Unwind_VRS_DataRepresentation representation,
+                void *valuep);
+
+extern _Unwind_VRS_Result
+_Unwind_VRS_Set(_Unwind_Context *context, _Unwind_VRS_RegClass regclass,
+                uint32_t regno, _Unwind_VRS_DataRepresentation representation,
+                void *valuep);
+
+extern _Unwind_VRS_Result
+_Unwind_VRS_Pop(_Unwind_Context *context, _Unwind_VRS_RegClass regclass,
+                uint32_t discriminator,
+                _Unwind_VRS_DataRepresentation representation);
+
+#if defined(_LIBUNWIND_UNWIND_LEVEL1_EXTERNAL_LINKAGE)
+#define _LIBUNWIND_EXPORT_UNWIND_LEVEL1 extern
+#else
+#define _LIBUNWIND_EXPORT_UNWIND_LEVEL1 static __inline__
+#endif
+
+// These are de facto helper functions for ARM, which delegate the function
+// calls to _Unwind_VRS_Get/Set().  These are not a part of ARM EHABI
+// specification, thus these function MUST be inlined.  Please don't replace
+// these with the "extern" function declaration; otherwise, the program
+// including this <unwind.h> header won't be ABI compatible and will result in
+// link error when we are linking the program with libgcc.
+
+_LIBUNWIND_EXPORT_UNWIND_LEVEL1
+uintptr_t _Unwind_GetGR(struct _Unwind_Context *context, int index) {
+  uintptr_t value = 0;
+  _Unwind_VRS_Get(context, _UVRSC_CORE, (uint32_t)index, _UVRSD_UINT32, &value);
+  return value;
+}
+
+_LIBUNWIND_EXPORT_UNWIND_LEVEL1
+void _Unwind_SetGR(struct _Unwind_Context *context, int index,
+                   uintptr_t value) {
+  _Unwind_VRS_Set(context, _UVRSC_CORE, (uint32_t)index, _UVRSD_UINT32, &value);
+}
+
+_LIBUNWIND_EXPORT_UNWIND_LEVEL1
+uintptr_t _Unwind_GetIP(struct _Unwind_Context *context) {
+  // remove the thumb-bit before returning
+  return _Unwind_GetGR(context, 15) & (~(uintptr_t)0x1);
+}
+
+_LIBUNWIND_EXPORT_UNWIND_LEVEL1
+void _Unwind_SetIP(struct _Unwind_Context *context, uintptr_t value) {
+  uintptr_t thumb_bit = _Unwind_GetGR(context, 15) & ((uintptr_t)0x1);
+  _Unwind_SetGR(context, 15, value | thumb_bit);
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __ARM_EHABI_UNWIND_H__
diff --git a/WAVM/ThirdParty/libunwind/include/unwind_itanium.h b/WAVM/ThirdParty/libunwind/include/unwind_itanium.h
new file mode 100644
index 00000000..d94a6183
--- /dev/null
+++ b/WAVM/ThirdParty/libunwind/include/unwind_itanium.h
@@ -0,0 +1,76 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//
+// C++ ABI Level 1 ABI documented at:
+//   https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef __ITANIUM_UNWIND_H__
+#define __ITANIUM_UNWIND_H__
+
+struct _Unwind_Context;   // opaque
+struct _Unwind_Exception; // forward declaration
+typedef struct _Unwind_Exception _Unwind_Exception;
+typedef uint64_t _Unwind_Exception_Class;
+
+struct _Unwind_Exception {
+  _Unwind_Exception_Class exception_class;
+  void (*exception_cleanup)(_Unwind_Reason_Code reason,
+                            _Unwind_Exception *exc);
+#if defined(__SEH__) && !defined(__USING_SJLJ_EXCEPTIONS__)
+  uintptr_t private_[6];
+#else
+  uintptr_t private_1; // non-zero means forced unwind
+  uintptr_t private_2; // holds sp that phase1 found for phase2 to use
+#endif
+#if __SIZEOF_POINTER__ == 4
+  // The implementation of _Unwind_Exception uses an attribute mode on the
+  // above fields which has the side effect of causing this whole struct to
+  // round up to 32 bytes in size (48 with SEH). To be more explicit, we add
+  // pad fields added for binary compatibility.
+  uint32_t reserved[3];
+#endif
+  // The Itanium ABI requires that _Unwind_Exception objects are "double-word
+  // aligned".  GCC has interpreted this to mean "use the maximum useful
+  // alignment for the target"; so do we.
+} __attribute__((__aligned__));
+
+typedef _Unwind_Reason_Code (*_Unwind_Personality_Fn)(
+    int version, _Unwind_Action actions, uint64_t exceptionClass,
+    _Unwind_Exception *exceptionObject, struct _Unwind_Context *context);
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+//
+// The following are the base functions documented by the C++ ABI
+//
+#ifdef __USING_SJLJ_EXCEPTIONS__
+extern _Unwind_Reason_Code
+    _Unwind_SjLj_RaiseException(_Unwind_Exception *exception_object);
+extern void _Unwind_SjLj_Resume(_Unwind_Exception *exception_object);
+#else
+extern _Unwind_Reason_Code
+    _Unwind_RaiseException(_Unwind_Exception *exception_object);
+extern void _Unwind_Resume(_Unwind_Exception *exception_object);
+#endif
+extern void _Unwind_DeleteException(_Unwind_Exception *exception_object);
+
+
+extern uintptr_t _Unwind_GetGR(struct _Unwind_Context *context, int index);
+extern void _Unwind_SetGR(struct _Unwind_Context *context, int index,
+                          uintptr_t new_value);
+extern uintptr_t _Unwind_GetIP(struct _Unwind_Context *context);
+extern void _Unwind_SetIP(struct _Unwind_Context *, uintptr_t new_value);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __ITANIUM_UNWIND_H__
diff --git a/WAVM/ThirdParty/libunwind/src/AddressSpace.hpp b/WAVM/ThirdParty/libunwind/src/AddressSpace.hpp
index 32ff1f3d..0c4dfeb4 100644
--- a/WAVM/ThirdParty/libunwind/src/AddressSpace.hpp
+++ b/WAVM/ThirdParty/libunwind/src/AddressSpace.hpp
@@ -1,9 +1,8 @@
-//===------------------------- AddressSpace.hpp ---------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
+//===----------------------------------------------------------------------===//
 //
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //
 // Abstracts accessing local vs remote address spaces.
@@ -18,23 +17,34 @@
 #include <stdlib.h>
 #include <string.h>
 
-#if !defined(_LIBUNWIND_IS_BAREMETAL) && !defined(_WIN32)
-#include <dlfcn.h>
-#endif
-
-#ifdef __APPLE__
-#include <mach-o/getsect.h>
-namespace libunwind {
-   bool checkKeyMgrRegisteredFDEs(uintptr_t targetAddr, void *&fde);
-}
-#endif
-
 #include "libunwind.h"
 #include "config.h"
 #include "dwarf2.h"
 #include "EHHeaderParser.hpp"
 #include "Registers.hpp"
 
+#ifndef _LIBUNWIND_USE_DLADDR
+  #if !defined(_LIBUNWIND_IS_BAREMETAL) && !defined(_WIN32)
+    #define _LIBUNWIND_USE_DLADDR 1
+  #else
+    #define _LIBUNWIND_USE_DLADDR 0
+  #endif
+#endif
+
+#if _LIBUNWIND_USE_DLADDR
+#include <dlfcn.h>
+#if defined(__ELF__) && defined(_LIBUNWIND_LINK_DL_LIB)
+#pragma comment(lib, "dl")
+#endif
+#endif
+
+#if defined(_LIBUNWIND_ARM_EHABI)
+struct EHABIIndexEntry {
+  uint32_t functionOffset;
+  uint32_t data;
+};
+#endif
+
 #ifdef __APPLE__
 
   struct dyld_unwind_sections
@@ -45,43 +55,9 @@ namespace libunwind {
     const void*                 compact_unwind_section;
     uintptr_t                   compact_unwind_section_length;
   };
-  #if (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) \
-                                 && (__MAC_OS_X_VERSION_MIN_REQUIRED >= 1070)) \
-      || defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
-    // In 10.7.0 or later, libSystem.dylib implements this function.
-    extern "C" bool _dyld_find_unwind_sections(void *, dyld_unwind_sections *);
-  #else
-    // In 10.6.x and earlier, we need to implement this functionality. Note
-    // that this requires a newer version of libmacho (from cctools) than is
-    // present in libSystem on 10.6.x (for getsectiondata).
-    static inline bool _dyld_find_unwind_sections(void* addr,
-                                                    dyld_unwind_sections* info) {
-      // Find mach-o image containing address.
-      Dl_info dlinfo;
-      if (!dladdr(addr, &dlinfo))
-        return false;
-#if __LP64__
-      const struct mach_header_64 *mh = (const struct mach_header_64 *)dlinfo.dli_fbase;
-#else
-      const struct mach_header *mh = (const struct mach_header *)dlinfo.dli_fbase;
-#endif
-
-      // Initialize the return struct
-      info->mh = (const struct mach_header *)mh;
-      info->dwarf_section = getsectiondata(mh, "__TEXT", "__eh_frame", &info->dwarf_section_length);
-      info->compact_unwind_section = getsectiondata(mh, "__TEXT", "__unwind_info", &info->compact_unwind_section_length);
-
-      if (!info->dwarf_section) {
-        info->dwarf_section_length = 0;
-      }
-
-      if (!info->compact_unwind_section) {
-        info->compact_unwind_section_length = 0;
-      }
 
-      return true;
-    }
-  #endif
+  // In 10.7.0 or later, libSystem.dylib implements this function.
+  extern "C" bool _dyld_find_unwind_sections(void *, dyld_unwind_sections *);
 
 #elif defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND) && defined(_LIBUNWIND_IS_BAREMETAL)
 
@@ -122,22 +98,15 @@ extern char __eh_frame_hdr_end;
 extern char __exidx_start;
 extern char __exidx_end;
 
-#elif defined(_LIBUNWIND_ARM_EHABI) || defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND)
+#elif defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND) && defined(_WIN32)
 
-// ELF-based systems may use dl_iterate_phdr() to access sections
-// containing unwinding information. The ElfW() macro for pointer-size
-// independent ELF header traversal is not provided by <link.h> on some
-// systems (e.g., FreeBSD). On these systems the data structures are
-// just called Elf_XXX. Define ElfW() locally.
-#ifndef _WIN32
-#include <link.h>
-#else
 #include <windows.h>
 #include <psapi.h>
-#endif
-#if !defined(ElfW)
-#define ElfW(type) Elf_##type
-#endif
+
+#elif defined(_LIBUNWIND_USE_DL_ITERATE_PHDR) ||                               \
+      defined(_LIBUNWIND_USE_DL_UNWIND_FIND_EXIDX)
+
+#include <link.h>
 
 #endif
 
@@ -145,26 +114,30 @@ namespace libunwind {
 
 /// Used by findUnwindSections() to return info about needed sections.
 struct UnwindInfoSections {
-#if defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND) || defined(_LIBUNWIND_SUPPORT_DWARF_INDEX) ||       \
-    defined(_LIBUNWIND_SUPPORT_COMPACT_UNWIND)
-  // No dso_base for ARM EHABI.
+#if defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND) ||                                \
+    defined(_LIBUNWIND_SUPPORT_COMPACT_UNWIND) ||                              \
+    defined(_LIBUNWIND_USE_DL_ITERATE_PHDR)
+  // No dso_base for SEH.
   uintptr_t       dso_base;
 #endif
+#if defined(_LIBUNWIND_USE_DL_ITERATE_PHDR)
+  size_t          text_segment_length;
+#endif
 #if defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND)
   uintptr_t       dwarf_section;
-  uintptr_t       dwarf_section_length;
+  size_t          dwarf_section_length;
 #endif
 #if defined(_LIBUNWIND_SUPPORT_DWARF_INDEX)
   uintptr_t       dwarf_index_section;
-  uintptr_t       dwarf_index_section_length;
+  size_t          dwarf_index_section_length;
 #endif
 #if defined(_LIBUNWIND_SUPPORT_COMPACT_UNWIND)
   uintptr_t       compact_unwind_section;
-  uintptr_t       compact_unwind_section_length;
+  size_t          compact_unwind_section_length;
 #endif
 #if defined(_LIBUNWIND_ARM_EHABI)
   uintptr_t       arm_section;
-  uintptr_t       arm_section_length;
+  size_t          arm_section_length;
 #endif
 };
 
@@ -172,7 +145,7 @@ struct UnwindInfoSections {
 /// LocalAddressSpace is used as a template parameter to UnwindCursor when
 /// unwinding a thread in the same process.  The wrappers compile away,
 /// making local unwinds fast.
-class __attribute__((visibility("hidden"))) LocalAddressSpace {
+class _LIBUNWIND_HIDDEN LocalAddressSpace {
 public:
   typedef uintptr_t pint_t;
   typedef intptr_t  sint_t;
@@ -273,11 +246,11 @@ inline int64_t LocalAddressSpace::getSLEB128(pint_t &addr, pint_t end) {
     if (p == pend)
       _LIBUNWIND_ABORT("truncated sleb128 expression");
     byte = *p++;
-    result |= ((byte & 0x7f) << bit);
+    result |= (uint64_t)(byte & 0x7f) << bit;
     bit += 7;
   } while (byte & 0x80);
   // sign extend negative numbers
-  if ((byte & 0x40) != 0)
+  if ((byte & 0x40) != 0 && bit < 64)
     result |= (-1ULL) << bit;
   addr = (pint_t) p;
   return result;
@@ -375,6 +348,156 @@ LocalAddressSpace::getEncodedP(pint_t &addr, pint_t end, uint8_t encoding,
   return result;
 }
 
+#if defined(_LIBUNWIND_USE_DL_ITERATE_PHDR)
+
+// The ElfW() macro for pointer-size independent ELF header traversal is not
+// provided by <link.h> on some systems (e.g., FreeBSD). On these systems the
+// data structures are just called Elf_XXX. Define ElfW() locally.
+#if !defined(ElfW)
+  #define ElfW(type) Elf_##type
+#endif
+#if !defined(Elf_Half)
+  typedef ElfW(Half) Elf_Half;
+#endif
+#if !defined(Elf_Phdr)
+  typedef ElfW(Phdr) Elf_Phdr;
+#endif
+#if !defined(Elf_Addr)
+  typedef ElfW(Addr) Elf_Addr;
+#endif
+
+static Elf_Addr calculateImageBase(struct dl_phdr_info *pinfo) {
+  Elf_Addr image_base = pinfo->dlpi_addr;
+#if defined(__ANDROID__) && __ANDROID_API__ < 18
+  if (image_base == 0) {
+    // Normally, an image base of 0 indicates a non-PIE executable. On
+    // versions of Android prior to API 18, the dynamic linker reported a
+    // dlpi_addr of 0 for PIE executables. Compute the true image base
+    // using the PT_PHDR segment.
+    // See https://github.com/android/ndk/issues/505.
+    for (Elf_Half i = 0; i < pinfo->dlpi_phnum; i++) {
+      const Elf_Phdr *phdr = &pinfo->dlpi_phdr[i];
+      if (phdr->p_type == PT_PHDR) {
+        image_base = reinterpret_cast<Elf_Addr>(pinfo->dlpi_phdr) -
+          phdr->p_vaddr;
+        break;
+      }
+    }
+  }
+#endif
+  return image_base;
+}
+
+struct _LIBUNWIND_HIDDEN dl_iterate_cb_data {
+  LocalAddressSpace *addressSpace;
+  UnwindInfoSections *sects;
+  uintptr_t targetAddr;
+};
+
+#if defined(_LIBUNWIND_USE_FRAME_HEADER_CACHE)
+#include "FrameHeaderCache.hpp"
+
+// Typically there is one cache per process, but when libunwind is built as a
+// hermetic static library, then each shared object may have its own cache.
+static FrameHeaderCache TheFrameHeaderCache;
+#endif
+
+static bool checkAddrInSegment(const Elf_Phdr *phdr, size_t image_base,
+                               dl_iterate_cb_data *cbdata) {
+  if (phdr->p_type == PT_LOAD) {
+    uintptr_t begin = image_base + phdr->p_vaddr;
+    uintptr_t end = begin + phdr->p_memsz;
+    if (cbdata->targetAddr >= begin && cbdata->targetAddr < end) {
+      cbdata->sects->dso_base = begin;
+      cbdata->sects->text_segment_length = phdr->p_memsz;
+      return true;
+    }
+  }
+  return false;
+}
+
+static bool checkForUnwindInfoSegment(const Elf_Phdr *phdr, size_t image_base,
+                                      dl_iterate_cb_data *cbdata) {
+#if defined(_LIBUNWIND_SUPPORT_DWARF_INDEX)
+  if (phdr->p_type == PT_GNU_EH_FRAME) {
+    EHHeaderParser<LocalAddressSpace>::EHHeaderInfo hdrInfo;
+    uintptr_t eh_frame_hdr_start = image_base + phdr->p_vaddr;
+    cbdata->sects->dwarf_index_section = eh_frame_hdr_start;
+    cbdata->sects->dwarf_index_section_length = phdr->p_memsz;
+    if (EHHeaderParser<LocalAddressSpace>::decodeEHHdr(
+            *cbdata->addressSpace, eh_frame_hdr_start, phdr->p_memsz,
+            hdrInfo)) {
+      // .eh_frame_hdr records the start of .eh_frame, but not its size.
+      // Rely on a zero terminator to find the end of the section.
+      cbdata->sects->dwarf_section = hdrInfo.eh_frame_ptr;
+      cbdata->sects->dwarf_section_length = SIZE_MAX;
+      return true;
+    }
+  }
+  return false;
+#elif defined(_LIBUNWIND_ARM_EHABI)
+  if (phdr->p_type == PT_ARM_EXIDX) {
+    uintptr_t exidx_start = image_base + phdr->p_vaddr;
+    cbdata->sects->arm_section = exidx_start;
+    cbdata->sects->arm_section_length = phdr->p_memsz;
+    return true;
+  }
+  return false;
+#else
+#error Need one of _LIBUNWIND_SUPPORT_DWARF_INDEX or _LIBUNWIND_ARM_EHABI
+#endif
+}
+
+static int findUnwindSectionsByPhdr(struct dl_phdr_info *pinfo,
+                                    size_t pinfo_size, void *data) {
+  auto cbdata = static_cast<dl_iterate_cb_data *>(data);
+  if (pinfo->dlpi_phnum == 0 || cbdata->targetAddr < pinfo->dlpi_addr)
+    return 0;
+#if defined(_LIBUNWIND_USE_FRAME_HEADER_CACHE)
+  if (TheFrameHeaderCache.find(pinfo, pinfo_size, data))
+    return 1;
+#else
+  // Avoid warning about unused variable.
+  (void)pinfo_size;
+#endif
+
+  Elf_Addr image_base = calculateImageBase(pinfo);
+
+  // Most shared objects seen in this callback function likely don't contain the
+  // target address, so optimize for that. Scan for a matching PT_LOAD segment
+  // first and bail when it isn't found.
+  bool found_text = false;
+  for (Elf_Half i = 0; i < pinfo->dlpi_phnum; ++i) {
+    if (checkAddrInSegment(&pinfo->dlpi_phdr[i], image_base, cbdata)) {
+      found_text = true;
+      break;
+    }
+  }
+  if (!found_text)
+    return 0;
+
+  // PT_GNU_EH_FRAME and PT_ARM_EXIDX are usually near the end. Iterate
+  // backward.
+  bool found_unwind = false;
+  for (Elf_Half i = pinfo->dlpi_phnum; i > 0; i--) {
+    const Elf_Phdr *phdr = &pinfo->dlpi_phdr[i - 1];
+    if (checkForUnwindInfoSegment(phdr, image_base, cbdata)) {
+      found_unwind = true;
+      break;
+    }
+  }
+  if (!found_unwind)
+    return 0;
+
+#if defined(_LIBUNWIND_USE_FRAME_HEADER_CACHE)
+  TheFrameHeaderCache.add(cbdata->sects);
+#endif
+  return 1;
+}
+
+#endif  // defined(_LIBUNWIND_USE_DL_ITERATE_PHDR)
+
+
 inline bool LocalAddressSpace::findUnwindSections(pint_t targetAddr,
                                                   UnwindInfoSections &info) {
 #ifdef __APPLE__
@@ -383,21 +506,22 @@ inline bool LocalAddressSpace::findUnwindSections(pint_t targetAddr,
     info.dso_base                      = (uintptr_t)dyldInfo.mh;
  #if defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND)
     info.dwarf_section                 = (uintptr_t)dyldInfo.dwarf_section;
-    info.dwarf_section_length          = dyldInfo.dwarf_section_length;
+    info.dwarf_section_length          = (size_t)dyldInfo.dwarf_section_length;
  #endif
     info.compact_unwind_section        = (uintptr_t)dyldInfo.compact_unwind_section;
-    info.compact_unwind_section_length = dyldInfo.compact_unwind_section_length;
+    info.compact_unwind_section_length = (size_t)dyldInfo.compact_unwind_section_length;
     return true;
   }
 #elif defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND) && defined(_LIBUNWIND_IS_BAREMETAL)
+  info.dso_base = 0;
   // Bare metal is statically linked, so no need to ask the dynamic loader
-  info.dwarf_section_length = (uintptr_t)(&__eh_frame_end - &__eh_frame_start);
+  info.dwarf_section_length = (size_t)(&__eh_frame_end - &__eh_frame_start);
   info.dwarf_section =        (uintptr_t)(&__eh_frame_start);
   _LIBUNWIND_TRACE_UNWINDING("findUnwindSections: section %p length %p",
                              (void *)info.dwarf_section, (void *)info.dwarf_section_length);
 #if defined(_LIBUNWIND_SUPPORT_DWARF_INDEX)
   info.dwarf_index_section =        (uintptr_t)(&__eh_frame_hdr_start);
-  info.dwarf_index_section_length = (uintptr_t)(&__eh_frame_hdr_end - &__eh_frame_hdr_start);
+  info.dwarf_index_section_length = (size_t)(&__eh_frame_hdr_end - &__eh_frame_hdr_start);
   _LIBUNWIND_TRACE_UNWINDING("findUnwindSections: index section %p length %p",
                              (void *)info.dwarf_index_section, (void *)info.dwarf_index_section_length);
 #endif
@@ -406,7 +530,7 @@ inline bool LocalAddressSpace::findUnwindSections(pint_t targetAddr,
 #elif defined(_LIBUNWIND_ARM_EHABI) && defined(_LIBUNWIND_IS_BAREMETAL)
   // Bare metal is statically linked, so no need to ask the dynamic loader
   info.arm_section =        (uintptr_t)(&__exidx_start);
-  info.arm_section_length = (uintptr_t)(&__exidx_end - &__exidx_start);
+  info.arm_section_length = (size_t)(&__exidx_end - &__exidx_start);
   _LIBUNWIND_TRACE_UNWINDING("findUnwindSections: section %p length %p",
                              (void *)info.arm_section, (void *)info.arm_section_length);
   if (info.arm_section && info.arm_section_length)
@@ -416,8 +540,12 @@ inline bool LocalAddressSpace::findUnwindSections(pint_t targetAddr,
   HANDLE process = GetCurrentProcess();
   DWORD needed;
 
-  if (!EnumProcessModules(process, mods, sizeof(mods), &needed))
+  if (!EnumProcessModules(process, mods, sizeof(mods), &needed)) {
+    DWORD err = GetLastError();
+    _LIBUNWIND_TRACE_UNWINDING("findUnwindSections: EnumProcessModules failed, "
+                               "returned error %d", (int)err);
     return false;
+  }
 
   for (unsigned i = 0; i < (needed / sizeof(HMODULE)); i++) {
     PIMAGE_DOS_HEADER pidh = (PIMAGE_DOS_HEADER)mods[i];
@@ -446,115 +574,22 @@ inline bool LocalAddressSpace::findUnwindSections(pint_t targetAddr,
     }
   }
   return false;
-#elif defined(_LIBUNWIND_ARM_EHABI) && defined(__BIONIC__) &&                  \
-    (__ANDROID_API__ < 21)
+#elif defined(_LIBUNWIND_SUPPORT_SEH_UNWIND) && defined(_WIN32)
+  // Don't even bother, since Windows has functions that do all this stuff
+  // for us.
+  (void)targetAddr;
+  (void)info;
+  return true;
+#elif defined(_LIBUNWIND_USE_DL_UNWIND_FIND_EXIDX)
   int length = 0;
   info.arm_section =
       (uintptr_t)dl_unwind_find_exidx((_Unwind_Ptr)targetAddr, &length);
-  info.arm_section_length = (uintptr_t)length;
+  info.arm_section_length = (size_t)length * sizeof(EHABIIndexEntry);
   if (info.arm_section && info.arm_section_length)
     return true;
-#elif defined(_LIBUNWIND_ARM_EHABI) || defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND)
-  struct dl_iterate_cb_data {
-    LocalAddressSpace *addressSpace;
-    UnwindInfoSections *sects;
-    uintptr_t targetAddr;
-  };
-
+#elif defined(_LIBUNWIND_USE_DL_ITERATE_PHDR)
   dl_iterate_cb_data cb_data = {this, &info, targetAddr};
-  int found = dl_iterate_phdr(
-      [](struct dl_phdr_info *pinfo, size_t, void *data) -> int {
-        auto cbdata = static_cast<dl_iterate_cb_data *>(data);
-        bool found_obj = false;
-        bool found_hdr = false;
-
-        assert(cbdata);
-        assert(cbdata->sects);
-
-        if (cbdata->targetAddr < pinfo->dlpi_addr) {
-          return false;
-        }
-
-#if !defined(Elf_Half)
-        typedef ElfW(Half) Elf_Half;
-#endif
-#if !defined(Elf_Phdr)
-        typedef ElfW(Phdr) Elf_Phdr;
-#endif
-#if !defined(Elf_Addr) && defined(__ANDROID__)
-        typedef ElfW(Addr) Elf_Addr;
-#endif
-
- #if defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND)
-  #if !defined(_LIBUNWIND_SUPPORT_DWARF_INDEX)
-   #error "_LIBUNWIND_SUPPORT_DWARF_UNWIND requires _LIBUNWIND_SUPPORT_DWARF_INDEX on this platform."
-  #endif
-        size_t object_length;
-#if defined(__ANDROID__)
-        Elf_Addr image_base =
-            pinfo->dlpi_phnum
-                ? reinterpret_cast<Elf_Addr>(pinfo->dlpi_phdr) -
-                      reinterpret_cast<const Elf_Phdr *>(pinfo->dlpi_phdr)
-                          ->p_offset
-                : 0;
-#endif
-
-        for (Elf_Half i = 0; i < pinfo->dlpi_phnum; i++) {
-          const Elf_Phdr *phdr = &pinfo->dlpi_phdr[i];
-          if (phdr->p_type == PT_LOAD) {
-            uintptr_t begin = pinfo->dlpi_addr + phdr->p_vaddr;
-#if defined(__ANDROID__)
-            if (pinfo->dlpi_addr == 0 && phdr->p_vaddr < image_base)
-              begin = begin + image_base;
-#endif
-            uintptr_t end = begin + phdr->p_memsz;
-            if (cbdata->targetAddr >= begin && cbdata->targetAddr < end) {
-              cbdata->sects->dso_base = begin;
-              object_length = phdr->p_memsz;
-              found_obj = true;
-            }
-          } else if (phdr->p_type == PT_GNU_EH_FRAME) {
-            EHHeaderParser<LocalAddressSpace>::EHHeaderInfo hdrInfo;
-            uintptr_t eh_frame_hdr_start = pinfo->dlpi_addr + phdr->p_vaddr;
-#if defined(__ANDROID__)
-            if (pinfo->dlpi_addr == 0 && phdr->p_vaddr < image_base)
-              eh_frame_hdr_start = eh_frame_hdr_start + image_base;
-#endif
-            cbdata->sects->dwarf_index_section = eh_frame_hdr_start;
-            cbdata->sects->dwarf_index_section_length = phdr->p_memsz;
-            EHHeaderParser<LocalAddressSpace>::decodeEHHdr(
-                *cbdata->addressSpace, eh_frame_hdr_start, phdr->p_memsz,
-                hdrInfo);
-            cbdata->sects->dwarf_section = hdrInfo.eh_frame_ptr;
-            found_hdr = true;
-          }
-        }
-
-        if (found_obj && found_hdr) {
-          cbdata->sects->dwarf_section_length = object_length;
-          return true;
-        } else {
-          return false;
-        }
- #else // defined(_LIBUNWIND_ARM_EHABI)
-        for (Elf_Half i = 0; i < pinfo->dlpi_phnum; i++) {
-          const Elf_Phdr *phdr = &pinfo->dlpi_phdr[i];
-          if (phdr->p_type == PT_LOAD) {
-            uintptr_t begin = pinfo->dlpi_addr + phdr->p_vaddr;
-            uintptr_t end = begin + phdr->p_memsz;
-            if (cbdata->targetAddr >= begin && cbdata->targetAddr < end)
-              found_obj = true;
-          } else if (phdr->p_type == PT_ARM_EXIDX) {
-            uintptr_t exidx_start = pinfo->dlpi_addr + phdr->p_vaddr;
-            cbdata->sects->arm_section = exidx_start;
-            cbdata->sects->arm_section_length = phdr->p_memsz;
-            found_hdr = true;
-          }
-        }
-        return found_obj && found_hdr;
- #endif
-      },
-      &cb_data);
+  int found = dl_iterate_phdr(findUnwindSectionsByPhdr, &cb_data);
   return static_cast<bool>(found);
 #endif
 
@@ -563,20 +598,16 @@ inline bool LocalAddressSpace::findUnwindSections(pint_t targetAddr,
 
 
 inline bool LocalAddressSpace::findOtherFDE(pint_t targetAddr, pint_t &fde) {
-#ifdef __APPLE__
-  return checkKeyMgrRegisteredFDEs(targetAddr, *((void**)&fde));
-#else
   // TO DO: if OS has way to dynamically register FDEs, check that.
   (void)targetAddr;
   (void)fde;
   return false;
-#endif
 }
 
 inline bool LocalAddressSpace::findFunctionName(pint_t addr, char *buf,
                                                 size_t bufLen,
                                                 unw_word_t *offset) {
-#if !defined(_LIBUNWIND_IS_BAREMETAL) && !defined(_WIN32)
+#if _LIBUNWIND_USE_DLADDR
   Dl_info dyldInfo;
   if (dladdr((void *)addr, &dyldInfo)) {
     if (dyldInfo.dli_sname != NULL) {
@@ -585,142 +616,15 @@ inline bool LocalAddressSpace::findFunctionName(pint_t addr, char *buf,
       return true;
     }
   }
+#else
+  (void)addr;
+  (void)buf;
+  (void)bufLen;
+  (void)offset;
 #endif
   return false;
 }
 
-
-
-#ifdef UNW_REMOTE
-
-/// RemoteAddressSpace is used as a template parameter to UnwindCursor when
-/// unwinding a thread in the another process.  The other process can be a
-/// different endianness and a different pointer size which is handled by
-/// the P template parameter.
-template <typename P>
-class RemoteAddressSpace {
-public:
-  RemoteAddressSpace(task_t task) : fTask(task) {}
-
-  typedef typename P::uint_t pint_t;
-
-  uint8_t   get8(pint_t addr);
-  uint16_t  get16(pint_t addr);
-  uint32_t  get32(pint_t addr);
-  uint64_t  get64(pint_t addr);
-  pint_t    getP(pint_t addr);
-  uint64_t  getRegister(pint_t addr);
-  uint64_t  getULEB128(pint_t &addr, pint_t end);
-  int64_t   getSLEB128(pint_t &addr, pint_t end);
-  pint_t    getEncodedP(pint_t &addr, pint_t end, uint8_t encoding,
-                        pint_t datarelBase = 0);
-  bool      findFunctionName(pint_t addr, char *buf, size_t bufLen,
-                        unw_word_t *offset);
-  bool      findUnwindSections(pint_t targetAddr, UnwindInfoSections &info);
-  bool      findOtherFDE(pint_t targetAddr, pint_t &fde);
-private:
-  void *localCopy(pint_t addr);
-
-  task_t fTask;
-};
-
-template <typename P> uint8_t RemoteAddressSpace<P>::get8(pint_t addr) {
-  return *((uint8_t *)localCopy(addr));
-}
-
-template <typename P> uint16_t RemoteAddressSpace<P>::get16(pint_t addr) {
-  return P::E::get16(*(uint16_t *)localCopy(addr));
-}
-
-template <typename P> uint32_t RemoteAddressSpace<P>::get32(pint_t addr) {
-  return P::E::get32(*(uint32_t *)localCopy(addr));
-}
-
-template <typename P> uint64_t RemoteAddressSpace<P>::get64(pint_t addr) {
-  return P::E::get64(*(uint64_t *)localCopy(addr));
-}
-
-template <typename P>
-typename P::uint_t RemoteAddressSpace<P>::getP(pint_t addr) {
-  return P::getP(*(uint64_t *)localCopy(addr));
-}
-
-template <typename P>
-typename P::uint_t OtherAddressSpace<P>::getRegister(pint_t addr) {
-  return P::getRegister(*(uint64_t *)localCopy(addr));
-}
-
-template <typename P>
-uint64_t OtherAddressSpace<P>::getULEB128(pint_t &addr, pint_t end) {
-  uintptr_t size = (end - addr);
-  LocalAddressSpace::pint_t laddr = (LocalAddressSpace::pint_t) localCopy(addr);
-  LocalAddressSpace::pint_t sladdr = laddr;
-  uint64_t result = LocalAddressSpace::getULEB128(laddr, laddr + size);
-  addr += (laddr - sladdr);
-  return result;
-}
-
-template <typename P>
-int64_t RemoteAddressSpace<P>::getSLEB128(pint_t &addr, pint_t end) {
-  uintptr_t size = (end - addr);
-  LocalAddressSpace::pint_t laddr = (LocalAddressSpace::pint_t) localCopy(addr);
-  LocalAddressSpace::pint_t sladdr = laddr;
-  uint64_t result = LocalAddressSpace::getSLEB128(laddr, laddr + size);
-  addr += (laddr - sladdr);
-  return result;
-}
-
-template <typename P> void *RemoteAddressSpace<P>::localCopy(pint_t addr) {
-  // FIX ME
-}
-
-template <typename P>
-bool RemoteAddressSpace<P>::findFunctionName(pint_t addr, char *buf,
-                                             size_t bufLen,
-                                             unw_word_t *offset) {
-  // FIX ME
-}
-
-/// unw_addr_space is the base class that abstract unw_addr_space_t type in
-/// libunwind.h points to.
-struct unw_addr_space {
-  cpu_type_t cpuType;
-  task_t taskPort;
-};
-
-/// unw_addr_space_i386 is the concrete instance that a unw_addr_space_t points
-/// to when examining
-/// a 32-bit intel process.
-struct unw_addr_space_i386 : public unw_addr_space {
-  unw_addr_space_i386(task_t task) : oas(task) {}
-  RemoteAddressSpace<Pointer32<LittleEndian>> oas;
-};
-
-/// unw_addr_space_x86_64 is the concrete instance that a unw_addr_space_t
-/// points to when examining
-/// a 64-bit intel process.
-struct unw_addr_space_x86_64 : public unw_addr_space {
-  unw_addr_space_x86_64(task_t task) : oas(task) {}
-  RemoteAddressSpace<Pointer64<LittleEndian>> oas;
-};
-
-/// unw_addr_space_ppc is the concrete instance that a unw_addr_space_t points
-/// to when examining
-/// a 32-bit PowerPC process.
-struct unw_addr_space_ppc : public unw_addr_space {
-  unw_addr_space_ppc(task_t task) : oas(task) {}
-  RemoteAddressSpace<Pointer32<BigEndian>> oas;
-};
-
-/// unw_addr_space_ppc is the concrete instance that a unw_addr_space_t points
-/// to when examining a 64-bit PowerPC process.
-struct unw_addr_space_ppc64 : public unw_addr_space {
-  unw_addr_space_ppc64(task_t task) : oas(task) {}
-  RemoteAddressSpace<Pointer64<LittleEndian>> oas;
-};
-
-#endif // UNW_REMOTE
-
 } // namespace libunwind
 
 #endif // __ADDRESSSPACE_HPP__
diff --git a/WAVM/ThirdParty/libunwind/src/CMakeLists.txt b/WAVM/ThirdParty/libunwind/src/CMakeLists.txt
index 5c7a4c73..71019855 100644
--- a/WAVM/ThirdParty/libunwind/src/CMakeLists.txt
+++ b/WAVM/ThirdParty/libunwind/src/CMakeLists.txt
@@ -2,41 +2,60 @@
 
 set(LIBUNWIND_CXX_SOURCES
     libunwind.cpp
-    Unwind-EHABI.cpp)
-append_if(LIBUNWIND_CXX_SOURCES APPLE Unwind_AppleExtras.cpp)
+    Unwind-EHABI.cpp
+    Unwind-seh.cpp
+    )
+if(APPLE)
+  list(APPEND LIBUNWIND_CXX_SOURCES
+    Unwind_AppleExtras.cpp
+    )
+endif()
 
 set(LIBUNWIND_C_SOURCES
     UnwindLevel1.c
     UnwindLevel1-gcc-ext.c
-    Unwind-sjlj.c)
+    Unwind-sjlj.c
+    )
 set_source_files_properties(${LIBUNWIND_C_SOURCES}
                             PROPERTIES
                               COMPILE_FLAGS "-std=c99")
 
 set(LIBUNWIND_ASM_SOURCES
     UnwindRegistersRestore.S
-    UnwindRegistersSave.S)
-set_source_files_properties(${LIBUNWIND_ASM_SOURCES}
-                            PROPERTIES
-                              LANGUAGE C)
+    UnwindRegistersSave.S
+    )
+
+# See add_asm_sources() in compiler-rt for explanation of this workaround.
+if((APPLE AND CMAKE_VERSION VERSION_LESS 3.19) OR (MINGW AND CMAKE_VERSION VERSION_LESS 3.17))
+  set_source_files_properties(${LIBUNWIND_ASM_SOURCES} PROPERTIES LANGUAGE C)
+endif()
 
 set(LIBUNWIND_HEADERS
     AddressSpace.hpp
     assembly.h
     CompactUnwinder.hpp
+    cet_unwind.h
     config.h
     dwarf2.h
     DwarfInstructions.hpp
     DwarfParser.hpp
+    EHHeaderParser.hpp
+    FrameHeaderCache.hpp
     libunwind_ext.h
     Registers.hpp
     RWMutex.hpp
+    Unwind-EHABI.h
     UnwindCursor.hpp
-    ${CMAKE_CURRENT_SOURCE_DIR}/../include/libunwind.h
-    ${CMAKE_CURRENT_SOURCE_DIR}/../include/unwind.h)
-
-append_if(LIBUNWIND_HEADERS APPLE
-          "${CMAKE_CURRENT_SOURCE_DIR}/../include/mach-o/compact_unwind_encoding.h")
+    ../include/libunwind.h
+    ../include/unwind.h
+    ../include/unwind_itanium.h
+    ../include/unwind_arm_ehabi.h
+    )
+if(APPLE)
+  list(APPEND LIBUNWIND_HEADERS
+    ../include/mach-o/compact_unwind_encoding.h
+    )
+endif()
 
 if (MSVC_IDE)
   # Force them all into the headers dir on MSVC, otherwise they end up at
@@ -50,22 +69,33 @@ set(LIBUNWIND_SOURCES
     ${LIBUNWIND_ASM_SOURCES})
 
 # Generate library list.
-set(libraries ${LIBUNWINDCXX_ABI_LIBRARIES})
-append_if(libraries LIBUNWIND_HAS_C_LIB c)
-append_if(libraries LIBUNWIND_HAS_DL_LIB dl)
+add_library_flags_if(LIBUNWIND_HAS_C_LIB c)
+if (LIBUNWIND_USE_COMPILER_RT)
+  add_library_flags("${LIBUNWIND_BUILTINS_LIBRARY}")
+else()
+  add_library_flags_if(LIBUNWIND_HAS_GCC_S_LIB gcc_s)
+  add_library_flags_if(LIBUNWIND_HAS_GCC_LIB gcc)
+endif()
+add_library_flags_if(LIBUNWIND_HAS_DL_LIB dl)
 if (LIBUNWIND_ENABLE_THREADS)
-  append_if(libraries LIBUNWIND_HAS_PTHREAD_LIB pthread)
+  add_library_flags_if(LIBUNWIND_HAS_PTHREAD_LIB pthread)
+  add_compile_flags_if(LIBUNWIND_WEAK_PTHREAD_LIB -DLIBUNWIND_USE_WEAK_PTHREAD=1)
 endif()
 
 # Setup flags.
-append_if(LIBUNWIND_CXX_FLAGS LIBUNWIND_HAS_NO_RTTI_FLAG -fno-rtti)
+add_link_flags_if(LIBUNWIND_SUPPORTS_UNWINDLIB_NONE_FLAG --unwindlib=none)
+if (LIBUNWIND_SUPPORTS_NOSTDLIBXX_FLAG)
+  add_link_flags_if_supported(-nostdlib++)
+else()
+  add_link_flags_if_supported(-nodefaultlibs)
+endif()
 
-append_if(LIBUNWIND_LINK_FLAGS LIBUNWIND_HAS_NODEFAULTLIBS_FLAG -nodefaultlibs)
+# MINGW_LIBRARIES is defined in config-ix.cmake
+add_library_flags_if(MINGW "${MINGW_LIBRARIES}")
 
-if (LIBUNWIND_HAS_NO_EXCEPTIONS_FLAG AND LIBUNWIND_HAS_FUNWIND_TABLES)
-  list(APPEND LIBUNWIND_COMPILE_FLAGS -fno-exceptions)
-  list(APPEND LIBUNWIND_COMPILE_FLAGS -funwind-tables)
-elseif (LIBUNWIND_ENABLE_SHARED)
+if (LIBUNWIND_ENABLE_SHARED AND
+    NOT (LIBUNWIND_SUPPORTS_FNO_EXCEPTIONS_FLAG AND
+         LIBUNWIND_SUPPORTS_FUNWIND_TABLES_FLAG))
   message(FATAL_ERROR
           "Compiler doesn't support generation of unwind tables if exception "
           "support is disabled.  Building libunwind DSO with runtime dependency "
@@ -73,15 +103,11 @@ elseif (LIBUNWIND_ENABLE_SHARED)
 endif()
 
 if (APPLE)
-  list(APPEND LIBUNWIND_COMPILE_FLAGS "-U__STRICT_ANSI__")
-  list(APPEND LIBUNWIND_LINK_FLAGS
-       "-compatibility_version 1"
-       "-install_name /usr/lib/libunwind.1.dylib")
+  add_compile_flags("-U__STRICT_ANSI__")
+  add_link_flags("-compatibility_version 1" "-install_name /usr/lib/libunwind.1.dylib")
 
   if (CMAKE_OSX_DEPLOYMENT_TARGET STREQUAL "10.6")
-    list(APPEND LIBUNWIND_LINK_FLAGS
-         "-current_version ${LIBUNWIND_VERSION}"
-         "/usr/lib/libSystem.B.dylib")
+    add_link_flags("-current_version ${LIBUNWIND_VERSION}" "/usr/lib/libSystem.B.dylib")
   endif ()
 endif ()
 
@@ -95,50 +121,80 @@ set_property(SOURCE ${LIBUNWIND_CXX_SOURCES}
 set_property(SOURCE ${LIBUNWIND_C_SOURCES}
              APPEND_STRING PROPERTY COMPILE_FLAGS " ${LIBUNWIND_C_FLAGS}")
 
-# Add a object library that contains the compiled source files.
-add_library(unwind_objects OBJECT ${LIBUNWIND_SOURCES} ${LIBUNWIND_HEADERS})
-
-set_target_properties(unwind_objects
-                      PROPERTIES
-                        COMPILE_FLAGS "${LIBUNWIND_COMPILE_FLAGS}"
-                        POSITION_INDEPENDENT_CODE ON)
-
-set(LIBUNWIND_TARGETS)
+# NOTE: avoid implicit dependencies on C++ runtimes.  libunwind uses C++ for
+# ease, but does not rely on C++ at runtime.
+set(CMAKE_CXX_IMPLICIT_LINK_LIBRARIES "")
 
 # Build the shared library.
 if (LIBUNWIND_ENABLE_SHARED)
-  add_library(unwind_shared SHARED $<TARGET_OBJECTS:unwind_objects>)
-  if(COMMAND llvm_setup_rpath)
-    llvm_setup_rpath(unwind_shared)
+  add_library(unwind_shared SHARED ${LIBUNWIND_SOURCES} ${LIBUNWIND_HEADERS})
+  if(CMAKE_C_COMPILER_ID STREQUAL MSVC)
+    target_compile_options(unwind_shared PRIVATE /GR-)
+  else()
+    target_compile_options(unwind_shared PRIVATE -fno-rtti)
   endif()
-  target_link_libraries(unwind_shared ${libraries})
+  target_link_libraries(unwind_shared PRIVATE ${LIBUNWIND_LIBRARIES}
+                                      PRIVATE unwind-headers)
   set_target_properties(unwind_shared
-                        PROPERTIES
-                          LINK_FLAGS    "${LIBUNWIND_LINK_FLAGS}"
-                          OUTPUT_NAME   "unwind"
-                          VERSION       "1.0"
-                          SOVERSION     "1")
-  list(APPEND LIBUNWIND_TARGETS "unwind_shared")
+    PROPERTIES
+      CXX_EXTENSIONS OFF
+      CXX_STANDARD 11
+      CXX_STANDARD_REQUIRED ON
+      COMPILE_FLAGS "${LIBUNWIND_COMPILE_FLAGS}"
+      LINK_FLAGS "${LIBUNWIND_LINK_FLAGS}"
+      LINKER_LANGUAGE C
+      OUTPUT_NAME "unwind"
+      VERSION "1.0"
+      SOVERSION "1"
+  )
+  list(APPEND LIBUNWIND_BUILD_TARGETS "unwind_shared")
+  if (LIBUNWIND_INSTALL_SHARED_LIBRARY)
+    list(APPEND LIBUNWIND_INSTALL_TARGETS "unwind_shared")
+  endif()
 endif()
 
 # Build the static library.
 if (LIBUNWIND_ENABLE_STATIC)
-  add_library(unwind_static STATIC $<TARGET_OBJECTS:unwind_objects>)
-  target_link_libraries(unwind_static ${libraries})
+  add_library(unwind_static STATIC ${LIBUNWIND_SOURCES} ${LIBUNWIND_HEADERS})
+  if(CMAKE_C_COMPILER_ID STREQUAL MSVC)
+    target_compile_options(unwind_static PRIVATE /GR-)
+  else()
+    target_compile_options(unwind_static PRIVATE -fno-rtti)
+  endif()
+  target_link_libraries(unwind_static PRIVATE ${LIBUNWIND_LIBRARIES}
+                                      PRIVATE unwind-headers)
   set_target_properties(unwind_static
-                        PROPERTIES
-                          LINK_FLAGS    "${LIBUNWIND_LINK_FLAGS}"
-                          OUTPUT_NAME   "unwind")
-  list(APPEND LIBUNWIND_TARGETS "unwind_static")
+    PROPERTIES
+      CXX_EXTENSIONS OFF
+      CXX_STANDARD 11
+      CXX_STANDARD_REQUIRED ON
+      COMPILE_FLAGS "${LIBUNWIND_COMPILE_FLAGS}"
+      LINK_FLAGS "${LIBUNWIND_LINK_FLAGS}"
+      LINKER_LANGUAGE C
+      OUTPUT_NAME "unwind"
+  )
+
+  if(LIBUNWIND_HIDE_SYMBOLS)
+    append_flags_if_supported(UNWIND_STATIC_LIBRARY_FLAGS -fvisibility=hidden)
+    append_flags_if_supported(UNWIND_STATIC_LIBRARY_FLAGS -fvisibility-global-new-delete-hidden)
+    target_compile_options(unwind_static PRIVATE ${UNWIND_STATIC_LIBRARY_FLAGS})
+    target_compile_definitions(unwind_static PRIVATE _LIBUNWIND_HIDE_SYMBOLS)
+  endif()
+
+  list(APPEND LIBUNWIND_BUILD_TARGETS "unwind_static")
+  if (LIBUNWIND_INSTALL_STATIC_LIBRARY)
+    list(APPEND LIBUNWIND_INSTALL_TARGETS "unwind_static")
+  endif()
 endif()
 
 # Add a meta-target for both libraries.
-add_custom_target(unwind DEPENDS ${LIBUNWIND_TARGETS})
+add_custom_target(unwind DEPENDS ${LIBUNWIND_BUILD_TARGETS})
 
 if (LIBUNWIND_INSTALL_LIBRARY)
-  install(TARGETS ${LIBUNWIND_TARGETS}
-    LIBRARY DESTINATION ${LIBUNWIND_INSTALL_PREFIX}lib${LIBUNWIND_LIBDIR_SUFFIX} COMPONENT unwind
-    ARCHIVE DESTINATION ${LIBUNWIND_INSTALL_PREFIX}lib${LIBUNWIND_LIBDIR_SUFFIX} COMPONENT unwind)
+  install(TARGETS ${LIBUNWIND_INSTALL_TARGETS}
+    LIBRARY DESTINATION ${LIBUNWIND_INSTALL_LIBRARY_DIR} COMPONENT unwind
+    ARCHIVE DESTINATION ${LIBUNWIND_INSTALL_LIBRARY_DIR} COMPONENT unwind
+    RUNTIME DESTINATION ${LIBUNWIND_INSTALL_RUNTIME_DIR} COMPONENT unwind)
 endif()
 
 if (NOT CMAKE_CONFIGURATION_TYPES AND LIBUNWIND_INSTALL_LIBRARY)
@@ -153,4 +209,8 @@ if (NOT CMAKE_CONFIGURATION_TYPES AND LIBUNWIND_INSTALL_LIBRARY)
             -DCMAKE_INSTALL_COMPONENT=unwind
             -DCMAKE_INSTALL_DO_STRIP=1
             -P "${LIBUNWIND_BINARY_DIR}/cmake_install.cmake")
+  if(LIBUNWIND_INSTALL_HEADERS)
+    add_dependencies(install-unwind install-unwind-headers)
+    add_dependencies(install-unwind-stripped install-unwind-headers-stripped)
+  endif()
 endif()
diff --git a/WAVM/ThirdParty/libunwind/src/CompactUnwinder.hpp b/WAVM/ThirdParty/libunwind/src/CompactUnwinder.hpp
index 7b97bf84..0b2b5e11 100644
--- a/WAVM/ThirdParty/libunwind/src/CompactUnwinder.hpp
+++ b/WAVM/ThirdParty/libunwind/src/CompactUnwinder.hpp
@@ -1,9 +1,8 @@
-//===-------------------------- CompactUnwinder.hpp -----------------------===//
-//
-//                     The LLVM Compiler Infrastructure
+//===----------------------------------------------------------------------===//
 //
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //
 //  Does runtime stack unwinding using compact unwind encodings.
@@ -538,65 +537,65 @@ int CompactUnwinder_arm64<A>::stepWithCompactEncodingFrameless(
   uint64_t savedRegisterLoc = registers.getSP() + stackSize;
 
   if (encoding & UNWIND_ARM64_FRAME_X19_X20_PAIR) {
-    registers.setRegister(UNW_ARM64_X19, addressSpace.get64(savedRegisterLoc));
+    registers.setRegister(UNW_AARCH64_X19, addressSpace.get64(savedRegisterLoc));
     savedRegisterLoc -= 8;
-    registers.setRegister(UNW_ARM64_X20, addressSpace.get64(savedRegisterLoc));
+    registers.setRegister(UNW_AARCH64_X20, addressSpace.get64(savedRegisterLoc));
     savedRegisterLoc -= 8;
   }
   if (encoding & UNWIND_ARM64_FRAME_X21_X22_PAIR) {
-    registers.setRegister(UNW_ARM64_X21, addressSpace.get64(savedRegisterLoc));
+    registers.setRegister(UNW_AARCH64_X21, addressSpace.get64(savedRegisterLoc));
     savedRegisterLoc -= 8;
-    registers.setRegister(UNW_ARM64_X22, addressSpace.get64(savedRegisterLoc));
+    registers.setRegister(UNW_AARCH64_X22, addressSpace.get64(savedRegisterLoc));
     savedRegisterLoc -= 8;
   }
   if (encoding & UNWIND_ARM64_FRAME_X23_X24_PAIR) {
-    registers.setRegister(UNW_ARM64_X23, addressSpace.get64(savedRegisterLoc));
+    registers.setRegister(UNW_AARCH64_X23, addressSpace.get64(savedRegisterLoc));
     savedRegisterLoc -= 8;
-    registers.setRegister(UNW_ARM64_X24, addressSpace.get64(savedRegisterLoc));
+    registers.setRegister(UNW_AARCH64_X24, addressSpace.get64(savedRegisterLoc));
     savedRegisterLoc -= 8;
   }
   if (encoding & UNWIND_ARM64_FRAME_X25_X26_PAIR) {
-    registers.setRegister(UNW_ARM64_X25, addressSpace.get64(savedRegisterLoc));
+    registers.setRegister(UNW_AARCH64_X25, addressSpace.get64(savedRegisterLoc));
     savedRegisterLoc -= 8;
-    registers.setRegister(UNW_ARM64_X26, addressSpace.get64(savedRegisterLoc));
+    registers.setRegister(UNW_AARCH64_X26, addressSpace.get64(savedRegisterLoc));
     savedRegisterLoc -= 8;
   }
   if (encoding & UNWIND_ARM64_FRAME_X27_X28_PAIR) {
-    registers.setRegister(UNW_ARM64_X27, addressSpace.get64(savedRegisterLoc));
+    registers.setRegister(UNW_AARCH64_X27, addressSpace.get64(savedRegisterLoc));
     savedRegisterLoc -= 8;
-    registers.setRegister(UNW_ARM64_X28, addressSpace.get64(savedRegisterLoc));
+    registers.setRegister(UNW_AARCH64_X28, addressSpace.get64(savedRegisterLoc));
     savedRegisterLoc -= 8;
   }
 
   if (encoding & UNWIND_ARM64_FRAME_D8_D9_PAIR) {
-    registers.setFloatRegister(UNW_ARM64_D8,
+    registers.setFloatRegister(UNW_AARCH64_V8,
                                addressSpace.getDouble(savedRegisterLoc));
     savedRegisterLoc -= 8;
-    registers.setFloatRegister(UNW_ARM64_D9,
+    registers.setFloatRegister(UNW_AARCH64_V9,
                                addressSpace.getDouble(savedRegisterLoc));
     savedRegisterLoc -= 8;
   }
   if (encoding & UNWIND_ARM64_FRAME_D10_D11_PAIR) {
-    registers.setFloatRegister(UNW_ARM64_D10,
+    registers.setFloatRegister(UNW_AARCH64_V10,
                                addressSpace.getDouble(savedRegisterLoc));
     savedRegisterLoc -= 8;
-    registers.setFloatRegister(UNW_ARM64_D11,
+    registers.setFloatRegister(UNW_AARCH64_V11,
                                addressSpace.getDouble(savedRegisterLoc));
     savedRegisterLoc -= 8;
   }
   if (encoding & UNWIND_ARM64_FRAME_D12_D13_PAIR) {
-    registers.setFloatRegister(UNW_ARM64_D12,
+    registers.setFloatRegister(UNW_AARCH64_V12,
                                addressSpace.getDouble(savedRegisterLoc));
     savedRegisterLoc -= 8;
-    registers.setFloatRegister(UNW_ARM64_D13,
+    registers.setFloatRegister(UNW_AARCH64_V13,
                                addressSpace.getDouble(savedRegisterLoc));
     savedRegisterLoc -= 8;
   }
   if (encoding & UNWIND_ARM64_FRAME_D14_D15_PAIR) {
-    registers.setFloatRegister(UNW_ARM64_D14,
+    registers.setFloatRegister(UNW_AARCH64_V14,
                                addressSpace.getDouble(savedRegisterLoc));
     savedRegisterLoc -= 8;
-    registers.setFloatRegister(UNW_ARM64_D15,
+    registers.setFloatRegister(UNW_AARCH64_V15,
                                addressSpace.getDouble(savedRegisterLoc));
     savedRegisterLoc -= 8;
   }
@@ -605,7 +604,7 @@ int CompactUnwinder_arm64<A>::stepWithCompactEncodingFrameless(
   registers.setSP(savedRegisterLoc);
 
   // set pc to be value in lr
-  registers.setIP(registers.getRegister(UNW_ARM64_LR));
+  registers.setIP(registers.getRegister(UNW_AARCH64_LR));
 
   return UNW_STEP_SUCCESS;
 }
@@ -617,65 +616,65 @@ int CompactUnwinder_arm64<A>::stepWithCompactEncodingFrame(
   uint64_t savedRegisterLoc = registers.getFP() - 8;
 
   if (encoding & UNWIND_ARM64_FRAME_X19_X20_PAIR) {
-    registers.setRegister(UNW_ARM64_X19, addressSpace.get64(savedRegisterLoc));
+    registers.setRegister(UNW_AARCH64_X19, addressSpace.get64(savedRegisterLoc));
     savedRegisterLoc -= 8;
-    registers.setRegister(UNW_ARM64_X20, addressSpace.get64(savedRegisterLoc));
+    registers.setRegister(UNW_AARCH64_X20, addressSpace.get64(savedRegisterLoc));
     savedRegisterLoc -= 8;
   }
   if (encoding & UNWIND_ARM64_FRAME_X21_X22_PAIR) {
-    registers.setRegister(UNW_ARM64_X21, addressSpace.get64(savedRegisterLoc));
+    registers.setRegister(UNW_AARCH64_X21, addressSpace.get64(savedRegisterLoc));
     savedRegisterLoc -= 8;
-    registers.setRegister(UNW_ARM64_X22, addressSpace.get64(savedRegisterLoc));
+    registers.setRegister(UNW_AARCH64_X22, addressSpace.get64(savedRegisterLoc));
     savedRegisterLoc -= 8;
   }
   if (encoding & UNWIND_ARM64_FRAME_X23_X24_PAIR) {
-    registers.setRegister(UNW_ARM64_X23, addressSpace.get64(savedRegisterLoc));
+    registers.setRegister(UNW_AARCH64_X23, addressSpace.get64(savedRegisterLoc));
     savedRegisterLoc -= 8;
-    registers.setRegister(UNW_ARM64_X24, addressSpace.get64(savedRegisterLoc));
+    registers.setRegister(UNW_AARCH64_X24, addressSpace.get64(savedRegisterLoc));
     savedRegisterLoc -= 8;
   }
   if (encoding & UNWIND_ARM64_FRAME_X25_X26_PAIR) {
-    registers.setRegister(UNW_ARM64_X25, addressSpace.get64(savedRegisterLoc));
+    registers.setRegister(UNW_AARCH64_X25, addressSpace.get64(savedRegisterLoc));
     savedRegisterLoc -= 8;
-    registers.setRegister(UNW_ARM64_X26, addressSpace.get64(savedRegisterLoc));
+    registers.setRegister(UNW_AARCH64_X26, addressSpace.get64(savedRegisterLoc));
     savedRegisterLoc -= 8;
   }
   if (encoding & UNWIND_ARM64_FRAME_X27_X28_PAIR) {
-    registers.setRegister(UNW_ARM64_X27, addressSpace.get64(savedRegisterLoc));
+    registers.setRegister(UNW_AARCH64_X27, addressSpace.get64(savedRegisterLoc));
     savedRegisterLoc -= 8;
-    registers.setRegister(UNW_ARM64_X28, addressSpace.get64(savedRegisterLoc));
+    registers.setRegister(UNW_AARCH64_X28, addressSpace.get64(savedRegisterLoc));
     savedRegisterLoc -= 8;
   }
 
   if (encoding & UNWIND_ARM64_FRAME_D8_D9_PAIR) {
-    registers.setFloatRegister(UNW_ARM64_D8,
+    registers.setFloatRegister(UNW_AARCH64_V8,
                                addressSpace.getDouble(savedRegisterLoc));
     savedRegisterLoc -= 8;
-    registers.setFloatRegister(UNW_ARM64_D9,
+    registers.setFloatRegister(UNW_AARCH64_V9,
                                addressSpace.getDouble(savedRegisterLoc));
     savedRegisterLoc -= 8;
   }
   if (encoding & UNWIND_ARM64_FRAME_D10_D11_PAIR) {
-    registers.setFloatRegister(UNW_ARM64_D10,
+    registers.setFloatRegister(UNW_AARCH64_V10,
                                addressSpace.getDouble(savedRegisterLoc));
     savedRegisterLoc -= 8;
-    registers.setFloatRegister(UNW_ARM64_D11,
+    registers.setFloatRegister(UNW_AARCH64_V11,
                                addressSpace.getDouble(savedRegisterLoc));
     savedRegisterLoc -= 8;
   }
   if (encoding & UNWIND_ARM64_FRAME_D12_D13_PAIR) {
-    registers.setFloatRegister(UNW_ARM64_D12,
+    registers.setFloatRegister(UNW_AARCH64_V12,
                                addressSpace.getDouble(savedRegisterLoc));
     savedRegisterLoc -= 8;
-    registers.setFloatRegister(UNW_ARM64_D13,
+    registers.setFloatRegister(UNW_AARCH64_V13,
                                addressSpace.getDouble(savedRegisterLoc));
     savedRegisterLoc -= 8;
   }
   if (encoding & UNWIND_ARM64_FRAME_D14_D15_PAIR) {
-    registers.setFloatRegister(UNW_ARM64_D14,
+    registers.setFloatRegister(UNW_AARCH64_V14,
                                addressSpace.getDouble(savedRegisterLoc));
     savedRegisterLoc -= 8;
-    registers.setFloatRegister(UNW_ARM64_D15,
+    registers.setFloatRegister(UNW_AARCH64_V15,
                                addressSpace.getDouble(savedRegisterLoc));
     savedRegisterLoc -= 8;
   }
diff --git a/WAVM/ThirdParty/libunwind/src/DwarfInstructions.hpp b/WAVM/ThirdParty/libunwind/src/DwarfInstructions.hpp
index 88e67198..ab83b0c8 100644
--- a/WAVM/ThirdParty/libunwind/src/DwarfInstructions.hpp
+++ b/WAVM/ThirdParty/libunwind/src/DwarfInstructions.hpp
@@ -1,9 +1,8 @@
-//===-------------------------- DwarfInstructions.hpp ---------------------===//
-//
-//                     The LLVM Compiler Infrastructure
+//===----------------------------------------------------------------------===//
 //
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //
 //  Processor specific interpretation of DWARF unwind info.
@@ -35,7 +34,7 @@ public:
   typedef typename A::sint_t sint_t;
 
   static int stepWithDwarf(A &addressSpace, pint_t pc, pint_t fdeStart,
-                           R &registers);
+                           R &registers, bool &isSignalFrame);
 
 private:
 
@@ -75,6 +74,13 @@ private:
   }
 };
 
+template <typename R>
+auto getSparcWCookie(const R &r, int) -> decltype(r.getWCookie()) {
+  return r.getWCookie();
+}
+template <typename R> uint64_t getSparcWCookie(const R &, long) {
+  return 0;
+}
 
 template <typename A, typename R>
 typename A::pint_t DwarfInstructions<A, R>::getSavedRegister(
@@ -82,12 +88,15 @@ typename A::pint_t DwarfInstructions<A, R>::getSavedRegister(
     const RegisterLocation &savedReg) {
   switch (savedReg.location) {
   case CFI_Parser<A>::kRegisterInCFA:
-    return addressSpace.getRegister(cfa + (pint_t)savedReg.value);
+    return (pint_t)addressSpace.getRegister(cfa + (pint_t)savedReg.value);
+
+  case CFI_Parser<A>::kRegisterInCFADecrypt: // sparc64 specific
+    return (pint_t)(addressSpace.getP(cfa + (pint_t)savedReg.value) ^
+           getSparcWCookie(registers, 0));
 
   case CFI_Parser<A>::kRegisterAtExpression:
-    return addressSpace.getRegister(
-        evaluateExpression((pint_t)savedReg.value, addressSpace,
-                            registers, cfa));
+    return (pint_t)addressSpace.getRegister(evaluateExpression(
+        (pint_t)savedReg.value, addressSpace, registers, cfa));
 
   case CFI_Parser<A>::kRegisterIsExpression:
     return evaluateExpression((pint_t)savedReg.value, addressSpace,
@@ -95,7 +104,8 @@ typename A::pint_t DwarfInstructions<A, R>::getSavedRegister(
 
   case CFI_Parser<A>::kRegisterInRegister:
     return registers.getRegister((int)savedReg.value);
-
+  case CFI_Parser<A>::kRegisterUndefined:
+    return 0;
   case CFI_Parser<A>::kRegisterUnused:
   case CFI_Parser<A>::kRegisterOffsetFromCFA:
     // FIX ME
@@ -116,11 +126,16 @@ double DwarfInstructions<A, R>::getSavedFloatRegister(
     return addressSpace.getDouble(
         evaluateExpression((pint_t)savedReg.value, addressSpace,
                             registers, cfa));
-
+  case CFI_Parser<A>::kRegisterUndefined:
+    return 0.0;
+  case CFI_Parser<A>::kRegisterInRegister:
+#ifndef _LIBUNWIND_TARGET_ARM
+    return registers.getFloatRegister((int)savedReg.value);
+#endif
   case CFI_Parser<A>::kRegisterIsExpression:
   case CFI_Parser<A>::kRegisterUnused:
   case CFI_Parser<A>::kRegisterOffsetFromCFA:
-  case CFI_Parser<A>::kRegisterInRegister:
+  case CFI_Parser<A>::kRegisterInCFADecrypt:
     // FIX ME
     break;
   }
@@ -142,8 +157,10 @@ v128 DwarfInstructions<A, R>::getSavedVectorRegister(
 
   case CFI_Parser<A>::kRegisterIsExpression:
   case CFI_Parser<A>::kRegisterUnused:
+  case CFI_Parser<A>::kRegisterUndefined:
   case CFI_Parser<A>::kRegisterOffsetFromCFA:
   case CFI_Parser<A>::kRegisterInRegister:
+  case CFI_Parser<A>::kRegisterInCFADecrypt:
     // FIX ME
     break;
   }
@@ -152,19 +169,30 @@ v128 DwarfInstructions<A, R>::getSavedVectorRegister(
 
 template <typename A, typename R>
 int DwarfInstructions<A, R>::stepWithDwarf(A &addressSpace, pint_t pc,
-                                           pint_t fdeStart, R &registers) {
+                                           pint_t fdeStart, R &registers,
+                                           bool &isSignalFrame) {
   FDE_Info fdeInfo;
   CIE_Info cieInfo;
   if (CFI_Parser<A>::decodeFDE(addressSpace, fdeStart, &fdeInfo,
                                &cieInfo) == NULL) {
     PrologInfo prolog;
     if (CFI_Parser<A>::parseFDEInstructions(addressSpace, fdeInfo, cieInfo, pc,
-                                            &prolog)) {
+                                            R::getArch(), &prolog)) {
       // get pointer to cfa (architecture specific)
       pint_t cfa = getCFA(addressSpace, prolog, registers);
 
        // restore registers that DWARF says were saved
       R newRegisters = registers;
+
+      // Typically, the CFA is the stack pointer at the call site in
+      // the previous frame. However, there are scenarios in which this is not
+      // true. For example, if we switched to a new stack. In that case, the
+      // value of the previous SP might be indicated by a CFI directive.
+      //
+      // We set the SP here to the CFA, allowing for it to be overridden
+      // by a CFI directive later on.
+      newRegisters.setSP(cfa);
+
       pint_t returnAddress = 0;
       const int lastReg = R::lastDwarfRegNum();
       assert(static_cast<int>(CFI_Parser<A>::kMaxRegisterNumber) >= lastReg &&
@@ -191,12 +219,96 @@ int DwarfInstructions<A, R>::stepWithDwarf(A &addressSpace, pint_t pc,
                                     prolog.savedRegisters[i]));
           else
             return UNW_EBADREG;
+        } else if (i == (int)cieInfo.returnAddressRegister) {
+            // Leaf function keeps the return address in register and there is no
+            // explicit intructions how to restore it.
+            returnAddress = registers.getRegister(cieInfo.returnAddressRegister);
         }
       }
 
-      // By definition, the CFA is the stack pointer at the call site, so
-      // restoring SP means setting it to CFA.
-      newRegisters.setSP(cfa);
+      isSignalFrame = cieInfo.isSignalFrame;
+
+#if defined(_LIBUNWIND_TARGET_AARCH64)
+      // If the target is aarch64 then the return address may have been signed
+      // using the v8.3 pointer authentication extensions. The original
+      // return address needs to be authenticated before the return address is
+      // restored. autia1716 is used instead of autia as autia1716 assembles
+      // to a NOP on pre-v8.3a architectures.
+      if ((R::getArch() == REGISTERS_ARM64) &&
+          prolog.savedRegisters[UNW_AARCH64_RA_SIGN_STATE].value &&
+          returnAddress != 0) {
+#if !defined(_LIBUNWIND_IS_NATIVE_ONLY)
+        return UNW_ECROSSRASIGNING;
+#else
+        register unsigned long long x17 __asm("x17") = returnAddress;
+        register unsigned long long x16 __asm("x16") = cfa;
+
+        // These are the autia1716/autib1716 instructions. The hint instructions
+        // are used here as gcc does not assemble autia1716/autib1716 for pre
+        // armv8.3a targets.
+        if (cieInfo.addressesSignedWithBKey)
+          asm("hint 0xe" : "+r"(x17) : "r"(x16)); // autib1716
+        else
+          asm("hint 0xc" : "+r"(x17) : "r"(x16)); // autia1716
+        returnAddress = x17;
+#endif
+      }
+#endif
+
+#if defined(_LIBUNWIND_IS_NATIVE_ONLY) && defined(_LIBUNWIND_TARGET_ARM) &&    \
+    defined(__ARM_FEATURE_PAUTH)
+      if ((R::getArch() == REGISTERS_ARM) &&
+          prolog.savedRegisters[UNW_ARM_RA_AUTH_CODE].value) {
+        pint_t pac =
+            getSavedRegister(addressSpace, registers, cfa,
+                             prolog.savedRegisters[UNW_ARM_RA_AUTH_CODE]);
+        __asm__ __volatile__("autg %0, %1, %2"
+                             :
+                             : "r"(pac), "r"(returnAddress), "r"(cfa)
+                             :);
+      }
+#endif
+
+#if defined(_LIBUNWIND_TARGET_SPARC)
+      if (R::getArch() == REGISTERS_SPARC) {
+        // Skip call site instruction and delay slot
+        returnAddress += 8;
+        // Skip unimp instruction if function returns a struct
+        if ((addressSpace.get32(returnAddress) & 0xC1C00000) == 0)
+          returnAddress += 4;
+      }
+#endif
+
+#if defined(_LIBUNWIND_TARGET_SPARC64)
+      // Skip call site instruction and delay slot.
+      if (R::getArch() == REGISTERS_SPARC64)
+        returnAddress += 8;
+#endif
+
+#if defined(_LIBUNWIND_TARGET_PPC64)
+#define PPC64_ELFV1_R2_LOAD_INST_ENCODING 0xe8410028u // ld r2,40(r1)
+#define PPC64_ELFV1_R2_OFFSET 40
+#define PPC64_ELFV2_R2_LOAD_INST_ENCODING 0xe8410018u // ld r2,24(r1)
+#define PPC64_ELFV2_R2_OFFSET 24
+      // If the instruction at return address is a TOC (r2) restore,
+      // then r2 was saved and needs to be restored.
+      // ELFv2 ABI specifies that the TOC Pointer must be saved at SP + 24,
+      // while in ELFv1 ABI it is saved at SP + 40.
+      if (R::getArch() == REGISTERS_PPC64 && returnAddress != 0) {
+        pint_t sp = newRegisters.getRegister(UNW_REG_SP);
+        pint_t r2 = 0;
+        switch (addressSpace.get32(returnAddress)) {
+        case PPC64_ELFV1_R2_LOAD_INST_ENCODING:
+          r2 = addressSpace.get64(sp + PPC64_ELFV1_R2_OFFSET);
+          break;
+        case PPC64_ELFV2_R2_LOAD_INST_ENCODING:
+          r2 = addressSpace.get64(sp + PPC64_ELFV2_R2_OFFSET);
+          break;
+        }
+        if (r2)
+          newRegisters.setRegister(UNW_PPC64_R2, r2);
+      }
+#endif
 
       // Return address is address after call site instruction, so setting IP to
       // that does simualates a return.
@@ -371,7 +483,7 @@ DwarfInstructions<A, R>::evaluateExpression(pint_t expression, A &addressSpace,
       // pick from
       reg = addressSpace.get8(p);
       p += 1;
-      value = sp[-reg];
+      value = sp[-(int)reg];
       *(++sp) = value;
       if (log)
         fprintf(stderr, "duplicate %d in stack\n", reg);
diff --git a/WAVM/ThirdParty/libunwind/src/DwarfParser.hpp b/WAVM/ThirdParty/libunwind/src/DwarfParser.hpp
index 86727fda..b5a53166 100644
--- a/WAVM/ThirdParty/libunwind/src/DwarfParser.hpp
+++ b/WAVM/ThirdParty/libunwind/src/DwarfParser.hpp
@@ -1,9 +1,8 @@
-//===--------------------------- DwarfParser.hpp --------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
+//===----------------------------------------------------------------------===//
 //
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //
 //  Parses DWARF CFIs (FDEs and CIEs).
@@ -20,6 +19,7 @@
 
 #include "libunwind.h"
 #include "dwarf2.h"
+#include "Registers.hpp"
 
 #include "config.h"
 
@@ -49,6 +49,9 @@ public:
     bool      isSignalFrame;
     bool      fdesHaveAugmentationData;
     uint8_t   returnAddressRegister;
+#if defined(_LIBUNWIND_TARGET_AARCH64)
+    bool      addressesSignedWithBKey;
+#endif
   };
 
   /// Information about an FDE (Frame Description Entry)
@@ -66,7 +69,9 @@ public:
   };
   enum RegisterSavedWhere {
     kRegisterUnused,
+    kRegisterUndefined,
     kRegisterInCFA,
+    kRegisterInCFADecrypt, // sparc64 specific
     kRegisterOffsetFromCFA,
     kRegisterInRegister,
     kRegisterAtExpression,
@@ -74,6 +79,7 @@ public:
   };
   struct RegisterLocation {
     RegisterSavedWhere location;
+    bool initialStateSaved;
     int64_t value;
   };
   /// Information about a frame layout and registers saved determined
@@ -83,10 +89,41 @@ public:
     int32_t           cfaRegisterOffset;  // CFA = (cfaRegister)+cfaRegisterOffset
     int64_t           cfaExpression;      // CFA = expression
     uint32_t          spExtraArgSize;
-    uint32_t          codeOffsetAtStackDecrement;
-    bool              registersInOtherRegisters;
-    bool              sameValueUsed;
     RegisterLocation  savedRegisters[kMaxRegisterNumber + 1];
+    enum class InitializeTime { kLazy, kNormal };
+
+    // When saving registers, this data structure is lazily initialized.
+    PrologInfo(InitializeTime IT = InitializeTime::kNormal) {
+      if (IT == InitializeTime::kNormal)
+        memset(this, 0, sizeof(*this));
+    }
+    void checkSaveRegister(uint64_t reg, PrologInfo &initialState) {
+      if (!savedRegisters[reg].initialStateSaved) {
+        initialState.savedRegisters[reg] = savedRegisters[reg];
+        savedRegisters[reg].initialStateSaved = true;
+      }
+    }
+    void setRegister(uint64_t reg, RegisterSavedWhere newLocation,
+                     int64_t newValue, PrologInfo &initialState) {
+      checkSaveRegister(reg, initialState);
+      savedRegisters[reg].location = newLocation;
+      savedRegisters[reg].value = newValue;
+    }
+    void setRegisterLocation(uint64_t reg, RegisterSavedWhere newLocation,
+                             PrologInfo &initialState) {
+      checkSaveRegister(reg, initialState);
+      savedRegisters[reg].location = newLocation;
+    }
+    void setRegisterValue(uint64_t reg, int64_t newValue,
+                          PrologInfo &initialState) {
+      checkSaveRegister(reg, initialState);
+      savedRegisters[reg].value = newValue;
+    }
+    void restoreRegisterToInitialState(uint64_t reg, PrologInfo &initialState) {
+      if (savedRegisters[reg].initialStateSaved)
+        savedRegisters[reg] = initialState.savedRegisters[reg];
+      // else the register still holds its initial state
+    }
   };
 
   struct PrologInfoStackEntry {
@@ -96,29 +133,45 @@ public:
     PrologInfo info;
   };
 
+  struct RememberStack {
+    PrologInfoStackEntry *entry;
+    RememberStack() : entry(nullptr) {}
+    ~RememberStack() {
+#if defined(_LIBUNWIND_REMEMBER_CLEANUP_NEEDED)
+      // Clean up rememberStack. Even in the case where every
+      // DW_CFA_remember_state is paired with a DW_CFA_restore_state,
+      // parseInstructions can skip restore opcodes if it reaches the target PC
+      // and stops interpreting, so we have to make sure we don't leak memory.
+      while (entry) {
+        PrologInfoStackEntry *next = entry->next;
+        _LIBUNWIND_REMEMBER_FREE(entry);
+        entry = next;
+      }
+#endif
+    }
+  };
+
   static bool findFDE(A &addressSpace, pint_t pc, pint_t ehSectionStart,
-                      uint32_t sectionLength, pint_t fdeHint, FDE_Info *fdeInfo,
+                      size_t sectionLength, pint_t fdeHint, FDE_Info *fdeInfo,
                       CIE_Info *cieInfo);
   static const char *decodeFDE(A &addressSpace, pint_t fdeStart,
-                               FDE_Info *fdeInfo, CIE_Info *cieInfo);
+                               FDE_Info *fdeInfo, CIE_Info *cieInfo,
+                               bool useCIEInfo = false);
   static bool parseFDEInstructions(A &addressSpace, const FDE_Info &fdeInfo,
                                    const CIE_Info &cieInfo, pint_t upToPC,
-                                   PrologInfo *results);
+                                   int arch, PrologInfo *results);
 
   static const char *parseCIE(A &addressSpace, pint_t cie, CIE_Info *cieInfo);
-
-private:
-  static bool parseInstructions(A &addressSpace, pint_t instructions,
-                                pint_t instructionsEnd, const CIE_Info &cieInfo,
-                                pint_t pcoffset,
-                                PrologInfoStackEntry *&rememberStack,
-                                PrologInfo *results);
 };
 
-/// Parse a FDE into a CIE_Info and an FDE_Info
+/// Parse a FDE into a CIE_Info and an FDE_Info. If useCIEInfo is
+/// true, treat cieInfo as already-parsed CIE_Info (whose start offset
+/// must match the one specified by the FDE) rather than parsing the
+/// one indicated within the FDE.
 template <typename A>
 const char *CFI_Parser<A>::decodeFDE(A &addressSpace, pint_t fdeStart,
-                                     FDE_Info *fdeInfo, CIE_Info *cieInfo) {
+                                     FDE_Info *fdeInfo, CIE_Info *cieInfo,
+                                     bool useCIEInfo) {
   pint_t p = fdeStart;
   pint_t cfiLength = (pint_t)addressSpace.get32(p);
   p += 4;
@@ -128,15 +181,20 @@ const char *CFI_Parser<A>::decodeFDE(A &addressSpace, pint_t fdeStart,
     p += 8;
   }
   if (cfiLength == 0)
-    return "FDE has zero length"; // end marker
+    return "FDE has zero length"; // zero terminator
   uint32_t ciePointer = addressSpace.get32(p);
   if (ciePointer == 0)
     return "FDE is really a CIE"; // this is a CIE not an FDE
   pint_t nextCFI = p + cfiLength;
   pint_t cieStart = p - ciePointer;
-  const char *err = parseCIE(addressSpace, cieStart, cieInfo);
-  if (err != NULL)
-    return err;
+  if (useCIEInfo) {
+    if (cieInfo->cieStart != cieStart)
+      return "CIE start does not match";
+  } else {
+    const char *err = parseCIE(addressSpace, cieStart, cieInfo);
+    if (err != NULL)
+      return err;
+  }
   p += 4;
   // Parse pc begin and range.
   pint_t pcStart =
@@ -173,11 +231,13 @@ const char *CFI_Parser<A>::decodeFDE(A &addressSpace, pint_t fdeStart,
 /// Scan an eh_frame section to find an FDE for a pc
 template <typename A>
 bool CFI_Parser<A>::findFDE(A &addressSpace, pint_t pc, pint_t ehSectionStart,
-                            uint32_t sectionLength, pint_t fdeHint,
+                            size_t sectionLength, pint_t fdeHint,
                             FDE_Info *fdeInfo, CIE_Info *cieInfo) {
   //fprintf(stderr, "findFDE(0x%llX)\n", (long long)pc);
   pint_t p = (fdeHint != 0) ? fdeHint : ehSectionStart;
-  const pint_t ehSectionEnd = p + sectionLength;
+  const pint_t ehSectionEnd = (sectionLength == SIZE_MAX)
+                                  ? static_cast<pint_t>(-1)
+                                  : (ehSectionStart + sectionLength);
   while (p < ehSectionEnd) {
     pint_t currentCFI = p;
     //fprintf(stderr, "findFDE() CFI at 0x%llX\n", (long long)p);
@@ -189,7 +249,7 @@ bool CFI_Parser<A>::findFDE(A &addressSpace, pint_t pc, pint_t ehSectionStart,
       p += 8;
     }
     if (cfiLength == 0)
-      return false; // end marker
+      return false; // zero terminator
     uint32_t id = addressSpace.get32(p);
     if (id == 0) {
       // Skip over CIEs.
@@ -263,6 +323,9 @@ const char *CFI_Parser<A>::parseCIE(A &addressSpace, pint_t cie,
   cieInfo->dataAlignFactor = 0;
   cieInfo->isSignalFrame = false;
   cieInfo->fdesHaveAugmentationData = false;
+#if defined(_LIBUNWIND_TARGET_AARCH64)
+  cieInfo->addressesSignedWithBKey = false;
+#endif
   cieInfo->cieStart = cie;
   pint_t p = cie;
   pint_t cieLength = (pint_t)addressSpace.get32(p);
@@ -295,7 +358,8 @@ const char *CFI_Parser<A>::parseCIE(A &addressSpace, pint_t cie,
   // parse data alignment factor
   cieInfo->dataAlignFactor = (int)addressSpace.getSLEB128(p, cieContentEnd);
   // parse return address register
-  uint64_t raReg = addressSpace.getULEB128(p, cieContentEnd);
+  uint64_t raReg = (version == 1) ? addressSpace.get8(p++)
+                                  : addressSpace.getULEB128(p, cieContentEnd);
   assert(raReg < 255 && "return address register too large");
   cieInfo->returnAddressRegister = (uint8_t)raReg;
   // parse augmentation data based on augmentation string
@@ -326,6 +390,11 @@ const char *CFI_Parser<A>::parseCIE(A &addressSpace, pint_t cie,
       case 'S':
         cieInfo->isSignalFrame = true;
         break;
+#if defined(_LIBUNWIND_TARGET_AARCH64)
+      case 'B':
+        cieInfo->addressesSignedWithBKey = true;
+        break;
+#endif
       default:
         // ignore unknown letters
         break;
@@ -343,365 +412,434 @@ template <typename A>
 bool CFI_Parser<A>::parseFDEInstructions(A &addressSpace,
                                          const FDE_Info &fdeInfo,
                                          const CIE_Info &cieInfo, pint_t upToPC,
-                                         PrologInfo *results) {
-  // clear results
-  memset(results, '\0', sizeof(PrologInfo));
-  PrologInfoStackEntry *rememberStack = NULL;
-
-  // parse CIE then FDE instructions
-  return parseInstructions(addressSpace, cieInfo.cieInstructions,
-                           cieInfo.cieStart + cieInfo.cieLength, cieInfo,
-                           (pint_t)(-1), rememberStack, results) &&
-         parseInstructions(addressSpace, fdeInfo.fdeInstructions,
-                           fdeInfo.fdeStart + fdeInfo.fdeLength, cieInfo,
-                           upToPC - fdeInfo.pcStart, rememberStack, results);
-}
+                                         int arch, PrologInfo *results) {
+  // Alloca is used for the allocation of the rememberStack entries. It removes
+  // the dependency on new/malloc but the below for loop can not be refactored
+  // into functions. Entry could be saved during the processing of a CIE and
+  // restored by an FDE.
+  RememberStack rememberStack;
 
-/// "run" the DWARF instructions
-template <typename A>
-bool CFI_Parser<A>::parseInstructions(A &addressSpace, pint_t instructions,
-                                      pint_t instructionsEnd,
-                                      const CIE_Info &cieInfo, pint_t pcoffset,
-                                      PrologInfoStackEntry *&rememberStack,
-                                      PrologInfo *results) {
-  pint_t p = instructions;
-  pint_t codeOffset = 0;
-  PrologInfo initialState = *results;
-
-  _LIBUNWIND_TRACE_DWARF("parseInstructions(instructions=0x%0" PRIx64 ")\n",
-                         static_cast<uint64_t>(instructionsEnd));
-
-  // see DWARF Spec, section 6.4.2 for details on unwind opcodes
-  while ((p < instructionsEnd) && (codeOffset < pcoffset)) {
-    uint64_t reg;
-    uint64_t reg2;
-    int64_t offset;
-    uint64_t length;
-    uint8_t opcode = addressSpace.get8(p);
-    uint8_t operand;
-    PrologInfoStackEntry *entry;
-    ++p;
-    switch (opcode) {
-    case DW_CFA_nop:
-      _LIBUNWIND_TRACE_DWARF("DW_CFA_nop\n");
-      break;
-    case DW_CFA_set_loc:
-      codeOffset =
-          addressSpace.getEncodedP(p, instructionsEnd, cieInfo.pointerEncoding);
-      _LIBUNWIND_TRACE_DWARF("DW_CFA_set_loc\n");
-      break;
-    case DW_CFA_advance_loc1:
-      codeOffset += (addressSpace.get8(p) * cieInfo.codeAlignFactor);
-      p += 1;
-      _LIBUNWIND_TRACE_DWARF("DW_CFA_advance_loc1: new offset=%" PRIu64 "\n",
-                             static_cast<uint64_t>(codeOffset));
-      break;
-    case DW_CFA_advance_loc2:
-      codeOffset += (addressSpace.get16(p) * cieInfo.codeAlignFactor);
-      p += 2;
-      _LIBUNWIND_TRACE_DWARF("DW_CFA_advance_loc2: new offset=%" PRIu64 "\n",
-                             static_cast<uint64_t>(codeOffset));
-      break;
-    case DW_CFA_advance_loc4:
-      codeOffset += (addressSpace.get32(p) * cieInfo.codeAlignFactor);
-      p += 4;
-      _LIBUNWIND_TRACE_DWARF("DW_CFA_advance_loc4: new offset=%" PRIu64 "\n",
-                             static_cast<uint64_t>(codeOffset));
-      break;
-    case DW_CFA_offset_extended:
-      reg = addressSpace.getULEB128(p, instructionsEnd);
-      offset = (int64_t)addressSpace.getULEB128(p, instructionsEnd)
-                                                  * cieInfo.dataAlignFactor;
-      if (reg > kMaxRegisterNumber) {
-        _LIBUNWIND_LOG0(
-                "malformed DW_CFA_offset_extended DWARF unwind, reg too big");
-        return false;
-      }
-      results->savedRegisters[reg].location = kRegisterInCFA;
-      results->savedRegisters[reg].value = offset;
-      _LIBUNWIND_TRACE_DWARF("DW_CFA_offset_extended(reg=%" PRIu64 ", "
-                             "offset=%" PRId64 ")\n",
-                             reg, offset);
-      break;
-    case DW_CFA_restore_extended:
-      reg = addressSpace.getULEB128(p, instructionsEnd);
-      if (reg > kMaxRegisterNumber) {
-        _LIBUNWIND_LOG0(
-            "malformed DW_CFA_restore_extended DWARF unwind, reg too big");
-        return false;
-      }
-      results->savedRegisters[reg] = initialState.savedRegisters[reg];
-      _LIBUNWIND_TRACE_DWARF("DW_CFA_restore_extended(reg=%" PRIu64 ")\n", reg);
-      break;
-    case DW_CFA_undefined:
-      reg = addressSpace.getULEB128(p, instructionsEnd);
-      if (reg > kMaxRegisterNumber) {
-        _LIBUNWIND_LOG0(
-                "malformed DW_CFA_undefined DWARF unwind, reg too big");
-        return false;
-      }
-      results->savedRegisters[reg].location = kRegisterUnused;
-      _LIBUNWIND_TRACE_DWARF("DW_CFA_undefined(reg=%" PRIu64 ")\n", reg);
-      break;
-    case DW_CFA_same_value:
-      reg = addressSpace.getULEB128(p, instructionsEnd);
-      if (reg > kMaxRegisterNumber) {
-        _LIBUNWIND_LOG0(
-                "malformed DW_CFA_same_value DWARF unwind, reg too big");
-        return false;
-      }
-      // <rdar://problem/8456377> DW_CFA_same_value unsupported
-      // "same value" means register was stored in frame, but its current
-      // value has not changed, so no need to restore from frame.
-      // We model this as if the register was never saved.
-      results->savedRegisters[reg].location = kRegisterUnused;
-      // set flag to disable conversion to compact unwind
-      results->sameValueUsed = true;
-      _LIBUNWIND_TRACE_DWARF("DW_CFA_same_value(reg=%" PRIu64 ")\n", reg);
-      break;
-    case DW_CFA_register:
-      reg = addressSpace.getULEB128(p, instructionsEnd);
-      reg2 = addressSpace.getULEB128(p, instructionsEnd);
-      if (reg > kMaxRegisterNumber) {
-        _LIBUNWIND_LOG0(
-                "malformed DW_CFA_register DWARF unwind, reg too big");
-        return false;
-      }
-      if (reg2 > kMaxRegisterNumber) {
-        _LIBUNWIND_LOG0(
-                "malformed DW_CFA_register DWARF unwind, reg2 too big");
-        return false;
-      }
-      results->savedRegisters[reg].location = kRegisterInRegister;
-      results->savedRegisters[reg].value = (int64_t)reg2;
-      // set flag to disable conversion to compact unwind
-      results->registersInOtherRegisters = true;
-      _LIBUNWIND_TRACE_DWARF(
-          "DW_CFA_register(reg=%" PRIu64 ", reg2=%" PRIu64 ")\n", reg, reg2);
-      break;
-    case DW_CFA_remember_state:
-      entry = (PrologInfoStackEntry *)alloca(sizeof(PrologInfoStackEntry));
-      if (entry != NULL) {
-        entry->next = rememberStack;
-        entry->info = *results;
-        rememberStack = entry;
-      } else {
-        return false;
-      }
-      _LIBUNWIND_TRACE_DWARF("DW_CFA_remember_state\n");
-      break;
-    case DW_CFA_restore_state:
-      if (rememberStack != NULL) {
-        PrologInfoStackEntry *top = rememberStack;
-        *results = top->info;
-        rememberStack = top->next;
-      } else {
-        return false;
-      }
-      _LIBUNWIND_TRACE_DWARF("DW_CFA_restore_state\n");
-      break;
-    case DW_CFA_def_cfa:
-      reg = addressSpace.getULEB128(p, instructionsEnd);
-      offset = (int64_t)addressSpace.getULEB128(p, instructionsEnd);
-      if (reg > kMaxRegisterNumber) {
-        _LIBUNWIND_LOG0("malformed DW_CFA_def_cfa DWARF unwind, reg too big");
-        return false;
-      }
-      results->cfaRegister = (uint32_t)reg;
-      results->cfaRegisterOffset = (int32_t)offset;
-      _LIBUNWIND_TRACE_DWARF(
-          "DW_CFA_def_cfa(reg=%" PRIu64 ", offset=%" PRIu64 ")\n", reg, offset);
-      break;
-    case DW_CFA_def_cfa_register:
-      reg = addressSpace.getULEB128(p, instructionsEnd);
-      if (reg > kMaxRegisterNumber) {
-        _LIBUNWIND_LOG0(
-            "malformed DW_CFA_def_cfa_register DWARF unwind, reg too big");
-        return false;
-      }
-      results->cfaRegister = (uint32_t)reg;
-      _LIBUNWIND_TRACE_DWARF("DW_CFA_def_cfa_register(%" PRIu64 ")\n", reg);
-      break;
-    case DW_CFA_def_cfa_offset:
-      results->cfaRegisterOffset = (int32_t)
-                                  addressSpace.getULEB128(p, instructionsEnd);
-      results->codeOffsetAtStackDecrement = (uint32_t)codeOffset;
-      _LIBUNWIND_TRACE_DWARF("DW_CFA_def_cfa_offset(%d)\n",
-                             results->cfaRegisterOffset);
-      break;
-    case DW_CFA_def_cfa_expression:
-      results->cfaRegister = 0;
-      results->cfaExpression = (int64_t)p;
-      length = addressSpace.getULEB128(p, instructionsEnd);
-      assert(length < static_cast<pint_t>(~0) && "pointer overflow");
-      p += static_cast<pint_t>(length);
-      _LIBUNWIND_TRACE_DWARF("DW_CFA_def_cfa_expression(expression=0x%" PRIx64
-                             ", length=%" PRIu64 ")\n",
-                             results->cfaExpression, length);
-      break;
-    case DW_CFA_expression:
-      reg = addressSpace.getULEB128(p, instructionsEnd);
-      if (reg > kMaxRegisterNumber) {
-        _LIBUNWIND_LOG0(
-                "malformed DW_CFA_expression DWARF unwind, reg too big");
-        return false;
-      }
-      results->savedRegisters[reg].location = kRegisterAtExpression;
-      results->savedRegisters[reg].value = (int64_t)p;
-      length = addressSpace.getULEB128(p, instructionsEnd);
-      assert(length < static_cast<pint_t>(~0) && "pointer overflow");
-      p += static_cast<pint_t>(length);
-      _LIBUNWIND_TRACE_DWARF("DW_CFA_expression(reg=%" PRIu64 ", "
-                             "expression=0x%" PRIx64 ", "
-                             "length=%" PRIu64 ")\n",
-                             reg, results->savedRegisters[reg].value, length);
-      break;
-    case DW_CFA_offset_extended_sf:
-      reg = addressSpace.getULEB128(p, instructionsEnd);
-      if (reg > kMaxRegisterNumber) {
-        _LIBUNWIND_LOG0(
-            "malformed DW_CFA_offset_extended_sf DWARF unwind, reg too big");
-        return false;
-      }
-      offset =
-          addressSpace.getSLEB128(p, instructionsEnd) * cieInfo.dataAlignFactor;
-      results->savedRegisters[reg].location = kRegisterInCFA;
-      results->savedRegisters[reg].value = offset;
-      _LIBUNWIND_TRACE_DWARF("DW_CFA_offset_extended_sf(reg=%" PRIu64 ", "
-                             "offset=%" PRId64 ")\n",
-                             reg, offset);
-      break;
-    case DW_CFA_def_cfa_sf:
-      reg = addressSpace.getULEB128(p, instructionsEnd);
-      offset =
-          addressSpace.getSLEB128(p, instructionsEnd) * cieInfo.dataAlignFactor;
-      if (reg > kMaxRegisterNumber) {
-        _LIBUNWIND_LOG0(
-                "malformed DW_CFA_def_cfa_sf DWARF unwind, reg too big");
-        return false;
-      }
-      results->cfaRegister = (uint32_t)reg;
-      results->cfaRegisterOffset = (int32_t)offset;
-      _LIBUNWIND_TRACE_DWARF("DW_CFA_def_cfa_sf(reg=%" PRIu64 ", "
-                             "offset=%" PRId64 ")\n",
-                             reg, offset);
-      break;
-    case DW_CFA_def_cfa_offset_sf:
-      results->cfaRegisterOffset = (int32_t)
-        (addressSpace.getSLEB128(p, instructionsEnd) * cieInfo.dataAlignFactor);
-      results->codeOffsetAtStackDecrement = (uint32_t)codeOffset;
-      _LIBUNWIND_TRACE_DWARF("DW_CFA_def_cfa_offset_sf(%d)\n",
-                             results->cfaRegisterOffset);
-      break;
-    case DW_CFA_val_offset:
-      reg = addressSpace.getULEB128(p, instructionsEnd);
-      if (reg > kMaxRegisterNumber) {
-        _LIBUNWIND_LOG(
-                "malformed DW_CFA_val_offset DWARF unwind, reg (%" PRIu64
-                ") out of range\n",
-                reg);
-        return false;
-      }
-      offset = (int64_t)addressSpace.getULEB128(p, instructionsEnd)
-                                                    * cieInfo.dataAlignFactor;
-      results->savedRegisters[reg].location = kRegisterOffsetFromCFA;
-      results->savedRegisters[reg].value = offset;
-      _LIBUNWIND_TRACE_DWARF("DW_CFA_val_offset(reg=%" PRIu64 ", "
-                             "offset=%" PRId64 "\n",
-                             reg, offset);
-      break;
-    case DW_CFA_val_offset_sf:
-      reg = addressSpace.getULEB128(p, instructionsEnd);
-      if (reg > kMaxRegisterNumber) {
-        _LIBUNWIND_LOG0(
-                "malformed DW_CFA_val_offset_sf DWARF unwind, reg too big");
-        return false;
-      }
-      offset =
-          addressSpace.getSLEB128(p, instructionsEnd) * cieInfo.dataAlignFactor;
-      results->savedRegisters[reg].location = kRegisterOffsetFromCFA;
-      results->savedRegisters[reg].value = offset;
-      _LIBUNWIND_TRACE_DWARF("DW_CFA_val_offset_sf(reg=%" PRIu64 ", "
-                             "offset=%" PRId64 "\n",
-                             reg, offset);
-      break;
-    case DW_CFA_val_expression:
-      reg = addressSpace.getULEB128(p, instructionsEnd);
-      if (reg > kMaxRegisterNumber) {
-        _LIBUNWIND_LOG0(
-                "malformed DW_CFA_val_expression DWARF unwind, reg too big");
-        return false;
-      }
-      results->savedRegisters[reg].location = kRegisterIsExpression;
-      results->savedRegisters[reg].value = (int64_t)p;
-      length = addressSpace.getULEB128(p, instructionsEnd);
-      assert(length < static_cast<pint_t>(~0) && "pointer overflow");
-      p += static_cast<pint_t>(length);
-      _LIBUNWIND_TRACE_DWARF("DW_CFA_val_expression(reg=%" PRIu64 ", "
-                             "expression=0x%" PRIx64 ", length=%" PRIu64 ")\n",
-                             reg, results->savedRegisters[reg].value, length);
-      break;
-    case DW_CFA_GNU_args_size:
-      length = addressSpace.getULEB128(p, instructionsEnd);
-      results->spExtraArgSize = (uint32_t)length;
-      _LIBUNWIND_TRACE_DWARF("DW_CFA_GNU_args_size(%" PRIu64 ")\n", length);
-      break;
-    case DW_CFA_GNU_negative_offset_extended:
-      reg = addressSpace.getULEB128(p, instructionsEnd);
-      if (reg > kMaxRegisterNumber) {
-        _LIBUNWIND_LOG0("malformed DW_CFA_GNU_negative_offset_extended DWARF "
-                        "unwind, reg too big");
-        return false;
+  struct ParseInfo {
+    pint_t instructions;
+    pint_t instructionsEnd;
+    pint_t pcoffset;
+  };
+
+  ParseInfo parseInfoArray[] = {
+      {cieInfo.cieInstructions, cieInfo.cieStart + cieInfo.cieLength,
+       (pint_t)(-1)},
+      {fdeInfo.fdeInstructions, fdeInfo.fdeStart + fdeInfo.fdeLength,
+       upToPC - fdeInfo.pcStart}};
+
+  for (const auto &info : parseInfoArray) {
+    pint_t p = info.instructions;
+    pint_t instructionsEnd = info.instructionsEnd;
+    pint_t pcoffset = info.pcoffset;
+    pint_t codeOffset = 0;
+
+    // initialState initialized as registers in results are modified. Use
+    // PrologInfo accessor functions to avoid reading uninitialized data.
+    PrologInfo initialState(PrologInfo::InitializeTime::kLazy);
+
+    _LIBUNWIND_TRACE_DWARF("parseFDEInstructions(instructions=0x%0" PRIx64
+                           ")\n",
+                           static_cast<uint64_t>(instructionsEnd));
+
+    // see DWARF Spec, section 6.4.2 for details on unwind opcodes
+    while ((p < instructionsEnd) && (codeOffset < pcoffset)) {
+      uint64_t reg;
+      uint64_t reg2;
+      int64_t offset;
+      uint64_t length;
+      uint8_t opcode = addressSpace.get8(p);
+      uint8_t operand;
+
+      ++p;
+      switch (opcode) {
+      case DW_CFA_nop:
+        _LIBUNWIND_TRACE_DWARF("DW_CFA_nop\n");
+        break;
+      case DW_CFA_set_loc:
+        codeOffset = addressSpace.getEncodedP(p, instructionsEnd,
+                                              cieInfo.pointerEncoding);
+        _LIBUNWIND_TRACE_DWARF("DW_CFA_set_loc\n");
+        break;
+      case DW_CFA_advance_loc1:
+        codeOffset += (addressSpace.get8(p) * cieInfo.codeAlignFactor);
+        p += 1;
+        _LIBUNWIND_TRACE_DWARF("DW_CFA_advance_loc1: new offset=%" PRIu64 "\n",
+                               static_cast<uint64_t>(codeOffset));
+        break;
+      case DW_CFA_advance_loc2:
+        codeOffset += (addressSpace.get16(p) * cieInfo.codeAlignFactor);
+        p += 2;
+        _LIBUNWIND_TRACE_DWARF("DW_CFA_advance_loc2: new offset=%" PRIu64 "\n",
+                               static_cast<uint64_t>(codeOffset));
+        break;
+      case DW_CFA_advance_loc4:
+        codeOffset += (addressSpace.get32(p) * cieInfo.codeAlignFactor);
+        p += 4;
+        _LIBUNWIND_TRACE_DWARF("DW_CFA_advance_loc4: new offset=%" PRIu64 "\n",
+                               static_cast<uint64_t>(codeOffset));
+        break;
+      case DW_CFA_offset_extended:
+        reg = addressSpace.getULEB128(p, instructionsEnd);
+        offset = (int64_t)addressSpace.getULEB128(p, instructionsEnd) *
+                 cieInfo.dataAlignFactor;
+        if (reg > kMaxRegisterNumber) {
+          _LIBUNWIND_LOG0(
+              "malformed DW_CFA_offset_extended DWARF unwind, reg too big");
+          return false;
+        }
+        results->setRegister(reg, kRegisterInCFA, offset, initialState);
+        _LIBUNWIND_TRACE_DWARF("DW_CFA_offset_extended(reg=%" PRIu64 ", "
+                               "offset=%" PRId64 ")\n",
+                               reg, offset);
+        break;
+      case DW_CFA_restore_extended:
+        reg = addressSpace.getULEB128(p, instructionsEnd);
+        if (reg > kMaxRegisterNumber) {
+          _LIBUNWIND_LOG0(
+              "malformed DW_CFA_restore_extended DWARF unwind, reg too big");
+          return false;
+        }
+        results->restoreRegisterToInitialState(reg, initialState);
+        _LIBUNWIND_TRACE_DWARF("DW_CFA_restore_extended(reg=%" PRIu64 ")\n",
+                               reg);
+        break;
+      case DW_CFA_undefined:
+        reg = addressSpace.getULEB128(p, instructionsEnd);
+        if (reg > kMaxRegisterNumber) {
+          _LIBUNWIND_LOG0(
+              "malformed DW_CFA_undefined DWARF unwind, reg too big");
+          return false;
+        }
+        results->setRegisterLocation(reg, kRegisterUndefined, initialState);
+        _LIBUNWIND_TRACE_DWARF("DW_CFA_undefined(reg=%" PRIu64 ")\n", reg);
+        break;
+      case DW_CFA_same_value:
+        reg = addressSpace.getULEB128(p, instructionsEnd);
+        if (reg > kMaxRegisterNumber) {
+          _LIBUNWIND_LOG0(
+              "malformed DW_CFA_same_value DWARF unwind, reg too big");
+          return false;
+        }
+        // <rdar://problem/8456377> DW_CFA_same_value unsupported
+        // "same value" means register was stored in frame, but its current
+        // value has not changed, so no need to restore from frame.
+        // We model this as if the register was never saved.
+        results->setRegisterLocation(reg, kRegisterUnused, initialState);
+        _LIBUNWIND_TRACE_DWARF("DW_CFA_same_value(reg=%" PRIu64 ")\n", reg);
+        break;
+      case DW_CFA_register:
+        reg = addressSpace.getULEB128(p, instructionsEnd);
+        reg2 = addressSpace.getULEB128(p, instructionsEnd);
+        if (reg > kMaxRegisterNumber) {
+          _LIBUNWIND_LOG0(
+              "malformed DW_CFA_register DWARF unwind, reg too big");
+          return false;
+        }
+        if (reg2 > kMaxRegisterNumber) {
+          _LIBUNWIND_LOG0(
+              "malformed DW_CFA_register DWARF unwind, reg2 too big");
+          return false;
+        }
+        results->setRegister(reg, kRegisterInRegister, (int64_t)reg2,
+                             initialState);
+        _LIBUNWIND_TRACE_DWARF(
+            "DW_CFA_register(reg=%" PRIu64 ", reg2=%" PRIu64 ")\n", reg, reg2);
+        break;
+      case DW_CFA_remember_state: {
+        // Avoid operator new because that would be an upward dependency.
+        // Avoid malloc because it needs heap allocation.
+        PrologInfoStackEntry *entry =
+            (PrologInfoStackEntry *)_LIBUNWIND_REMEMBER_ALLOC(
+                sizeof(PrologInfoStackEntry));
+        if (entry != NULL) {
+          entry->next = rememberStack.entry;
+          entry->info = *results;
+          rememberStack.entry = entry;
+        } else {
+          return false;
+        }
+        _LIBUNWIND_TRACE_DWARF("DW_CFA_remember_state\n");
+        break;
       }
-      offset = (int64_t)addressSpace.getULEB128(p, instructionsEnd)
-                                                    * cieInfo.dataAlignFactor;
-      results->savedRegisters[reg].location = kRegisterInCFA;
-      results->savedRegisters[reg].value = -offset;
-      _LIBUNWIND_TRACE_DWARF(
-          "DW_CFA_GNU_negative_offset_extended(%" PRId64 ")\n", offset);
-      break;
-    default:
-      operand = opcode & 0x3F;
-      switch (opcode & 0xC0) {
-      case DW_CFA_offset:
-        reg = operand;
+      case DW_CFA_restore_state:
+        if (rememberStack.entry != NULL) {
+          PrologInfoStackEntry *top = rememberStack.entry;
+          *results = top->info;
+          rememberStack.entry = top->next;
+          _LIBUNWIND_REMEMBER_FREE(top);
+        } else {
+          return false;
+        }
+        _LIBUNWIND_TRACE_DWARF("DW_CFA_restore_state\n");
+        break;
+      case DW_CFA_def_cfa:
+        reg = addressSpace.getULEB128(p, instructionsEnd);
+        offset = (int64_t)addressSpace.getULEB128(p, instructionsEnd);
         if (reg > kMaxRegisterNumber) {
-          _LIBUNWIND_LOG("malformed DW_CFA_offset DWARF unwind, reg (%" PRIu64
-                         ") out of range",
-                  reg);
+          _LIBUNWIND_LOG0("malformed DW_CFA_def_cfa DWARF unwind, reg too big");
           return false;
         }
-        offset = (int64_t)addressSpace.getULEB128(p, instructionsEnd)
-                                                    * cieInfo.dataAlignFactor;
-        results->savedRegisters[reg].location = kRegisterInCFA;
-        results->savedRegisters[reg].value = offset;
-        _LIBUNWIND_TRACE_DWARF("DW_CFA_offset(reg=%d, offset=%" PRId64 ")\n",
-                               operand, offset);
-        break;
-      case DW_CFA_advance_loc:
-        codeOffset += operand * cieInfo.codeAlignFactor;
-        _LIBUNWIND_TRACE_DWARF("DW_CFA_advance_loc: new offset=%" PRIu64 "\n",
-                               static_cast<uint64_t>(codeOffset));
+        results->cfaRegister = (uint32_t)reg;
+        results->cfaRegisterOffset = (int32_t)offset;
+        _LIBUNWIND_TRACE_DWARF("DW_CFA_def_cfa(reg=%" PRIu64 ", offset=%" PRIu64
+                               ")\n",
+                               reg, offset);
+        break;
+      case DW_CFA_def_cfa_register:
+        reg = addressSpace.getULEB128(p, instructionsEnd);
+        if (reg > kMaxRegisterNumber) {
+          _LIBUNWIND_LOG0(
+              "malformed DW_CFA_def_cfa_register DWARF unwind, reg too big");
+          return false;
+        }
+        results->cfaRegister = (uint32_t)reg;
+        _LIBUNWIND_TRACE_DWARF("DW_CFA_def_cfa_register(%" PRIu64 ")\n", reg);
+        break;
+      case DW_CFA_def_cfa_offset:
+        results->cfaRegisterOffset =
+            (int32_t)addressSpace.getULEB128(p, instructionsEnd);
+        _LIBUNWIND_TRACE_DWARF("DW_CFA_def_cfa_offset(%d)\n",
+                               results->cfaRegisterOffset);
+        break;
+      case DW_CFA_def_cfa_expression:
+        results->cfaRegister = 0;
+        results->cfaExpression = (int64_t)p;
+        length = addressSpace.getULEB128(p, instructionsEnd);
+        assert(length < static_cast<pint_t>(~0) && "pointer overflow");
+        p += static_cast<pint_t>(length);
+        _LIBUNWIND_TRACE_DWARF("DW_CFA_def_cfa_expression(expression=0x%" PRIx64
+                               ", length=%" PRIu64 ")\n",
+                               results->cfaExpression, length);
+        break;
+      case DW_CFA_expression:
+        reg = addressSpace.getULEB128(p, instructionsEnd);
+        if (reg > kMaxRegisterNumber) {
+          _LIBUNWIND_LOG0(
+              "malformed DW_CFA_expression DWARF unwind, reg too big");
+          return false;
+        }
+        results->setRegister(reg, kRegisterAtExpression, (int64_t)p,
+                             initialState);
+        length = addressSpace.getULEB128(p, instructionsEnd);
+        assert(length < static_cast<pint_t>(~0) && "pointer overflow");
+        p += static_cast<pint_t>(length);
+        _LIBUNWIND_TRACE_DWARF("DW_CFA_expression(reg=%" PRIu64 ", "
+                               "expression=0x%" PRIx64 ", "
+                               "length=%" PRIu64 ")\n",
+                               reg, results->savedRegisters[reg].value, length);
+        break;
+      case DW_CFA_offset_extended_sf:
+        reg = addressSpace.getULEB128(p, instructionsEnd);
+        if (reg > kMaxRegisterNumber) {
+          _LIBUNWIND_LOG0(
+              "malformed DW_CFA_offset_extended_sf DWARF unwind, reg too big");
+          return false;
+        }
+        offset = addressSpace.getSLEB128(p, instructionsEnd) *
+                 cieInfo.dataAlignFactor;
+        results->setRegister(reg, kRegisterInCFA, offset, initialState);
+        _LIBUNWIND_TRACE_DWARF("DW_CFA_offset_extended_sf(reg=%" PRIu64 ", "
+                               "offset=%" PRId64 ")\n",
+                               reg, offset);
+        break;
+      case DW_CFA_def_cfa_sf:
+        reg = addressSpace.getULEB128(p, instructionsEnd);
+        offset = addressSpace.getSLEB128(p, instructionsEnd) *
+                 cieInfo.dataAlignFactor;
+        if (reg > kMaxRegisterNumber) {
+          _LIBUNWIND_LOG0(
+              "malformed DW_CFA_def_cfa_sf DWARF unwind, reg too big");
+          return false;
+        }
+        results->cfaRegister = (uint32_t)reg;
+        results->cfaRegisterOffset = (int32_t)offset;
+        _LIBUNWIND_TRACE_DWARF("DW_CFA_def_cfa_sf(reg=%" PRIu64 ", "
+                               "offset=%" PRId64 ")\n",
+                               reg, offset);
+        break;
+      case DW_CFA_def_cfa_offset_sf:
+        results->cfaRegisterOffset =
+            (int32_t)(addressSpace.getSLEB128(p, instructionsEnd) *
+                      cieInfo.dataAlignFactor);
+        _LIBUNWIND_TRACE_DWARF("DW_CFA_def_cfa_offset_sf(%d)\n",
+                               results->cfaRegisterOffset);
         break;
-      case DW_CFA_restore:
-        reg = operand;
+      case DW_CFA_val_offset:
+        reg = addressSpace.getULEB128(p, instructionsEnd);
         if (reg > kMaxRegisterNumber) {
-          _LIBUNWIND_LOG("malformed DW_CFA_restore DWARF unwind, reg (%" PRIu64
-                         ") out of range",
-                  reg);
+          _LIBUNWIND_LOG(
+              "malformed DW_CFA_val_offset DWARF unwind, reg (%" PRIu64
+              ") out of range\n",
+              reg);
           return false;
         }
-        results->savedRegisters[reg] = initialState.savedRegisters[reg];
-        _LIBUNWIND_TRACE_DWARF("DW_CFA_restore(reg=%" PRIu64 ")\n",
-                               static_cast<uint64_t>(operand));
+        offset = (int64_t)addressSpace.getULEB128(p, instructionsEnd) *
+                 cieInfo.dataAlignFactor;
+        results->setRegister(reg, kRegisterOffsetFromCFA, offset, initialState);
+        _LIBUNWIND_TRACE_DWARF("DW_CFA_val_offset(reg=%" PRIu64 ", "
+                               "offset=%" PRId64 "\n",
+                               reg, offset);
+        break;
+      case DW_CFA_val_offset_sf:
+        reg = addressSpace.getULEB128(p, instructionsEnd);
+        if (reg > kMaxRegisterNumber) {
+          _LIBUNWIND_LOG0(
+              "malformed DW_CFA_val_offset_sf DWARF unwind, reg too big");
+          return false;
+        }
+        offset = addressSpace.getSLEB128(p, instructionsEnd) *
+                 cieInfo.dataAlignFactor;
+        results->setRegister(reg, kRegisterOffsetFromCFA, offset, initialState);
+        _LIBUNWIND_TRACE_DWARF("DW_CFA_val_offset_sf(reg=%" PRIu64 ", "
+                               "offset=%" PRId64 "\n",
+                               reg, offset);
+        break;
+      case DW_CFA_val_expression:
+        reg = addressSpace.getULEB128(p, instructionsEnd);
+        if (reg > kMaxRegisterNumber) {
+          _LIBUNWIND_LOG0(
+              "malformed DW_CFA_val_expression DWARF unwind, reg too big");
+          return false;
+        }
+        results->setRegister(reg, kRegisterIsExpression, (int64_t)p,
+                             initialState);
+        length = addressSpace.getULEB128(p, instructionsEnd);
+        assert(length < static_cast<pint_t>(~0) && "pointer overflow");
+        p += static_cast<pint_t>(length);
+        _LIBUNWIND_TRACE_DWARF("DW_CFA_val_expression(reg=%" PRIu64 ", "
+                               "expression=0x%" PRIx64 ", length=%" PRIu64
+                               ")\n",
+                               reg, results->savedRegisters[reg].value, length);
+        break;
+      case DW_CFA_GNU_args_size:
+        length = addressSpace.getULEB128(p, instructionsEnd);
+        results->spExtraArgSize = (uint32_t)length;
+        _LIBUNWIND_TRACE_DWARF("DW_CFA_GNU_args_size(%" PRIu64 ")\n", length);
+        break;
+      case DW_CFA_GNU_negative_offset_extended:
+        reg = addressSpace.getULEB128(p, instructionsEnd);
+        if (reg > kMaxRegisterNumber) {
+          _LIBUNWIND_LOG0("malformed DW_CFA_GNU_negative_offset_extended DWARF "
+                          "unwind, reg too big");
+          return false;
+        }
+        offset = (int64_t)addressSpace.getULEB128(p, instructionsEnd) *
+                 cieInfo.dataAlignFactor;
+        results->setRegister(reg, kRegisterInCFA, -offset, initialState);
+        _LIBUNWIND_TRACE_DWARF(
+            "DW_CFA_GNU_negative_offset_extended(%" PRId64 ")\n", offset);
+        break;
+
+#if defined(_LIBUNWIND_TARGET_AARCH64) || defined(_LIBUNWIND_TARGET_SPARC) || \
+    defined(_LIBUNWIND_TARGET_SPARC64)
+        // The same constant is used to represent different instructions on
+        // AArch64 (negate_ra_state) and SPARC (window_save).
+        static_assert(DW_CFA_AARCH64_negate_ra_state == DW_CFA_GNU_window_save,
+                      "uses the same constant");
+      case DW_CFA_AARCH64_negate_ra_state:
+        switch (arch) {
+#if defined(_LIBUNWIND_TARGET_AARCH64)
+        case REGISTERS_ARM64: {
+          int64_t value =
+              results->savedRegisters[UNW_AARCH64_RA_SIGN_STATE].value ^ 0x1;
+          results->setRegisterValue(UNW_AARCH64_RA_SIGN_STATE, value,
+                                    initialState);
+          _LIBUNWIND_TRACE_DWARF("DW_CFA_AARCH64_negate_ra_state\n");
+        } break;
+#endif
+
+#if defined(_LIBUNWIND_TARGET_SPARC)
+        // case DW_CFA_GNU_window_save:
+        case REGISTERS_SPARC:
+          _LIBUNWIND_TRACE_DWARF("DW_CFA_GNU_window_save()\n");
+          for (reg = UNW_SPARC_O0; reg <= UNW_SPARC_O7; reg++) {
+            results->setRegister(reg, kRegisterInRegister,
+                                 ((int64_t)reg - UNW_SPARC_O0) + UNW_SPARC_I0,
+                                 initialState);
+          }
+
+          for (reg = UNW_SPARC_L0; reg <= UNW_SPARC_I7; reg++) {
+            results->setRegister(reg, kRegisterInCFA,
+                                 ((int64_t)reg - UNW_SPARC_L0) * 4,
+                                 initialState);
+          }
+          break;
+#endif
+
+#if defined(_LIBUNWIND_TARGET_SPARC64)
+        // case DW_CFA_GNU_window_save:
+        case REGISTERS_SPARC64:
+          // Don't save %o0-%o7 on sparc64.
+          // https://reviews.llvm.org/D32450#736405
+
+          for (reg = UNW_SPARC_L0; reg <= UNW_SPARC_I7; reg++) {
+            if (reg == UNW_SPARC_I7)
+              results->setRegister(
+                  reg, kRegisterInCFADecrypt,
+                  static_cast<int64_t>((reg - UNW_SPARC_L0) * sizeof(pint_t)),
+                  initialState);
+            else
+              results->setRegister(
+                  reg, kRegisterInCFA,
+                  static_cast<int64_t>((reg - UNW_SPARC_L0) * sizeof(pint_t)),
+                  initialState);
+          }
+          _LIBUNWIND_TRACE_DWARF("DW_CFA_GNU_window_save\n");
+          break;
+#endif
+        }
         break;
+
+#else
+        (void)arch;
+#endif
+
       default:
-        _LIBUNWIND_TRACE_DWARF("unknown CFA opcode 0x%02X\n", opcode);
-        return false;
+        operand = opcode & 0x3F;
+        switch (opcode & 0xC0) {
+        case DW_CFA_offset:
+          reg = operand;
+          if (reg > kMaxRegisterNumber) {
+            _LIBUNWIND_LOG("malformed DW_CFA_offset DWARF unwind, reg (%" PRIu64
+                           ") out of range",
+                           reg);
+            return false;
+          }
+          offset = (int64_t)addressSpace.getULEB128(p, instructionsEnd) *
+                   cieInfo.dataAlignFactor;
+          results->setRegister(reg, kRegisterInCFA, offset, initialState);
+          _LIBUNWIND_TRACE_DWARF("DW_CFA_offset(reg=%d, offset=%" PRId64 ")\n",
+                                 operand, offset);
+          break;
+        case DW_CFA_advance_loc:
+          codeOffset += operand * cieInfo.codeAlignFactor;
+          _LIBUNWIND_TRACE_DWARF("DW_CFA_advance_loc: new offset=%" PRIu64 "\n",
+                                 static_cast<uint64_t>(codeOffset));
+          break;
+        case DW_CFA_restore:
+          reg = operand;
+          if (reg > kMaxRegisterNumber) {
+            _LIBUNWIND_LOG(
+                "malformed DW_CFA_restore DWARF unwind, reg (%" PRIu64
+                ") out of range",
+                reg);
+            return false;
+          }
+          results->restoreRegisterToInitialState(reg, initialState);
+          _LIBUNWIND_TRACE_DWARF("DW_CFA_restore(reg=%" PRIu64 ")\n",
+                                 static_cast<uint64_t>(operand));
+          break;
+        default:
+          _LIBUNWIND_TRACE_DWARF("unknown CFA opcode 0x%02X\n", opcode);
+          return false;
+        }
       }
     }
   }
-
   return true;
 }
 
diff --git a/WAVM/ThirdParty/libunwind/src/EHHeaderParser.hpp b/WAVM/ThirdParty/libunwind/src/EHHeaderParser.hpp
index 9bdaf550..9a38070f 100644
--- a/WAVM/ThirdParty/libunwind/src/EHHeaderParser.hpp
+++ b/WAVM/ThirdParty/libunwind/src/EHHeaderParser.hpp
@@ -1,9 +1,8 @@
-//===------------------------- EHHeaderParser.hpp -------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
+//===----------------------------------------------------------------------===//
 //
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //
 //  Parses ELF .eh_frame_hdr sections.
@@ -36,7 +35,7 @@ public:
     uint8_t table_enc;
   };
 
-  static void decodeEHHdr(A &addressSpace, pint_t ehHdrStart, pint_t ehHdrEnd,
+  static bool decodeEHHdr(A &addressSpace, pint_t ehHdrStart, pint_t ehHdrEnd,
                           EHHeaderInfo &ehHdrInfo);
   static bool findFDE(A &addressSpace, pint_t pc, pint_t ehHdrStart,
                       uint32_t sectionLength,
@@ -53,12 +52,14 @@ private:
 };
 
 template <typename A>
-void EHHeaderParser<A>::decodeEHHdr(A &addressSpace, pint_t ehHdrStart,
+bool EHHeaderParser<A>::decodeEHHdr(A &addressSpace, pint_t ehHdrStart,
                                     pint_t ehHdrEnd, EHHeaderInfo &ehHdrInfo) {
   pint_t p = ehHdrStart;
   uint8_t version = addressSpace.get8(p++);
-  if (version != 1)
-    _LIBUNWIND_ABORT("Unsupported .eh_frame_hdr version");
+  if (version != 1) {
+    _LIBUNWIND_LOG0("Unsupported .eh_frame_hdr version");
+    return false;
+  }
 
   uint8_t eh_frame_ptr_enc = addressSpace.get8(p++);
   uint8_t fde_count_enc = addressSpace.get8(p++);
@@ -71,6 +72,8 @@ void EHHeaderParser<A>::decodeEHHdr(A &addressSpace, pint_t ehHdrStart,
           ? 0
           : addressSpace.getEncodedP(p, ehHdrEnd, fde_count_enc, ehHdrStart);
   ehHdrInfo.table = p;
+
+  return true;
 }
 
 template <typename A>
@@ -102,7 +105,11 @@ bool EHHeaderParser<A>::findFDE(A &addressSpace, pint_t pc, pint_t ehHdrStart,
   pint_t ehHdrEnd = ehHdrStart + sectionLength;
 
   EHHeaderParser<A>::EHHeaderInfo hdrInfo;
-  EHHeaderParser<A>::decodeEHHdr(addressSpace, ehHdrStart, ehHdrEnd, hdrInfo);
+  if (!EHHeaderParser<A>::decodeEHHdr(addressSpace, ehHdrStart, ehHdrEnd,
+                                      hdrInfo))
+    return false;
+
+  if (hdrInfo.fde_count == 0) return false;
 
   size_t tableEntrySize = getTableEntrySize(hdrInfo.table_enc);
   pint_t tableEntry;
diff --git a/WAVM/ThirdParty/libunwind/src/FrameHeaderCache.hpp b/WAVM/ThirdParty/libunwind/src/FrameHeaderCache.hpp
new file mode 100644
index 00000000..54d5d33c
--- /dev/null
+++ b/WAVM/ThirdParty/libunwind/src/FrameHeaderCache.hpp
@@ -0,0 +1,149 @@
+//===-FrameHeaderCache.hpp ------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+// Cache the elf program headers necessary to unwind the stack more efficiently
+// in the presence of many dsos.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef __FRAMEHEADER_CACHE_HPP__
+#define __FRAMEHEADER_CACHE_HPP__
+
+#include "config.h"
+#include <limits.h>
+
+#ifdef _LIBUNWIND_DEBUG_FRAMEHEADER_CACHE
+#define _LIBUNWIND_FRAMEHEADERCACHE_TRACE0(x) _LIBUNWIND_LOG0(x)
+#define _LIBUNWIND_FRAMEHEADERCACHE_TRACE(msg, ...)                            \
+  _LIBUNWIND_LOG(msg, __VA_ARGS__)
+#else
+#define _LIBUNWIND_FRAMEHEADERCACHE_TRACE0(x)
+#define _LIBUNWIND_FRAMEHEADERCACHE_TRACE(msg, ...)
+#endif
+
+// This cache should only be be used from within a dl_iterate_phdr callback.
+// dl_iterate_phdr does the necessary synchronization to prevent problems
+// with concurrent access via the libc load lock. Adding synchronization
+// for other uses is possible, but not currently done.
+
+class _LIBUNWIND_HIDDEN FrameHeaderCache {
+  struct CacheEntry {
+    uintptr_t LowPC() { return Info.dso_base; };
+    uintptr_t HighPC() { return Info.dso_base + Info.text_segment_length; };
+    UnwindInfoSections Info;
+    CacheEntry *Next;
+  };
+
+  static const size_t kCacheEntryCount = 8;
+
+  // Can't depend on the C++ standard library in libunwind, so use an array to
+  // allocate the entries, and two linked lists for ordering unused and recently
+  // used entries.  FIXME: Would the the extra memory for a doubly-linked list
+  // be better than the runtime cost of traversing a very short singly-linked
+  // list on a cache miss? The entries themselves are all small and consecutive,
+  // so unlikely to cause page faults when following the pointers. The memory
+  // spent on additional pointers could also be spent on more entries.
+
+  CacheEntry Entries[kCacheEntryCount];
+  CacheEntry *MostRecentlyUsed;
+  CacheEntry *Unused;
+
+  void resetCache() {
+    _LIBUNWIND_FRAMEHEADERCACHE_TRACE0("FrameHeaderCache reset");
+    MostRecentlyUsed = nullptr;
+    Unused = &Entries[0];
+    for (size_t i = 0; i < kCacheEntryCount - 1; i++) {
+      Entries[i].Next = &Entries[i + 1];
+    }
+    Entries[kCacheEntryCount - 1].Next = nullptr;
+  }
+
+  bool cacheNeedsReset(dl_phdr_info *PInfo) {
+    // C libraries increment dl_phdr_info.adds and dl_phdr_info.subs when
+    // loading and unloading shared libraries. If these values change between
+    // iterations of dl_iterate_phdr, then invalidate the cache.
+
+    // These are static to avoid needing an initializer, and unsigned long long
+    // because that is their type within the extended dl_phdr_info.  Initialize
+    // these to something extremely unlikely to be found upon the first call to
+    // dl_iterate_phdr.
+    static unsigned long long LastAdds = ULLONG_MAX;
+    static unsigned long long LastSubs = ULLONG_MAX;
+    if (PInfo->dlpi_adds != LastAdds || PInfo->dlpi_subs != LastSubs) {
+      // Resetting the entire cache is a big hammer, but this path is rare--
+      // usually just on the very first call, when the cache is empty anyway--so
+      // added complexity doesn't buy much.
+      LastAdds = PInfo->dlpi_adds;
+      LastSubs = PInfo->dlpi_subs;
+      resetCache();
+      return true;
+    }
+    return false;
+  }
+
+public:
+  bool find(dl_phdr_info *PInfo, size_t, void *data) {
+    if (cacheNeedsReset(PInfo) || MostRecentlyUsed == nullptr)
+      return false;
+
+    auto *CBData = static_cast<dl_iterate_cb_data *>(data);
+    CacheEntry *Current = MostRecentlyUsed;
+    CacheEntry *Previous = nullptr;
+    while (Current != nullptr) {
+      _LIBUNWIND_FRAMEHEADERCACHE_TRACE(
+          "FrameHeaderCache check %lx in [%lx - %lx)", CBData->targetAddr,
+          Current->LowPC(), Current->HighPC());
+      if (Current->LowPC() <= CBData->targetAddr &&
+          CBData->targetAddr < Current->HighPC()) {
+        _LIBUNWIND_FRAMEHEADERCACHE_TRACE(
+            "FrameHeaderCache hit %lx in [%lx - %lx)", CBData->targetAddr,
+            Current->LowPC(), Current->HighPC());
+        if (Previous) {
+          // If there is no Previous, then Current is already the
+          // MostRecentlyUsed, and no need to move it up.
+          Previous->Next = Current->Next;
+          Current->Next = MostRecentlyUsed;
+          MostRecentlyUsed = Current;
+        }
+        *CBData->sects = Current->Info;
+        return true;
+      }
+      Previous = Current;
+      Current = Current->Next;
+    }
+    _LIBUNWIND_FRAMEHEADERCACHE_TRACE("FrameHeaderCache miss for address %lx",
+                                      CBData->targetAddr);
+    return false;
+  }
+
+  void add(const UnwindInfoSections *UIS) {
+    CacheEntry *Current = nullptr;
+
+    if (Unused != nullptr) {
+      Current = Unused;
+      Unused = Unused->Next;
+    } else {
+      Current = MostRecentlyUsed;
+      CacheEntry *Previous = nullptr;
+      while (Current->Next != nullptr) {
+        Previous = Current;
+        Current = Current->Next;
+      }
+      Previous->Next = nullptr;
+      _LIBUNWIND_FRAMEHEADERCACHE_TRACE("FrameHeaderCache evict [%lx - %lx)",
+                                        Current->LowPC(), Current->HighPC());
+    }
+
+    Current->Info = *UIS;
+    Current->Next = MostRecentlyUsed;
+    MostRecentlyUsed = Current;
+    _LIBUNWIND_FRAMEHEADERCACHE_TRACE("FrameHeaderCache add [%lx - %lx)",
+                                      MostRecentlyUsed->LowPC(),
+                                      MostRecentlyUsed->HighPC());
+  }
+};
+
+#endif // __FRAMEHEADER_CACHE_HPP__
diff --git a/WAVM/ThirdParty/libunwind/src/RWMutex.hpp b/WAVM/ThirdParty/libunwind/src/RWMutex.hpp
index 50a78a57..344d3564 100644
--- a/WAVM/ThirdParty/libunwind/src/RWMutex.hpp
+++ b/WAVM/ThirdParty/libunwind/src/RWMutex.hpp
@@ -1,9 +1,8 @@
-//===----------------------------- Registers.hpp --------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
+//===----------------------------------------------------------------------===//
 //
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //
 // Abstract interface to shared reader/writer log, hiding platform and
@@ -18,6 +17,9 @@
 #include <windows.h>
 #elif !defined(_LIBUNWIND_HAS_NO_THREADS)
 #include <pthread.h>
+#if defined(__ELF__) && defined(_LIBUNWIND_LINK_PTHREAD_LIB)
+#pragma comment(lib, "pthread")
+#endif
 #endif
 
 namespace libunwind {
@@ -57,11 +59,11 @@ private:
   SRWLOCK _lock = SRWLOCK_INIT;
 };
 
-#else
+#elif !defined(LIBUNWIND_USE_WEAK_PTHREAD)
 
 class _LIBUNWIND_HIDDEN RWMutex {
 public:
-  bool lock_shared() { return pthread_rwlock_rdlock(&_lock) == 0; }
+  bool lock_shared() { return pthread_rwlock_rdlock(&_lock) == 0;  }
   bool unlock_shared() { return pthread_rwlock_unlock(&_lock) == 0; }
   bool lock() { return pthread_rwlock_wrlock(&_lock) == 0; }
   bool unlock() { return pthread_rwlock_unlock(&_lock) == 0; }
@@ -70,6 +72,41 @@ private:
   pthread_rwlock_t _lock = PTHREAD_RWLOCK_INITIALIZER;
 };
 
+#else
+
+extern "C" int __attribute__((weak))
+pthread_create(pthread_t *thread, const pthread_attr_t *attr,
+               void *(*start_routine)(void *), void *arg);
+extern "C" int __attribute__((weak))
+pthread_rwlock_rdlock(pthread_rwlock_t *lock);
+extern "C" int __attribute__((weak))
+pthread_rwlock_wrlock(pthread_rwlock_t *lock);
+extern "C" int __attribute__((weak))
+pthread_rwlock_unlock(pthread_rwlock_t *lock);
+
+// Calls to the locking functions are gated on pthread_create, and not the
+// functions themselves, because the data structure should only be locked if
+// another thread has been created. This is what similar libraries do.
+
+class _LIBUNWIND_HIDDEN RWMutex {
+public:
+  bool lock_shared() {
+    return !pthread_create || (pthread_rwlock_rdlock(&_lock) == 0);
+  }
+  bool unlock_shared() {
+    return !pthread_create || (pthread_rwlock_unlock(&_lock) == 0);
+  }
+  bool lock() {
+    return !pthread_create || (pthread_rwlock_wrlock(&_lock) == 0);
+  }
+  bool unlock() {
+    return !pthread_create || (pthread_rwlock_unlock(&_lock) == 0);
+  }
+
+private:
+  pthread_rwlock_t _lock = PTHREAD_RWLOCK_INITIALIZER;
+};
+
 #endif
 
 } // namespace libunwind
diff --git a/WAVM/ThirdParty/libunwind/src/Registers.hpp b/WAVM/ThirdParty/libunwind/src/Registers.hpp
index 922b7faa..cbc3876d 100644
--- a/WAVM/ThirdParty/libunwind/src/Registers.hpp
+++ b/WAVM/ThirdParty/libunwind/src/Registers.hpp
@@ -1,9 +1,8 @@
-//===----------------------------- Registers.hpp --------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
+//===----------------------------------------------------------------------===//
 //
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //
 //  Models register sets for supported processors.
@@ -16,16 +15,42 @@
 #include <stdint.h>
 #include <string.h>
 
-#include "libunwind.h"
+#include "cet_unwind.h"
 #include "config.h"
+#include "libunwind.h"
 
 namespace libunwind {
 
 // For emulating 128-bit registers
 struct v128 { uint32_t vec[4]; };
 
+enum {
+  REGISTERS_X86,
+  REGISTERS_X86_64,
+  REGISTERS_PPC,
+  REGISTERS_PPC64,
+  REGISTERS_ARM64,
+  REGISTERS_ARM,
+  REGISTERS_OR1K,
+  REGISTERS_MIPS_O32,
+  REGISTERS_MIPS_NEWABI,
+  REGISTERS_SPARC,
+  REGISTERS_SPARC64,
+  REGISTERS_HEXAGON,
+  REGISTERS_RISCV,
+  REGISTERS_VE,
+};
 
 #if defined(_LIBUNWIND_TARGET_I386)
+class _LIBUNWIND_HIDDEN Registers_x86;
+extern "C" void __libunwind_Registers_x86_jumpto(Registers_x86 *);
+
+#if defined(_LIBUNWIND_USE_CET)
+extern "C" void *__libunwind_cet_get_jump_target() {
+  return reinterpret_cast<void *>(&__libunwind_Registers_x86_jumpto);
+}
+#endif
+
 /// Registers_x86 holds the register state of a thread in a 32-bit intel
 /// process.
 class _LIBUNWIND_HIDDEN Registers_x86 {
@@ -42,9 +67,10 @@ public:
   bool        validVectorRegister(int) const { return false; }
   v128        getVectorRegister(int num) const;
   void        setVectorRegister(int num, v128 value);
-  const char *getRegisterName(int num);
-  void        jumpto();
+  static const char *getRegisterName(int num);
+  void        jumpto() { __libunwind_Registers_x86_jumpto(this); }
   static int  lastDwarfRegNum() { return _LIBUNWIND_HIGHEST_DWARF_REGISTER_X86; }
+  static int  getArch() { return REGISTERS_X86; }
 
   uint32_t  getSP() const          { return _registers.__esp; }
   void      setSP(uint32_t value)  { _registers.__esp = value; }
@@ -234,6 +260,15 @@ inline void Registers_x86::setVectorRegister(int, v128) {
 #if defined(_LIBUNWIND_TARGET_X86_64)
 /// Registers_x86_64  holds the register state of a thread in a 64-bit intel
 /// process.
+class _LIBUNWIND_HIDDEN Registers_x86_64;
+extern "C" void __libunwind_Registers_x86_64_jumpto(Registers_x86_64 *);
+
+#if defined(_LIBUNWIND_USE_CET)
+extern "C" void *__libunwind_cet_get_jump_target() {
+  return reinterpret_cast<void *>(&__libunwind_Registers_x86_64_jumpto);
+}
+#endif
+
 class _LIBUNWIND_HIDDEN Registers_x86_64 {
 public:
   Registers_x86_64();
@@ -248,9 +283,10 @@ public:
   bool        validVectorRegister(int) const;
   v128        getVectorRegister(int num) const;
   void        setVectorRegister(int num, v128 value);
-  const char *getRegisterName(int num);
-  void        jumpto();
+  static const char *getRegisterName(int num);
+  void        jumpto() { __libunwind_Registers_x86_64_jumpto(this); }
   static int  lastDwarfRegNum() { return _LIBUNWIND_HIGHEST_DWARF_REGISTER_X86_64; }
+  static int  getArch() { return REGISTERS_X86_64; }
 
   uint64_t  getSP() const          { return _registers.__rsp; }
   void      setSP(uint64_t value)  { _registers.__rsp = value; }
@@ -319,7 +355,7 @@ inline bool Registers_x86_64::validRegister(int regNum) const {
     return true;
   if (regNum < 0)
     return false;
-  if (regNum > 15)
+  if (regNum > 16)
     return false;
   return true;
 }
@@ -327,6 +363,7 @@ inline bool Registers_x86_64::validRegister(int regNum) const {
 inline uint64_t Registers_x86_64::getRegister(int regNum) const {
   switch (regNum) {
   case UNW_REG_IP:
+  case UNW_X86_64_RIP:
     return _registers.__rip;
   case UNW_REG_SP:
     return _registers.__rsp;
@@ -369,6 +406,7 @@ inline uint64_t Registers_x86_64::getRegister(int regNum) const {
 inline void Registers_x86_64::setRegister(int regNum, uint64_t value) {
   switch (regNum) {
   case UNW_REG_IP:
+  case UNW_X86_64_RIP:
     _registers.__rip = value;
     return;
   case UNW_REG_SP:
@@ -429,6 +467,7 @@ inline void Registers_x86_64::setRegister(int regNum, uint64_t value) {
 inline const char *Registers_x86_64::getRegisterName(int regNum) {
   switch (regNum) {
   case UNW_REG_IP:
+  case UNW_X86_64_RIP:
     return "rip";
   case UNW_REG_SP:
     return "rsp";
@@ -517,6 +556,7 @@ inline bool Registers_x86_64::validVectorRegister(int regNum) const {
     return false;
   return true;
 #else
+  (void)regNum; // suppress unused parameter warning
   return false;
 #endif
 }
@@ -526,6 +566,7 @@ inline v128 Registers_x86_64::getVectorRegister(int regNum) const {
   assert(validVectorRegister(regNum));
   return _xmm[regNum - UNW_X86_64_XMM0];
 #else
+  (void)regNum; // suppress unused parameter warning
   _LIBUNWIND_ABORT("no x86_64 vector registers");
 #endif
 }
@@ -535,6 +576,7 @@ inline void Registers_x86_64::setVectorRegister(int regNum, v128 value) {
   assert(validVectorRegister(regNum));
   _xmm[regNum - UNW_X86_64_XMM0] = value;
 #else
+  (void)regNum; (void)value; // suppress unused parameter warnings
   _LIBUNWIND_ABORT("no x86_64 vector registers");
 #endif
 }
@@ -558,9 +600,10 @@ public:
   bool        validVectorRegister(int num) const;
   v128        getVectorRegister(int num) const;
   void        setVectorRegister(int num, v128 value);
-  const char *getRegisterName(int num);
+  static const char *getRegisterName(int num);
   void        jumpto();
   static int  lastDwarfRegNum() { return _LIBUNWIND_HIGHEST_DWARF_REGISTER_PPC; }
+  static int  getArch() { return REGISTERS_PPC; }
 
   uint64_t  getSP() const         { return _registers.__r1; }
   void      setSP(uint32_t value) { _registers.__r1 = value; }
@@ -1123,9 +1166,10 @@ public:
   bool        validVectorRegister(int num) const;
   v128        getVectorRegister(int num) const;
   void        setVectorRegister(int num, v128 value);
-  const char *getRegisterName(int num);
+  static const char *getRegisterName(int num);
   void        jumpto();
   static int  lastDwarfRegNum() { return _LIBUNWIND_HIGHEST_DWARF_REGISTER_PPC64; }
+  static int  getArch() { return REGISTERS_PPC64; }
 
   uint64_t  getSP() const         { return _registers.__r1; }
   void      setSP(uint64_t value) { _registers.__r1 = value; }
@@ -1490,12 +1534,12 @@ inline void Registers_ppc64::setFloatRegister(int regNum, double value) {
 }
 
 inline bool Registers_ppc64::validVectorRegister(int regNum) const {
-#ifdef PPC64_HAS_VMX
+#if defined(__VSX__)
   if (regNum >= UNW_PPC64_VS0 && regNum <= UNW_PPC64_VS31)
     return true;
   if (regNum >= UNW_PPC64_VS32 && regNum <= UNW_PPC64_VS63)
     return true;
-#else
+#elif defined(__ALTIVEC__)
   if (regNum >= UNW_PPC64_V0 && regNum <= UNW_PPC64_V31)
     return true;
 #endif
@@ -1751,6 +1795,8 @@ inline const char *Registers_ppc64::getRegisterName(int regNum) {
 #if defined(_LIBUNWIND_TARGET_AARCH64)
 /// Registers_arm64  holds the register state of a thread in a 64-bit arm
 /// process.
+class _LIBUNWIND_HIDDEN Registers_arm64;
+extern "C" void __libunwind_Registers_arm64_jumpto(Registers_arm64 *);
 class _LIBUNWIND_HIDDEN Registers_arm64 {
 public:
   Registers_arm64();
@@ -1765,9 +1811,10 @@ public:
   bool        validVectorRegister(int num) const;
   v128        getVectorRegister(int num) const;
   void        setVectorRegister(int num, v128 value);
-  const char *getRegisterName(int num);
-  void        jumpto();
+  static const char *getRegisterName(int num);
+  void        jumpto() { __libunwind_Registers_arm64_jumpto(this); }
   static int  lastDwarfRegNum() { return _LIBUNWIND_HIGHEST_DWARF_REGISTER_ARM64; }
+  static int  getArch() { return REGISTERS_ARM64; }
 
   uint64_t  getSP() const         { return _registers.__sp; }
   void      setSP(uint64_t value) { _registers.__sp = value; }
@@ -1783,7 +1830,7 @@ private:
     uint64_t __lr;    // Link register x30
     uint64_t __sp;    // Stack pointer x31
     uint64_t __pc;    // Program counter
-    uint64_t padding; // 16-byte align
+    uint64_t __ra_sign_state; // RA sign state register
   };
 
   GPRs    _registers;
@@ -1819,27 +1866,41 @@ inline bool Registers_arm64::validRegister(int regNum) const {
     return false;
   if (regNum > 95)
     return false;
-  if ((regNum > 31) && (regNum < 64))
+  if (regNum == UNW_AARCH64_RA_SIGN_STATE)
+    return true;
+  if ((regNum > 32) && (regNum < 64))
     return false;
   return true;
 }
 
 inline uint64_t Registers_arm64::getRegister(int regNum) const {
-  if (regNum == UNW_REG_IP)
+  if (regNum == UNW_REG_IP || regNum == UNW_AARCH64_PC)
     return _registers.__pc;
-  if (regNum == UNW_REG_SP)
+  if (regNum == UNW_REG_SP || regNum == UNW_AARCH64_SP)
     return _registers.__sp;
-  if ((regNum >= 0) && (regNum < 32))
+  if (regNum == UNW_AARCH64_RA_SIGN_STATE)
+    return _registers.__ra_sign_state;
+  if (regNum == UNW_AARCH64_FP)
+    return _registers.__fp;
+  if (regNum == UNW_AARCH64_LR)
+    return _registers.__lr;
+  if ((regNum >= 0) && (regNum < 29))
     return _registers.__x[regNum];
   _LIBUNWIND_ABORT("unsupported arm64 register");
 }
 
 inline void Registers_arm64::setRegister(int regNum, uint64_t value) {
-  if (regNum == UNW_REG_IP)
+  if (regNum == UNW_REG_IP || regNum == UNW_AARCH64_PC)
     _registers.__pc = value;
-  else if (regNum == UNW_REG_SP)
+  else if (regNum == UNW_REG_SP || regNum == UNW_AARCH64_SP)
     _registers.__sp = value;
-  else if ((regNum >= 0) && (regNum < 32))
+  else if (regNum == UNW_AARCH64_RA_SIGN_STATE)
+    _registers.__ra_sign_state = value;
+  else if (regNum == UNW_AARCH64_FP)
+    _registers.__fp = value;
+  else if (regNum == UNW_AARCH64_LR)
+    _registers.__lr = value;
+  else if ((regNum >= 0) && (regNum < 29))
     _registers.__x[regNum] = value;
   else
     _LIBUNWIND_ABORT("unsupported arm64 register");
@@ -1851,133 +1912,135 @@ inline const char *Registers_arm64::getRegisterName(int regNum) {
     return "pc";
   case UNW_REG_SP:
     return "sp";
-  case UNW_ARM64_X0:
+  case UNW_AARCH64_X0:
     return "x0";
-  case UNW_ARM64_X1:
+  case UNW_AARCH64_X1:
     return "x1";
-  case UNW_ARM64_X2:
+  case UNW_AARCH64_X2:
     return "x2";
-  case UNW_ARM64_X3:
+  case UNW_AARCH64_X3:
     return "x3";
-  case UNW_ARM64_X4:
+  case UNW_AARCH64_X4:
     return "x4";
-  case UNW_ARM64_X5:
+  case UNW_AARCH64_X5:
     return "x5";
-  case UNW_ARM64_X6:
+  case UNW_AARCH64_X6:
     return "x6";
-  case UNW_ARM64_X7:
+  case UNW_AARCH64_X7:
     return "x7";
-  case UNW_ARM64_X8:
+  case UNW_AARCH64_X8:
     return "x8";
-  case UNW_ARM64_X9:
+  case UNW_AARCH64_X9:
     return "x9";
-  case UNW_ARM64_X10:
+  case UNW_AARCH64_X10:
     return "x10";
-  case UNW_ARM64_X11:
+  case UNW_AARCH64_X11:
     return "x11";
-  case UNW_ARM64_X12:
+  case UNW_AARCH64_X12:
     return "x12";
-  case UNW_ARM64_X13:
+  case UNW_AARCH64_X13:
     return "x13";
-  case UNW_ARM64_X14:
+  case UNW_AARCH64_X14:
     return "x14";
-  case UNW_ARM64_X15:
+  case UNW_AARCH64_X15:
     return "x15";
-  case UNW_ARM64_X16:
+  case UNW_AARCH64_X16:
     return "x16";
-  case UNW_ARM64_X17:
+  case UNW_AARCH64_X17:
     return "x17";
-  case UNW_ARM64_X18:
+  case UNW_AARCH64_X18:
     return "x18";
-  case UNW_ARM64_X19:
+  case UNW_AARCH64_X19:
     return "x19";
-  case UNW_ARM64_X20:
+  case UNW_AARCH64_X20:
     return "x20";
-  case UNW_ARM64_X21:
+  case UNW_AARCH64_X21:
     return "x21";
-  case UNW_ARM64_X22:
+  case UNW_AARCH64_X22:
     return "x22";
-  case UNW_ARM64_X23:
+  case UNW_AARCH64_X23:
     return "x23";
-  case UNW_ARM64_X24:
+  case UNW_AARCH64_X24:
     return "x24";
-  case UNW_ARM64_X25:
+  case UNW_AARCH64_X25:
     return "x25";
-  case UNW_ARM64_X26:
+  case UNW_AARCH64_X26:
     return "x26";
-  case UNW_ARM64_X27:
+  case UNW_AARCH64_X27:
     return "x27";
-  case UNW_ARM64_X28:
+  case UNW_AARCH64_X28:
     return "x28";
-  case UNW_ARM64_X29:
+  case UNW_AARCH64_FP:
     return "fp";
-  case UNW_ARM64_X30:
+  case UNW_AARCH64_LR:
     return "lr";
-  case UNW_ARM64_X31:
+  case UNW_AARCH64_SP:
     return "sp";
-  case UNW_ARM64_D0:
+  case UNW_AARCH64_PC:
+    return "pc";
+  case UNW_AARCH64_V0:
     return "d0";
-  case UNW_ARM64_D1:
+  case UNW_AARCH64_V1:
     return "d1";
-  case UNW_ARM64_D2:
+  case UNW_AARCH64_V2:
     return "d2";
-  case UNW_ARM64_D3:
+  case UNW_AARCH64_V3:
     return "d3";
-  case UNW_ARM64_D4:
+  case UNW_AARCH64_V4:
     return "d4";
-  case UNW_ARM64_D5:
+  case UNW_AARCH64_V5:
     return "d5";
-  case UNW_ARM64_D6:
+  case UNW_AARCH64_V6:
     return "d6";
-  case UNW_ARM64_D7:
+  case UNW_AARCH64_V7:
     return "d7";
-  case UNW_ARM64_D8:
+  case UNW_AARCH64_V8:
     return "d8";
-  case UNW_ARM64_D9:
+  case UNW_AARCH64_V9:
     return "d9";
-  case UNW_ARM64_D10:
+  case UNW_AARCH64_V10:
     return "d10";
-  case UNW_ARM64_D11:
+  case UNW_AARCH64_V11:
     return "d11";
-  case UNW_ARM64_D12:
+  case UNW_AARCH64_V12:
     return "d12";
-  case UNW_ARM64_D13:
+  case UNW_AARCH64_V13:
     return "d13";
-  case UNW_ARM64_D14:
+  case UNW_AARCH64_V14:
     return "d14";
-  case UNW_ARM64_D15:
+  case UNW_AARCH64_V15:
     return "d15";
-  case UNW_ARM64_D16:
+  case UNW_AARCH64_V16:
     return "d16";
-  case UNW_ARM64_D17:
+  case UNW_AARCH64_V17:
     return "d17";
-  case UNW_ARM64_D18:
+  case UNW_AARCH64_V18:
     return "d18";
-  case UNW_ARM64_D19:
+  case UNW_AARCH64_V19:
     return "d19";
-  case UNW_ARM64_D20:
+  case UNW_AARCH64_V20:
     return "d20";
-  case UNW_ARM64_D21:
+  case UNW_AARCH64_V21:
     return "d21";
-  case UNW_ARM64_D22:
+  case UNW_AARCH64_V22:
     return "d22";
-  case UNW_ARM64_D23:
+  case UNW_AARCH64_V23:
     return "d23";
-  case UNW_ARM64_D24:
+  case UNW_AARCH64_V24:
     return "d24";
-  case UNW_ARM64_D25:
+  case UNW_AARCH64_V25:
     return "d25";
-  case UNW_ARM64_D26:
+  case UNW_AARCH64_V26:
     return "d26";
-  case UNW_ARM64_D27:
+  case UNW_AARCH64_V27:
     return "d27";
-  case UNW_ARM64_D28:
+  case UNW_AARCH64_V28:
     return "d28";
-  case UNW_ARM64_D29:
+  case UNW_AARCH64_V29:
     return "d29";
-  case UNW_ARM64_D30:
+  case UNW_AARCH64_V30:
     return "d30";
-  case UNW_ARM64_D31:
+  case UNW_AARCH64_V31:
     return "d31";
   default:
     return "unknown register";
@@ -1985,21 +2048,21 @@ inline const char *Registers_arm64::getRegisterName(int regNum) {
 }
 
 inline bool Registers_arm64::validFloatRegister(int regNum) const {
-  if (regNum < UNW_ARM64_D0)
+  if (regNum < UNW_AARCH64_V0)
     return false;
-  if (regNum > UNW_ARM64_D31)
+  if (regNum > UNW_AARCH64_V31)
     return false;
   return true;
 }
 
 inline double Registers_arm64::getFloatRegister(int regNum) const {
   assert(validFloatRegister(regNum));
-  return _vectorHalfRegisters[regNum - UNW_ARM64_D0];
+  return _vectorHalfRegisters[regNum - UNW_AARCH64_V0];
 }
 
 inline void Registers_arm64::setFloatRegister(int regNum, double value) {
   assert(validFloatRegister(regNum));
-  _vectorHalfRegisters[regNum - UNW_ARM64_D0] = value;
+  _vectorHalfRegisters[regNum - UNW_AARCH64_V0] = value;
 }
 
 inline bool Registers_arm64::validVectorRegister(int) const {
@@ -2035,12 +2098,13 @@ public:
   bool        validVectorRegister(int num) const;
   v128        getVectorRegister(int num) const;
   void        setVectorRegister(int num, v128 value);
-  const char *getRegisterName(int num);
+  static const char *getRegisterName(int num);
   void        jumpto() {
     restoreSavedFloatRegisters();
     restoreCoreAndJumpTo();
   }
   static int  lastDwarfRegNum() { return _LIBUNWIND_HIGHEST_DWARF_REGISTER_ARM; }
+  static int  getArch() { return REGISTERS_ARM; }
 
   uint32_t  getSP() const         { return _registers.__sp; }
   void      setSP(uint32_t value) { _registers.__sp = value; }
@@ -2077,22 +2141,27 @@ private:
     uint32_t __pc;    // Program counter r15
   };
 
-  static void saveVFPWithFSTMD(unw_fpreg_t*);
-  static void saveVFPWithFSTMX(unw_fpreg_t*);
-  static void saveVFPv3(unw_fpreg_t*);
-  static void restoreVFPWithFLDMD(unw_fpreg_t*);
-  static void restoreVFPWithFLDMX(unw_fpreg_t*);
-  static void restoreVFPv3(unw_fpreg_t*);
+  struct PseudoRegisters {
+    uint32_t __pac; // Return Authentication Code (PAC)
+  };
+
+  static void saveVFPWithFSTMD(void*);
+  static void saveVFPWithFSTMX(void*);
+  static void saveVFPv3(void*);
+  static void restoreVFPWithFLDMD(void*);
+  static void restoreVFPWithFLDMX(void*);
+  static void restoreVFPv3(void*);
 #if defined(__ARM_WMMX)
-  static void saveiWMMX(unw_fpreg_t*);
+  static void saveiWMMX(void*);
   static void saveiWMMXControl(uint32_t*);
-  static void restoreiWMMX(unw_fpreg_t*);
+  static void restoreiWMMX(void*);
   static void restoreiWMMXControl(uint32_t*);
 #endif
   void restoreCoreAndJumpTo();
 
   // ARM registers
   GPRs _registers;
+  PseudoRegisters _pseudo_registers;
 
   // We save floating point registers lazily because we can't know ahead of
   // time which ones are used. See EHABI #4.7.
@@ -2128,8 +2197,9 @@ inline Registers_arm::Registers_arm(const void *registers)
     _saved_vfp_d16_d31(false) {
   static_assert((check_fit<Registers_arm, unw_context_t>::does_fit),
                 "arm registers do not fit into unw_context_t");
-  // See unw_getcontext() note about data.
+  // See __unw_getcontext() note about data.
   memcpy(&_registers, registers, sizeof(_registers));
+  memset(&_pseudo_registers, 0, sizeof(_pseudo_registers));
   memset(&_vfp_d0_d15_pad, 0, sizeof(_vfp_d0_d15_pad));
   memset(&_vfp_d16_d31, 0, sizeof(_vfp_d16_d31));
 #if defined(__ARM_WMMX)
@@ -2145,11 +2215,12 @@ inline Registers_arm::Registers_arm()
     _saved_vfp_d0_d15(false),
     _saved_vfp_d16_d31(false) {
   memset(&_registers, 0, sizeof(_registers));
+  memset(&_pseudo_registers, 0, sizeof(_pseudo_registers));
   memset(&_vfp_d0_d15_pad, 0, sizeof(_vfp_d0_d15_pad));
   memset(&_vfp_d16_d31, 0, sizeof(_vfp_d16_d31));
 #if defined(__ARM_WMMX)
   _saved_iwmmx = false;
-  _saved_iwmmx_control = false;  
+  _saved_iwmmx_control = false;
   memset(&_iwmmx, 0, sizeof(_iwmmx));
   memset(&_iwmmx_control, 0, sizeof(_iwmmx_control));
 #endif
@@ -2172,6 +2243,11 @@ inline bool Registers_arm::validRegister(int regNum) const {
     return true;
 #endif
 
+#ifdef __ARM_FEATURE_PAUTH
+  if (regNum == UNW_ARM_RA_AUTH_CODE)
+    return true;
+#endif
+
   return false;
 }
 
@@ -2198,6 +2274,11 @@ inline uint32_t Registers_arm::getRegister(int regNum) const {
   }
 #endif
 
+#ifdef __ARM_FEATURE_PAUTH
+  if (regNum == UNW_ARM_RA_AUTH_CODE)
+    return _pseudo_registers.__pac;
+#endif
+
   _LIBUNWIND_ABORT("unsupported arm register");
 }
 
@@ -2233,6 +2314,11 @@ inline void Registers_arm::setRegister(int regNum, uint32_t value) {
   }
 #endif
 
+  if (regNum == UNW_ARM_RA_AUTH_CODE) {
+    _pseudo_registers.__pac = value;
+    return;
+  }
+
   _LIBUNWIND_ABORT("unsupported arm register");
 }
 
@@ -2407,7 +2493,7 @@ inline const char *Registers_arm::getRegisterName(int regNum) {
 
 inline bool Registers_arm::validFloatRegister(int regNum) const {
   // NOTE: Consider the intel MMX registers floating points so the
-  // unw_get_fpreg can be used to transmit the 64-bit data back.
+  // __unw_get_fpreg can be used to transmit the 64-bit data back.
   return ((regNum >= UNW_ARM_D0) && (regNum <= UNW_ARM_D31))
 #if defined(__ARM_WMMX)
       || ((regNum >= UNW_ARM_WR0) && (regNum <= UNW_ARM_WR15))
@@ -2515,18 +2601,21 @@ public:
   bool        validVectorRegister(int num) const;
   v128        getVectorRegister(int num) const;
   void        setVectorRegister(int num, v128 value);
-  const char *getRegisterName(int num);
+  static const char *getRegisterName(int num);
   void        jumpto();
   static int  lastDwarfRegNum() { return _LIBUNWIND_HIGHEST_DWARF_REGISTER_OR1K; }
+  static int  getArch() { return REGISTERS_OR1K; }
 
   uint64_t  getSP() const         { return _registers.__r[1]; }
   void      setSP(uint32_t value) { _registers.__r[1] = value; }
-  uint64_t  getIP() const         { return _registers.__r[9]; }
-  void      setIP(uint32_t value) { _registers.__r[9] = value; }
+  uint64_t  getIP() const         { return _registers.__pc; }
+  void      setIP(uint32_t value) { _registers.__pc = value; }
 
 private:
   struct or1k_thread_state_t {
-    unsigned int __r[32];
+    unsigned int __r[32]; // r0-r31
+    unsigned int __pc;    // Program counter
+    unsigned int __epcr;  // Program counter at exception
   };
 
   or1k_thread_state_t _registers;
@@ -2552,6 +2641,8 @@ inline bool Registers_or1k::validRegister(int regNum) const {
     return false;
   if (regNum <= UNW_OR1K_R31)
     return true;
+  if (regNum == UNW_OR1K_EPCR)
+    return true;
   return false;
 }
 
@@ -2561,9 +2652,11 @@ inline uint32_t Registers_or1k::getRegister(int regNum) const {
 
   switch (regNum) {
   case UNW_REG_IP:
-    return _registers.__r[9];
+    return _registers.__pc;
   case UNW_REG_SP:
     return _registers.__r[1];
+  case UNW_OR1K_EPCR:
+    return _registers.__epcr;
   }
   _LIBUNWIND_ABORT("unsupported or1k register");
 }
@@ -2576,11 +2669,14 @@ inline void Registers_or1k::setRegister(int regNum, uint32_t value) {
 
   switch (regNum) {
   case UNW_REG_IP:
-    _registers.__r[9] = value;
+    _registers.__pc = value;
     return;
   case UNW_REG_SP:
     _registers.__r[1] = value;
     return;
+  case UNW_OR1K_EPCR:
+    _registers.__epcr = value;
+    return;
   }
   _LIBUNWIND_ABORT("unsupported or1k register");
 }
@@ -2676,6 +2772,8 @@ inline const char *Registers_or1k::getRegisterName(int regNum) {
     return "r30";
   case UNW_OR1K_R31:
     return "r31";
+  case UNW_OR1K_EPCR:
+    return "EPCR";
   default:
     return "unknown register";
   }
@@ -2700,9 +2798,10 @@ public:
   bool        validVectorRegister(int num) const;
   v128        getVectorRegister(int num) const;
   void        setVectorRegister(int num, v128 value);
-  const char *getRegisterName(int num);
+  static const char *getRegisterName(int num);
   void        jumpto();
   static int  lastDwarfRegNum() { return _LIBUNWIND_HIGHEST_DWARF_REGISTER_MIPS; }
+  static int  getArch() { return REGISTERS_MIPS_O32; }
 
   uint32_t  getSP() const         { return _registers.__r[29]; }
   void      setSP(uint32_t value) { _registers.__r[29] = value; }
@@ -2718,6 +2817,14 @@ private:
   };
 
   mips_o32_thread_state_t _registers;
+#ifdef __mips_hard_float
+  /// O32 with 32-bit floating point registers only uses half of this
+  /// space.  However, using the same layout for 32-bit vs 64-bit
+  /// floating point registers results in a single context size for
+  /// O32 with hard float.
+  uint32_t _padding;
+  double _floats[32];
+#endif
 };
 
 inline Registers_mips_o32::Registers_mips_o32(const void *registers) {
@@ -2740,17 +2847,34 @@ inline bool Registers_mips_o32::validRegister(int regNum) const {
     return false;
   if (regNum <= UNW_MIPS_R31)
     return true;
+#if __mips_isa_rev != 6
   if (regNum == UNW_MIPS_HI)
     return true;
   if (regNum == UNW_MIPS_LO)
     return true;
-  // FIXME: Hard float, DSP accumulator registers, MSA registers
+#endif
+#if defined(__mips_hard_float) && __mips_fpr == 32
+  if (regNum >= UNW_MIPS_F0 && regNum <= UNW_MIPS_F31)
+    return true;
+#endif
+  // FIXME: DSP accumulator registers, MSA registers
   return false;
 }
 
 inline uint32_t Registers_mips_o32::getRegister(int regNum) const {
   if (regNum >= UNW_MIPS_R0 && regNum <= UNW_MIPS_R31)
     return _registers.__r[regNum - UNW_MIPS_R0];
+#if defined(__mips_hard_float) && __mips_fpr == 32
+  if (regNum >= UNW_MIPS_F0 && regNum <= UNW_MIPS_F31) {
+    uint32_t *p;
+
+    if (regNum % 2 == 0)
+      p = (uint32_t *)&_floats[regNum - UNW_MIPS_F0];
+    else
+      p = (uint32_t *)&_floats[(regNum - 1) - UNW_MIPS_F0] + 1;
+    return *p;
+  }
+#endif
 
   switch (regNum) {
   case UNW_REG_IP:
@@ -2770,6 +2894,18 @@ inline void Registers_mips_o32::setRegister(int regNum, uint32_t value) {
     _registers.__r[regNum - UNW_MIPS_R0] = value;
     return;
   }
+#if defined(__mips_hard_float) && __mips_fpr == 32
+  if (regNum >= UNW_MIPS_F0 && regNum <= UNW_MIPS_F31) {
+    uint32_t *p;
+
+    if (regNum % 2 == 0)
+      p = (uint32_t *)&_floats[regNum - UNW_MIPS_F0];
+    else
+      p = (uint32_t *)&_floats[(regNum - 1) - UNW_MIPS_F0] + 1;
+    *p = value;
+    return;
+  }
+#endif
 
   switch (regNum) {
   case UNW_REG_IP:
@@ -2788,17 +2924,36 @@ inline void Registers_mips_o32::setRegister(int regNum, uint32_t value) {
   _LIBUNWIND_ABORT("unsupported mips_o32 register");
 }
 
-inline bool Registers_mips_o32::validFloatRegister(int /* regNum */) const {
+inline bool Registers_mips_o32::validFloatRegister(int regNum) const {
+#if defined(__mips_hard_float) && __mips_fpr == 64
+  if (regNum >= UNW_MIPS_F0 && regNum <= UNW_MIPS_F31)
+    return true;
+#else
+  (void)regNum;
+#endif
   return false;
 }
 
-inline double Registers_mips_o32::getFloatRegister(int /* regNum */) const {
+inline double Registers_mips_o32::getFloatRegister(int regNum) const {
+#if defined(__mips_hard_float) && __mips_fpr == 64
+  assert(validFloatRegister(regNum));
+  return _floats[regNum - UNW_MIPS_F0];
+#else
+  (void)regNum;
   _LIBUNWIND_ABORT("mips_o32 float support not implemented");
+#endif
 }
 
-inline void Registers_mips_o32::setFloatRegister(int /* regNum */,
-                                                 double /* value */) {
+inline void Registers_mips_o32::setFloatRegister(int regNum,
+                                                 double value) {
+#if defined(__mips_hard_float) && __mips_fpr == 64
+  assert(validFloatRegister(regNum));
+  _floats[regNum - UNW_MIPS_F0] = value;
+#else
+  (void)regNum;
+  (void)value;
   _LIBUNWIND_ABORT("mips_o32 float support not implemented");
+#endif
 }
 
 inline bool Registers_mips_o32::validVectorRegister(int /* regNum */) const {
@@ -2879,6 +3034,70 @@ inline const char *Registers_mips_o32::getRegisterName(int regNum) {
     return "$30";
   case UNW_MIPS_R31:
     return "$31";
+  case UNW_MIPS_F0:
+    return "$f0";
+  case UNW_MIPS_F1:
+    return "$f1";
+  case UNW_MIPS_F2:
+    return "$f2";
+  case UNW_MIPS_F3:
+    return "$f3";
+  case UNW_MIPS_F4:
+    return "$f4";
+  case UNW_MIPS_F5:
+    return "$f5";
+  case UNW_MIPS_F6:
+    return "$f6";
+  case UNW_MIPS_F7:
+    return "$f7";
+  case UNW_MIPS_F8:
+    return "$f8";
+  case UNW_MIPS_F9:
+    return "$f9";
+  case UNW_MIPS_F10:
+    return "$f10";
+  case UNW_MIPS_F11:
+    return "$f11";
+  case UNW_MIPS_F12:
+    return "$f12";
+  case UNW_MIPS_F13:
+    return "$f13";
+  case UNW_MIPS_F14:
+    return "$f14";
+  case UNW_MIPS_F15:
+    return "$f15";
+  case UNW_MIPS_F16:
+    return "$f16";
+  case UNW_MIPS_F17:
+    return "$f17";
+  case UNW_MIPS_F18:
+    return "$f18";
+  case UNW_MIPS_F19:
+    return "$f19";
+  case UNW_MIPS_F20:
+    return "$f20";
+  case UNW_MIPS_F21:
+    return "$f21";
+  case UNW_MIPS_F22:
+    return "$f22";
+  case UNW_MIPS_F23:
+    return "$f23";
+  case UNW_MIPS_F24:
+    return "$f24";
+  case UNW_MIPS_F25:
+    return "$f25";
+  case UNW_MIPS_F26:
+    return "$f26";
+  case UNW_MIPS_F27:
+    return "$f27";
+  case UNW_MIPS_F28:
+    return "$f28";
+  case UNW_MIPS_F29:
+    return "$f29";
+  case UNW_MIPS_F30:
+    return "$f30";
+  case UNW_MIPS_F31:
+    return "$f31";
   case UNW_MIPS_HI:
     return "$hi";
   case UNW_MIPS_LO:
@@ -2906,9 +3125,10 @@ public:
   bool        validVectorRegister(int num) const;
   v128        getVectorRegister(int num) const;
   void        setVectorRegister(int num, v128 value);
-  const char *getRegisterName(int num);
+  static const char *getRegisterName(int num);
   void        jumpto();
   static int  lastDwarfRegNum() { return _LIBUNWIND_HIGHEST_DWARF_REGISTER_MIPS; }
+  static int  getArch() { return REGISTERS_MIPS_NEWABI; }
 
   uint64_t  getSP() const         { return _registers.__r[29]; }
   void      setSP(uint64_t value) { _registers.__r[29] = value; }
@@ -2924,6 +3144,9 @@ private:
   };
 
   mips_newabi_thread_state_t _registers;
+#ifdef __mips_hard_float
+  double _floats[32];
+#endif
 };
 
 inline Registers_mips_newabi::Registers_mips_newabi(const void *registers) {
@@ -2946,10 +3169,12 @@ inline bool Registers_mips_newabi::validRegister(int regNum) const {
     return false;
   if (regNum <= UNW_MIPS_R31)
     return true;
+#if __mips_isa_rev != 6
   if (regNum == UNW_MIPS_HI)
     return true;
   if (regNum == UNW_MIPS_LO)
     return true;
+#endif
   // FIXME: Hard float, DSP accumulator registers, MSA registers
   return false;
 }
@@ -2994,17 +3219,36 @@ inline void Registers_mips_newabi::setRegister(int regNum, uint64_t value) {
   _LIBUNWIND_ABORT("unsupported mips_newabi register");
 }
 
-inline bool Registers_mips_newabi::validFloatRegister(int /* regNum */) const {
+inline bool Registers_mips_newabi::validFloatRegister(int regNum) const {
+#ifdef __mips_hard_float
+  if (regNum >= UNW_MIPS_F0 && regNum <= UNW_MIPS_F31)
+    return true;
+#else
+  (void)regNum;
+#endif
   return false;
 }
 
-inline double Registers_mips_newabi::getFloatRegister(int /* regNum */) const {
+inline double Registers_mips_newabi::getFloatRegister(int regNum) const {
+#ifdef __mips_hard_float
+  assert(validFloatRegister(regNum));
+  return _floats[regNum - UNW_MIPS_F0];
+#else
+  (void)regNum;
   _LIBUNWIND_ABORT("mips_newabi float support not implemented");
+#endif
 }
 
-inline void Registers_mips_newabi::setFloatRegister(int /* regNum */,
-                                                 double /* value */) {
+inline void Registers_mips_newabi::setFloatRegister(int regNum,
+                                                    double value) {
+#ifdef __mips_hard_float
+  assert(validFloatRegister(regNum));
+  _floats[regNum - UNW_MIPS_F0] = value;
+#else
+  (void)regNum;
+  (void)value;
   _LIBUNWIND_ABORT("mips_newabi float support not implemented");
+#endif
 }
 
 inline bool Registers_mips_newabi::validVectorRegister(int /* regNum */) const {
@@ -3085,6 +3329,70 @@ inline const char *Registers_mips_newabi::getRegisterName(int regNum) {
     return "$30";
   case UNW_MIPS_R31:
     return "$31";
+  case UNW_MIPS_F0:
+    return "$f0";
+  case UNW_MIPS_F1:
+    return "$f1";
+  case UNW_MIPS_F2:
+    return "$f2";
+  case UNW_MIPS_F3:
+    return "$f3";
+  case UNW_MIPS_F4:
+    return "$f4";
+  case UNW_MIPS_F5:
+    return "$f5";
+  case UNW_MIPS_F6:
+    return "$f6";
+  case UNW_MIPS_F7:
+    return "$f7";
+  case UNW_MIPS_F8:
+    return "$f8";
+  case UNW_MIPS_F9:
+    return "$f9";
+  case UNW_MIPS_F10:
+    return "$f10";
+  case UNW_MIPS_F11:
+    return "$f11";
+  case UNW_MIPS_F12:
+    return "$f12";
+  case UNW_MIPS_F13:
+    return "$f13";
+  case UNW_MIPS_F14:
+    return "$f14";
+  case UNW_MIPS_F15:
+    return "$f15";
+  case UNW_MIPS_F16:
+    return "$f16";
+  case UNW_MIPS_F17:
+    return "$f17";
+  case UNW_MIPS_F18:
+    return "$f18";
+  case UNW_MIPS_F19:
+    return "$f19";
+  case UNW_MIPS_F20:
+    return "$f20";
+  case UNW_MIPS_F21:
+    return "$f21";
+  case UNW_MIPS_F22:
+    return "$f22";
+  case UNW_MIPS_F23:
+    return "$f23";
+  case UNW_MIPS_F24:
+    return "$f24";
+  case UNW_MIPS_F25:
+    return "$f25";
+  case UNW_MIPS_F26:
+    return "$f26";
+  case UNW_MIPS_F27:
+    return "$f27";
+  case UNW_MIPS_F28:
+    return "$f28";
+  case UNW_MIPS_F29:
+    return "$f29";
+  case UNW_MIPS_F30:
+    return "$f30";
+  case UNW_MIPS_F31:
+    return "$f31";
   case UNW_MIPS_HI:
     return "$hi";
   case UNW_MIPS_LO:
@@ -3094,6 +3402,1316 @@ inline const char *Registers_mips_newabi::getRegisterName(int regNum) {
   }
 }
 #endif // _LIBUNWIND_TARGET_MIPS_NEWABI
+
+#if defined(_LIBUNWIND_TARGET_SPARC)
+/// Registers_sparc holds the register state of a thread in a 32-bit Sparc
+/// process.
+class _LIBUNWIND_HIDDEN Registers_sparc {
+public:
+  Registers_sparc();
+  Registers_sparc(const void *registers);
+
+  bool        validRegister(int num) const;
+  uint32_t    getRegister(int num) const;
+  void        setRegister(int num, uint32_t value);
+  bool        validFloatRegister(int num) const;
+  double      getFloatRegister(int num) const;
+  void        setFloatRegister(int num, double value);
+  bool        validVectorRegister(int num) const;
+  v128        getVectorRegister(int num) const;
+  void        setVectorRegister(int num, v128 value);
+  static const char *getRegisterName(int num);
+  void        jumpto();
+  static int  lastDwarfRegNum() { return _LIBUNWIND_HIGHEST_DWARF_REGISTER_SPARC; }
+  static int  getArch() { return REGISTERS_SPARC; }
+
+  uint64_t  getSP() const         { return _registers.__regs[UNW_SPARC_O6]; }
+  void      setSP(uint32_t value) { _registers.__regs[UNW_SPARC_O6] = value; }
+  uint64_t  getIP() const         { return _registers.__regs[UNW_SPARC_O7]; }
+  void      setIP(uint32_t value) { _registers.__regs[UNW_SPARC_O7] = value; }
+
+private:
+  struct sparc_thread_state_t {
+    unsigned int __regs[32];
+  };
+
+  sparc_thread_state_t _registers;
+};
+
+inline Registers_sparc::Registers_sparc(const void *registers) {
+  static_assert((check_fit<Registers_sparc, unw_context_t>::does_fit),
+                "sparc registers do not fit into unw_context_t");
+  memcpy(&_registers, static_cast<const uint8_t *>(registers),
+         sizeof(_registers));
+}
+
+inline Registers_sparc::Registers_sparc() {
+  memset(&_registers, 0, sizeof(_registers));
+}
+
+inline bool Registers_sparc::validRegister(int regNum) const {
+  if (regNum == UNW_REG_IP)
+    return true;
+  if (regNum == UNW_REG_SP)
+    return true;
+  if (regNum < 0)
+    return false;
+  if (regNum <= UNW_SPARC_I7)
+    return true;
+  return false;
+}
+
+inline uint32_t Registers_sparc::getRegister(int regNum) const {
+  if ((UNW_SPARC_G0 <= regNum) && (regNum <= UNW_SPARC_I7)) {
+    return _registers.__regs[regNum];
+  }
+
+  switch (regNum) {
+  case UNW_REG_IP:
+    return _registers.__regs[UNW_SPARC_O7];
+  case UNW_REG_SP:
+    return _registers.__regs[UNW_SPARC_O6];
+  }
+  _LIBUNWIND_ABORT("unsupported sparc register");
+}
+
+inline void Registers_sparc::setRegister(int regNum, uint32_t value) {
+  if ((UNW_SPARC_G0 <= regNum) && (regNum <= UNW_SPARC_I7)) {
+    _registers.__regs[regNum] = value;
+    return;
+  }
+
+  switch (regNum) {
+  case UNW_REG_IP:
+    _registers.__regs[UNW_SPARC_O7] = value;
+    return;
+  case UNW_REG_SP:
+    _registers.__regs[UNW_SPARC_O6] = value;
+    return;
+  }
+  _LIBUNWIND_ABORT("unsupported sparc register");
+}
+
+inline bool Registers_sparc::validFloatRegister(int) const { return false; }
+
+inline double Registers_sparc::getFloatRegister(int) const {
+  _LIBUNWIND_ABORT("no Sparc float registers");
+}
+
+inline void Registers_sparc::setFloatRegister(int, double) {
+  _LIBUNWIND_ABORT("no Sparc float registers");
+}
+
+inline bool Registers_sparc::validVectorRegister(int) const { return false; }
+
+inline v128 Registers_sparc::getVectorRegister(int) const {
+  _LIBUNWIND_ABORT("no Sparc vector registers");
+}
+
+inline void Registers_sparc::setVectorRegister(int, v128) {
+  _LIBUNWIND_ABORT("no Sparc vector registers");
+}
+
+inline const char *Registers_sparc::getRegisterName(int regNum) {
+  switch (regNum) {
+  case UNW_REG_IP:
+    return "pc";
+  case UNW_SPARC_G0:
+    return "g0";
+  case UNW_SPARC_G1:
+    return "g1";
+  case UNW_SPARC_G2:
+    return "g2";
+  case UNW_SPARC_G3:
+    return "g3";
+  case UNW_SPARC_G4:
+    return "g4";
+  case UNW_SPARC_G5:
+    return "g5";
+  case UNW_SPARC_G6:
+    return "g6";
+  case UNW_SPARC_G7:
+    return "g7";
+  case UNW_SPARC_O0:
+    return "o0";
+  case UNW_SPARC_O1:
+    return "o1";
+  case UNW_SPARC_O2:
+    return "o2";
+  case UNW_SPARC_O3:
+    return "o3";
+  case UNW_SPARC_O4:
+    return "o4";
+  case UNW_SPARC_O5:
+    return "o5";
+  case UNW_REG_SP:
+  case UNW_SPARC_O6:
+    return "sp";
+  case UNW_SPARC_O7:
+    return "o7";
+  case UNW_SPARC_L0:
+    return "l0";
+  case UNW_SPARC_L1:
+    return "l1";
+  case UNW_SPARC_L2:
+    return "l2";
+  case UNW_SPARC_L3:
+    return "l3";
+  case UNW_SPARC_L4:
+    return "l4";
+  case UNW_SPARC_L5:
+    return "l5";
+  case UNW_SPARC_L6:
+    return "l6";
+  case UNW_SPARC_L7:
+    return "l7";
+  case UNW_SPARC_I0:
+    return "i0";
+  case UNW_SPARC_I1:
+    return "i1";
+  case UNW_SPARC_I2:
+    return "i2";
+  case UNW_SPARC_I3:
+    return "i3";
+  case UNW_SPARC_I4:
+    return "i4";
+  case UNW_SPARC_I5:
+    return "i5";
+  case UNW_SPARC_I6:
+    return "fp";
+  case UNW_SPARC_I7:
+    return "i7";
+  default:
+    return "unknown register";
+  }
+}
+#endif // _LIBUNWIND_TARGET_SPARC
+
+#if defined(_LIBUNWIND_TARGET_SPARC64)
+/// Registers_sparc64 holds the register state of a thread in a 64-bit
+/// sparc process.
+class _LIBUNWIND_HIDDEN Registers_sparc64 {
+public:
+  Registers_sparc64() = default;
+  Registers_sparc64(const void *registers);
+
+  bool validRegister(int num) const;
+  uint64_t getRegister(int num) const;
+  void setRegister(int num, uint64_t value);
+  bool validFloatRegister(int num) const;
+  double getFloatRegister(int num) const;
+  void setFloatRegister(int num, double value);
+  bool validVectorRegister(int num) const;
+  v128 getVectorRegister(int num) const;
+  void setVectorRegister(int num, v128 value);
+  const char *getRegisterName(int num);
+  void jumpto();
+  static int lastDwarfRegNum() {
+    return _LIBUNWIND_HIGHEST_DWARF_REGISTER_SPARC64;
+  }
+  static int getArch() { return REGISTERS_SPARC64; }
+
+  uint64_t getSP() const { return _registers.__regs[UNW_SPARC_O6] + 2047; }
+  void setSP(uint64_t value) { _registers.__regs[UNW_SPARC_O6] = value - 2047; }
+  uint64_t getIP() const { return _registers.__regs[UNW_SPARC_O7]; }
+  void setIP(uint64_t value) { _registers.__regs[UNW_SPARC_O7] = value; }
+  uint64_t getWCookie() const { return _wcookie; }
+
+private:
+  struct sparc64_thread_state_t {
+    uint64_t __regs[32];
+  };
+
+  sparc64_thread_state_t _registers{};
+  uint64_t _wcookie = 0;
+};
+
+inline Registers_sparc64::Registers_sparc64(const void *registers) {
+  static_assert((check_fit<Registers_sparc64, unw_context_t>::does_fit),
+                "sparc64 registers do not fit into unw_context_t");
+  memcpy(&_registers, registers, sizeof(_registers));
+  memcpy(&_wcookie,
+         static_cast<const uint8_t *>(registers) + sizeof(_registers),
+         sizeof(_wcookie));
+}
+
+inline bool Registers_sparc64::validRegister(int regNum) const {
+  if (regNum == UNW_REG_IP)
+    return true;
+  if (regNum == UNW_REG_SP)
+    return true;
+  if (regNum < 0)
+    return false;
+  if (regNum <= UNW_SPARC_I7)
+    return true;
+  return false;
+}
+
+inline uint64_t Registers_sparc64::getRegister(int regNum) const {
+  if (regNum >= UNW_SPARC_G0 && regNum <= UNW_SPARC_I7)
+    return _registers.__regs[regNum];
+
+  switch (regNum) {
+  case UNW_REG_IP:
+    return _registers.__regs[UNW_SPARC_O7];
+  case UNW_REG_SP:
+    return _registers.__regs[UNW_SPARC_O6] + 2047;
+  }
+  _LIBUNWIND_ABORT("unsupported sparc64 register");
+}
+
+inline void Registers_sparc64::setRegister(int regNum, uint64_t value) {
+  if (regNum >= UNW_SPARC_G0 && regNum <= UNW_SPARC_I7) {
+    _registers.__regs[regNum] = value;
+    return;
+  }
+
+  switch (regNum) {
+  case UNW_REG_IP:
+    _registers.__regs[UNW_SPARC_O7] = value;
+    return;
+  case UNW_REG_SP:
+    _registers.__regs[UNW_SPARC_O6] = value - 2047;
+    return;
+  }
+  _LIBUNWIND_ABORT("unsupported sparc64 register");
+}
+
+inline bool Registers_sparc64::validFloatRegister(int) const { return false; }
+
+inline double Registers_sparc64::getFloatRegister(int) const {
+  _LIBUNWIND_ABORT("no sparc64 float registers");
+}
+
+inline void Registers_sparc64::setFloatRegister(int, double) {
+  _LIBUNWIND_ABORT("no sparc64 float registers");
+}
+
+inline bool Registers_sparc64::validVectorRegister(int) const { return false; }
+
+inline v128 Registers_sparc64::getVectorRegister(int) const {
+  _LIBUNWIND_ABORT("no sparc64 vector registers");
+}
+
+inline void Registers_sparc64::setVectorRegister(int, v128) {
+  _LIBUNWIND_ABORT("no sparc64 vector registers");
+}
+
+inline const char *Registers_sparc64::getRegisterName(int regNum) {
+  switch (regNum) {
+  case UNW_REG_IP:
+    return "pc";
+  case UNW_SPARC_G0:
+    return "g0";
+  case UNW_SPARC_G1:
+    return "g1";
+  case UNW_SPARC_G2:
+    return "g2";
+  case UNW_SPARC_G3:
+    return "g3";
+  case UNW_SPARC_G4:
+    return "g4";
+  case UNW_SPARC_G5:
+    return "g5";
+  case UNW_SPARC_G6:
+    return "g6";
+  case UNW_SPARC_G7:
+    return "g7";
+  case UNW_SPARC_O0:
+    return "o0";
+  case UNW_SPARC_O1:
+    return "o1";
+  case UNW_SPARC_O2:
+    return "o2";
+  case UNW_SPARC_O3:
+    return "o3";
+  case UNW_SPARC_O4:
+    return "o4";
+  case UNW_SPARC_O5:
+    return "o5";
+  case UNW_REG_SP:
+  case UNW_SPARC_O6:
+    return "o6";
+  case UNW_SPARC_O7:
+    return "o7";
+  case UNW_SPARC_L0:
+    return "l0";
+  case UNW_SPARC_L1:
+    return "l1";
+  case UNW_SPARC_L2:
+    return "l2";
+  case UNW_SPARC_L3:
+    return "l3";
+  case UNW_SPARC_L4:
+    return "l4";
+  case UNW_SPARC_L5:
+    return "l5";
+  case UNW_SPARC_L6:
+    return "l6";
+  case UNW_SPARC_L7:
+    return "l7";
+  case UNW_SPARC_I0:
+    return "i0";
+  case UNW_SPARC_I1:
+    return "i1";
+  case UNW_SPARC_I2:
+    return "i2";
+  case UNW_SPARC_I3:
+    return "i3";
+  case UNW_SPARC_I4:
+    return "i4";
+  case UNW_SPARC_I5:
+    return "i5";
+  case UNW_SPARC_I6:
+    return "i6";
+  case UNW_SPARC_I7:
+    return "i7";
+  default:
+    return "unknown register";
+  }
+}
+#endif // _LIBUNWIND_TARGET_SPARC64
+
+#if defined(_LIBUNWIND_TARGET_HEXAGON)
+/// Registers_hexagon holds the register state of a thread in a Hexagon QDSP6
+/// process.
+class _LIBUNWIND_HIDDEN Registers_hexagon {
+public:
+  Registers_hexagon();
+  Registers_hexagon(const void *registers);
+
+  bool        validRegister(int num) const;
+  uint32_t    getRegister(int num) const;
+  void        setRegister(int num, uint32_t value);
+  bool        validFloatRegister(int num) const;
+  double      getFloatRegister(int num) const;
+  void        setFloatRegister(int num, double value);
+  bool        validVectorRegister(int num) const;
+  v128        getVectorRegister(int num) const;
+  void        setVectorRegister(int num, v128 value);
+  const char *getRegisterName(int num);
+  void        jumpto();
+  static int  lastDwarfRegNum() { return _LIBUNWIND_HIGHEST_DWARF_REGISTER_HEXAGON; }
+  static int  getArch() { return REGISTERS_HEXAGON; }
+
+  uint32_t  getSP() const         { return _registers.__r[UNW_HEXAGON_R29]; }
+  void      setSP(uint32_t value) { _registers.__r[UNW_HEXAGON_R29] = value; }
+  uint32_t  getIP() const         { return _registers.__r[UNW_HEXAGON_PC]; }
+  void      setIP(uint32_t value) { _registers.__r[UNW_HEXAGON_PC] = value; }
+
+private:
+  struct hexagon_thread_state_t {
+    unsigned int __r[35];
+  };
+
+  hexagon_thread_state_t _registers;
+};
+
+inline Registers_hexagon::Registers_hexagon(const void *registers) {
+  static_assert((check_fit<Registers_hexagon, unw_context_t>::does_fit),
+                "hexagon registers do not fit into unw_context_t");
+  memcpy(&_registers, static_cast<const uint8_t *>(registers),
+         sizeof(_registers));
+}
+
+inline Registers_hexagon::Registers_hexagon() {
+  memset(&_registers, 0, sizeof(_registers));
+}
+
+inline bool Registers_hexagon::validRegister(int regNum) const {
+  if (regNum <= UNW_HEXAGON_R31)
+    return true;
+  return false;
+}
+
+inline uint32_t Registers_hexagon::getRegister(int regNum) const {
+  if (regNum >= UNW_HEXAGON_R0 && regNum <= UNW_HEXAGON_R31)
+    return _registers.__r[regNum - UNW_HEXAGON_R0];
+
+  switch (regNum) {
+  case UNW_REG_IP:
+    return _registers.__r[UNW_HEXAGON_PC];
+  case UNW_REG_SP:
+    return _registers.__r[UNW_HEXAGON_R29];
+  }
+  _LIBUNWIND_ABORT("unsupported hexagon register");
+}
+
+inline void Registers_hexagon::setRegister(int regNum, uint32_t value) {
+  if (regNum >= UNW_HEXAGON_R0 && regNum <= UNW_HEXAGON_R31) {
+    _registers.__r[regNum - UNW_HEXAGON_R0] = value;
+    return;
+  }
+
+  switch (regNum) {
+  case UNW_REG_IP:
+    _registers.__r[UNW_HEXAGON_PC] = value;
+    return;
+  case UNW_REG_SP:
+    _registers.__r[UNW_HEXAGON_R29] = value;
+    return;
+  }
+  _LIBUNWIND_ABORT("unsupported hexagon register");
+}
+
+inline bool Registers_hexagon::validFloatRegister(int /* regNum */) const {
+  return false;
+}
+
+inline double Registers_hexagon::getFloatRegister(int /* regNum */) const {
+  _LIBUNWIND_ABORT("hexagon float support not implemented");
+}
+
+inline void Registers_hexagon::setFloatRegister(int /* regNum */,
+                                             double /* value */) {
+  _LIBUNWIND_ABORT("hexagon float support not implemented");
+}
+
+inline bool Registers_hexagon::validVectorRegister(int /* regNum */) const {
+  return false;
+}
+
+inline v128 Registers_hexagon::getVectorRegister(int /* regNum */) const {
+  _LIBUNWIND_ABORT("hexagon vector support not implemented");
+}
+
+inline void Registers_hexagon::setVectorRegister(int /* regNum */, v128 /* value */) {
+  _LIBUNWIND_ABORT("hexagon vector support not implemented");
+}
+
+inline const char *Registers_hexagon::getRegisterName(int regNum) {
+  switch (regNum) {
+  case UNW_HEXAGON_R0:
+    return "r0";
+  case UNW_HEXAGON_R1:
+    return "r1";
+  case UNW_HEXAGON_R2:
+    return "r2";
+  case UNW_HEXAGON_R3:
+    return "r3";
+  case UNW_HEXAGON_R4:
+    return "r4";
+  case UNW_HEXAGON_R5:
+    return "r5";
+  case UNW_HEXAGON_R6:
+    return "r6";
+  case UNW_HEXAGON_R7:
+    return "r7";
+  case UNW_HEXAGON_R8:
+    return "r8";
+  case UNW_HEXAGON_R9:
+    return "r9";
+  case UNW_HEXAGON_R10:
+    return "r10";
+  case UNW_HEXAGON_R11:
+    return "r11";
+  case UNW_HEXAGON_R12:
+    return "r12";
+  case UNW_HEXAGON_R13:
+    return "r13";
+  case UNW_HEXAGON_R14:
+    return "r14";
+  case UNW_HEXAGON_R15:
+    return "r15";
+  case UNW_HEXAGON_R16:
+    return "r16";
+  case UNW_HEXAGON_R17:
+    return "r17";
+  case UNW_HEXAGON_R18:
+    return "r18";
+  case UNW_HEXAGON_R19:
+    return "r19";
+  case UNW_HEXAGON_R20:
+    return "r20";
+  case UNW_HEXAGON_R21:
+    return "r21";
+  case UNW_HEXAGON_R22:
+    return "r22";
+  case UNW_HEXAGON_R23:
+    return "r23";
+  case UNW_HEXAGON_R24:
+    return "r24";
+  case UNW_HEXAGON_R25:
+    return "r25";
+  case UNW_HEXAGON_R26:
+    return "r26";
+  case UNW_HEXAGON_R27:
+    return "r27";
+  case UNW_HEXAGON_R28:
+    return "r28";
+  case UNW_HEXAGON_R29:
+    return "r29";
+  case UNW_HEXAGON_R30:
+    return "r30";
+  case UNW_HEXAGON_R31:
+    return "r31";
+  default:
+    return "unknown register";
+  }
+
+}
+#endif // _LIBUNWIND_TARGET_HEXAGON
+
+
+#if defined(_LIBUNWIND_TARGET_RISCV)
+/// Registers_riscv holds the register state of a thread in a RISC-V
+/// process.
+
+// This check makes it safe when LIBUNWIND_ENABLE_CROSS_UNWINDING enabled.
+# ifdef __riscv
+#  if __riscv_xlen == 32
+typedef uint32_t reg_t;
+#  elif __riscv_xlen == 64
+typedef uint64_t reg_t;
+#  else
+#   error "Unsupported __riscv_xlen"
+#  endif
+
+#  if defined(__riscv_flen)
+#   if __riscv_flen == 64
+typedef double fp_t;
+#   elif __riscv_flen == 32
+typedef float fp_t;
+#   else
+#    error "Unsupported __riscv_flen"
+#   endif
+#  else
+// This is just for supressing undeclared error of fp_t.
+typedef double fp_t;
+#  endif
+# else
+// Use Max possible width when cross unwinding
+typedef uint64_t reg_t;
+typedef double fp_t;
+# define __riscv_xlen 64
+# define __riscv_flen 64
+#endif
+
+/// Registers_riscv holds the register state of a thread.
+class _LIBUNWIND_HIDDEN Registers_riscv {
+public:
+  Registers_riscv();
+  Registers_riscv(const void *registers);
+
+  bool        validRegister(int num) const;
+  reg_t       getRegister(int num) const;
+  void        setRegister(int num, reg_t value);
+  bool        validFloatRegister(int num) const;
+  fp_t        getFloatRegister(int num) const;
+  void        setFloatRegister(int num, fp_t value);
+  bool        validVectorRegister(int num) const;
+  v128        getVectorRegister(int num) const;
+  void        setVectorRegister(int num, v128 value);
+  static const char *getRegisterName(int num);
+  void        jumpto();
+  static int  lastDwarfRegNum() { return _LIBUNWIND_HIGHEST_DWARF_REGISTER_RISCV; }
+  static int  getArch() { return REGISTERS_RISCV; }
+
+  reg_t       getSP() const { return _registers[2]; }
+  void        setSP(reg_t value) { _registers[2] = value; }
+  reg_t       getIP() const { return _registers[0]; }
+  void        setIP(reg_t value) { _registers[0] = value; }
+
+private:
+  // _registers[0] holds the pc
+  reg_t _registers[32];
+# if defined(__riscv_flen)
+  fp_t _floats[32];
+# endif
+};
+
+inline Registers_riscv::Registers_riscv(const void *registers) {
+  static_assert((check_fit<Registers_riscv, unw_context_t>::does_fit),
+                "riscv registers do not fit into unw_context_t");
+  memcpy(&_registers, registers, sizeof(_registers));
+# if __riscv_xlen == 32
+  static_assert(sizeof(_registers) == 0x80,
+                "expected float registers to be at offset 128");
+# elif __riscv_xlen == 64
+  static_assert(sizeof(_registers) == 0x100,
+                "expected float registers to be at offset 256");
+# else
+# error "Unexpected float registers."
+# endif
+
+# if defined(__riscv_flen)
+  memcpy(_floats,
+         static_cast<const uint8_t *>(registers) + sizeof(_registers),
+         sizeof(_floats));
+# endif
+}
+
+inline Registers_riscv::Registers_riscv() {
+  memset(&_registers, 0, sizeof(_registers));
+# if defined(__riscv_flen)
+  memset(&_floats, 0, sizeof(_floats));
+# endif
+}
+
+inline bool Registers_riscv::validRegister(int regNum) const {
+  if (regNum == UNW_REG_IP)
+    return true;
+  if (regNum == UNW_REG_SP)
+    return true;
+  if (regNum < 0)
+    return false;
+  if (regNum > UNW_RISCV_F31)
+    return false;
+  return true;
+}
+
+inline reg_t Registers_riscv::getRegister(int regNum) const {
+  if (regNum == UNW_REG_IP)
+    return _registers[0];
+  if (regNum == UNW_REG_SP)
+    return _registers[2];
+  if (regNum == UNW_RISCV_X0)
+    return 0;
+  if ((regNum > 0) && (regNum < 32))
+    return _registers[regNum];
+  _LIBUNWIND_ABORT("unsupported riscv register");
+}
+
+inline void Registers_riscv::setRegister(int regNum, reg_t value) {
+  if (regNum == UNW_REG_IP)
+    _registers[0] = value;
+  else if (regNum == UNW_REG_SP)
+    _registers[2] = value;
+  else if (regNum == UNW_RISCV_X0)
+    /* x0 is hardwired to zero */
+    return;
+  else if ((regNum > 0) && (regNum < 32))
+    _registers[regNum] = value;
+  else
+    _LIBUNWIND_ABORT("unsupported riscv register");
+}
+
+inline const char *Registers_riscv::getRegisterName(int regNum) {
+  switch (regNum) {
+  case UNW_REG_IP:
+    return "pc";
+  case UNW_REG_SP:
+    return "sp";
+  case UNW_RISCV_X0:
+    return "zero";
+  case UNW_RISCV_X1:
+    return "ra";
+  case UNW_RISCV_X2:
+    return "sp";
+  case UNW_RISCV_X3:
+    return "gp";
+  case UNW_RISCV_X4:
+    return "tp";
+  case UNW_RISCV_X5:
+    return "t0";
+  case UNW_RISCV_X6:
+    return "t1";
+  case UNW_RISCV_X7:
+    return "t2";
+  case UNW_RISCV_X8:
+    return "s0";
+  case UNW_RISCV_X9:
+    return "s1";
+  case UNW_RISCV_X10:
+    return "a0";
+  case UNW_RISCV_X11:
+    return "a1";
+  case UNW_RISCV_X12:
+    return "a2";
+  case UNW_RISCV_X13:
+    return "a3";
+  case UNW_RISCV_X14:
+    return "a4";
+  case UNW_RISCV_X15:
+    return "a5";
+  case UNW_RISCV_X16:
+    return "a6";
+  case UNW_RISCV_X17:
+    return "a7";
+  case UNW_RISCV_X18:
+    return "s2";
+  case UNW_RISCV_X19:
+    return "s3";
+  case UNW_RISCV_X20:
+    return "s4";
+  case UNW_RISCV_X21:
+    return "s5";
+  case UNW_RISCV_X22:
+    return "s6";
+  case UNW_RISCV_X23:
+    return "s7";
+  case UNW_RISCV_X24:
+    return "s8";
+  case UNW_RISCV_X25:
+    return "s9";
+  case UNW_RISCV_X26:
+    return "s10";
+  case UNW_RISCV_X27:
+    return "s11";
+  case UNW_RISCV_X28:
+    return "t3";
+  case UNW_RISCV_X29:
+    return "t4";
+  case UNW_RISCV_X30:
+    return "t5";
+  case UNW_RISCV_X31:
+    return "t6";
+  case UNW_RISCV_F0:
+    return "ft0";
+  case UNW_RISCV_F1:
+    return "ft1";
+  case UNW_RISCV_F2:
+    return "ft2";
+  case UNW_RISCV_F3:
+    return "ft3";
+  case UNW_RISCV_F4:
+    return "ft4";
+  case UNW_RISCV_F5:
+    return "ft5";
+  case UNW_RISCV_F6:
+    return "ft6";
+  case UNW_RISCV_F7:
+    return "ft7";
+  case UNW_RISCV_F8:
+    return "fs0";
+  case UNW_RISCV_F9:
+    return "fs1";
+  case UNW_RISCV_F10:
+    return "fa0";
+  case UNW_RISCV_F11:
+    return "fa1";
+  case UNW_RISCV_F12:
+    return "fa2";
+  case UNW_RISCV_F13:
+    return "fa3";
+  case UNW_RISCV_F14:
+    return "fa4";
+  case UNW_RISCV_F15:
+    return "fa5";
+  case UNW_RISCV_F16:
+    return "fa6";
+  case UNW_RISCV_F17:
+    return "fa7";
+  case UNW_RISCV_F18:
+    return "fs2";
+  case UNW_RISCV_F19:
+    return "fs3";
+  case UNW_RISCV_F20:
+    return "fs4";
+  case UNW_RISCV_F21:
+    return "fs5";
+  case UNW_RISCV_F22:
+    return "fs6";
+  case UNW_RISCV_F23:
+    return "fs7";
+  case UNW_RISCV_F24:
+    return "fs8";
+  case UNW_RISCV_F25:
+    return "fs9";
+  case UNW_RISCV_F26:
+    return "fs10";
+  case UNW_RISCV_F27:
+    return "fs11";
+  case UNW_RISCV_F28:
+    return "ft8";
+  case UNW_RISCV_F29:
+    return "ft9";
+  case UNW_RISCV_F30:
+    return "ft10";
+  case UNW_RISCV_F31:
+    return "ft11";
+  default:
+    return "unknown register";
+  }
+}
+
+inline bool Registers_riscv::validFloatRegister(int regNum) const {
+# if defined(__riscv_flen)
+  if (regNum < UNW_RISCV_F0)
+    return false;
+  if (regNum > UNW_RISCV_F31)
+    return false;
+  return true;
+# else
+  (void)regNum;
+  return false;
+# endif
+}
+
+inline fp_t Registers_riscv::getFloatRegister(int regNum) const {
+# if defined(__riscv_flen)
+  assert(validFloatRegister(regNum));
+  return _floats[regNum - UNW_RISCV_F0];
+# else
+  (void)regNum;
+  _LIBUNWIND_ABORT("libunwind not built with float support");
+# endif
+}
+
+inline void Registers_riscv::setFloatRegister(int regNum, fp_t value) {
+# if defined(__riscv_flen)
+  assert(validFloatRegister(regNum));
+  _floats[regNum - UNW_RISCV_F0] = value;
+# else
+  (void)regNum;
+  (void)value;
+  _LIBUNWIND_ABORT("libunwind not built with float support");
+# endif
+}
+
+inline bool Registers_riscv::validVectorRegister(int) const {
+  return false;
+}
+
+inline v128 Registers_riscv::getVectorRegister(int) const {
+  _LIBUNWIND_ABORT("no riscv vector register support yet");
+}
+
+inline void Registers_riscv::setVectorRegister(int, v128) {
+  _LIBUNWIND_ABORT("no riscv vector register support yet");
+}
+#endif // _LIBUNWIND_TARGET_RISCV
+
+#if defined(_LIBUNWIND_TARGET_VE)
+/// Registers_ve holds the register state of a thread in a VE process.
+class _LIBUNWIND_HIDDEN Registers_ve {
+public:
+  Registers_ve();
+  Registers_ve(const void *registers);
+
+  bool        validRegister(int num) const;
+  uint64_t    getRegister(int num) const;
+  void        setRegister(int num, uint64_t value);
+  bool        validFloatRegister(int num) const;
+  double      getFloatRegister(int num) const;
+  void        setFloatRegister(int num, double value);
+  bool        validVectorRegister(int num) const;
+  v128        getVectorRegister(int num) const;
+  void        setVectorRegister(int num, v128 value);
+  static const char *getRegisterName(int num);
+  void        jumpto();
+  static int  lastDwarfRegNum() { return _LIBUNWIND_HIGHEST_DWARF_REGISTER_VE; }
+  static int  getArch() { return REGISTERS_VE; }
+
+  uint64_t  getSP() const         { return _registers.__s[11]; }
+  void      setSP(uint64_t value) { _registers.__s[11] = value; }
+  uint64_t  getIP() const         { return _registers.__ic; }
+  void      setIP(uint64_t value) { _registers.__ic = value; }
+
+private:
+  // FIXME: Need to store not only scalar registers but also vector and vector
+  // mask registers.  VEOS uses mcontext_t defined in ucontext.h.  It takes
+  // 524288 bytes (65536*8 bytes), though.  Currently, we use libunwind for
+  // SjLj exception support only, so Registers_ve is not implemented completely.
+  struct ve_thread_state_t {
+    uint64_t __s[64]; // s0-s64
+    uint64_t __ic;    // Instruction counter (IC)
+    uint64_t __vixr;  // Vector Index Register
+    uint64_t __vl;    // Vector Length Register
+  };
+
+  ve_thread_state_t _registers; // total 67 registers
+
+  // Currently no vector register is preserved.
+};
+
+inline Registers_ve::Registers_ve(const void *registers) {
+  static_assert((check_fit<Registers_ve, unw_context_t>::does_fit),
+                "ve registers do not fit into unw_context_t");
+  memcpy(&_registers, static_cast<const uint8_t *>(registers),
+         sizeof(_registers));
+  static_assert(sizeof(_registers) == 536,
+                "expected vector register offset to be 536");
+}
+
+inline Registers_ve::Registers_ve() {
+  memset(&_registers, 0, sizeof(_registers));
+}
+
+inline bool Registers_ve::validRegister(int regNum) const {
+  if (regNum >= UNW_VE_S0 && regNum <= UNW_VE_S63)
+    return true;
+
+  switch (regNum) {
+  case UNW_REG_IP:
+  case UNW_REG_SP:
+  case UNW_VE_VIXR:
+  case UNW_VE_VL:
+    return true;
+  default:
+    return false;
+  }
+}
+
+inline uint64_t Registers_ve::getRegister(int regNum) const {
+  if (regNum >= UNW_VE_S0 && regNum <= UNW_VE_S63)
+    return _registers.__s[regNum - UNW_VE_S0];
+
+  switch (regNum) {
+  case UNW_REG_IP:
+    return _registers.__ic;
+  case UNW_REG_SP:
+    return _registers.__s[11];
+  case UNW_VE_VIXR:
+    return _registers.__vixr;
+  case UNW_VE_VL:
+    return _registers.__vl;
+  }
+  _LIBUNWIND_ABORT("unsupported ve register");
+}
+
+inline void Registers_ve::setRegister(int regNum, uint64_t value) {
+  if (regNum >= UNW_VE_S0 && regNum <= UNW_VE_S63) {
+    _registers.__s[regNum - UNW_VE_S0] = value;
+    return;
+  }
+
+  switch (regNum) {
+  case UNW_REG_IP:
+    _registers.__ic = value;
+    return;
+  case UNW_REG_SP:
+    _registers.__s[11] = value;
+    return;
+  case UNW_VE_VIXR:
+    _registers.__vixr = value;
+    return;
+  case UNW_VE_VL:
+    _registers.__vl = value;
+    return;
+  }
+  _LIBUNWIND_ABORT("unsupported ve register");
+}
+
+inline bool Registers_ve::validFloatRegister(int /* regNum */) const {
+  return false;
+}
+
+inline double Registers_ve::getFloatRegister(int /* regNum */) const {
+  _LIBUNWIND_ABORT("VE doesn't have float registers");
+}
+
+inline void Registers_ve::setFloatRegister(int /* regNum */,
+                                           double /* value */) {
+  _LIBUNWIND_ABORT("VE doesn't have float registers");
+}
+
+inline bool Registers_ve::validVectorRegister(int /* regNum */) const {
+  return false;
+}
+
+inline v128 Registers_ve::getVectorRegister(int /* regNum */) const {
+  _LIBUNWIND_ABORT("VE vector support not implemented");
+}
+
+inline void Registers_ve::setVectorRegister(int /* regNum */,
+                                            v128 /* value */) {
+  _LIBUNWIND_ABORT("VE vector support not implemented");
+}
+
+inline const char *Registers_ve::getRegisterName(int regNum) {
+  switch (regNum) {
+  case UNW_REG_IP:
+    return "ip";
+  case UNW_REG_SP:
+    return "sp";
+  case UNW_VE_VIXR:
+    return "vixr";
+  case UNW_VE_VL:
+    return "vl";
+  case UNW_VE_S0:
+    return "s0";
+  case UNW_VE_S1:
+    return "s1";
+  case UNW_VE_S2:
+    return "s2";
+  case UNW_VE_S3:
+    return "s3";
+  case UNW_VE_S4:
+    return "s4";
+  case UNW_VE_S5:
+    return "s5";
+  case UNW_VE_S6:
+    return "s6";
+  case UNW_VE_S7:
+    return "s7";
+  case UNW_VE_S8:
+    return "s8";
+  case UNW_VE_S9:
+    return "s9";
+  case UNW_VE_S10:
+    return "s10";
+  case UNW_VE_S11:
+    return "s11";
+  case UNW_VE_S12:
+    return "s12";
+  case UNW_VE_S13:
+    return "s13";
+  case UNW_VE_S14:
+    return "s14";
+  case UNW_VE_S15:
+    return "s15";
+  case UNW_VE_S16:
+    return "s16";
+  case UNW_VE_S17:
+    return "s17";
+  case UNW_VE_S18:
+    return "s18";
+  case UNW_VE_S19:
+    return "s19";
+  case UNW_VE_S20:
+    return "s20";
+  case UNW_VE_S21:
+    return "s21";
+  case UNW_VE_S22:
+    return "s22";
+  case UNW_VE_S23:
+    return "s23";
+  case UNW_VE_S24:
+    return "s24";
+  case UNW_VE_S25:
+    return "s25";
+  case UNW_VE_S26:
+    return "s26";
+  case UNW_VE_S27:
+    return "s27";
+  case UNW_VE_S28:
+    return "s28";
+  case UNW_VE_S29:
+    return "s29";
+  case UNW_VE_S30:
+    return "s30";
+  case UNW_VE_S31:
+    return "s31";
+  case UNW_VE_S32:
+    return "s32";
+  case UNW_VE_S33:
+    return "s33";
+  case UNW_VE_S34:
+    return "s34";
+  case UNW_VE_S35:
+    return "s35";
+  case UNW_VE_S36:
+    return "s36";
+  case UNW_VE_S37:
+    return "s37";
+  case UNW_VE_S38:
+    return "s38";
+  case UNW_VE_S39:
+    return "s39";
+  case UNW_VE_S40:
+    return "s40";
+  case UNW_VE_S41:
+    return "s41";
+  case UNW_VE_S42:
+    return "s42";
+  case UNW_VE_S43:
+    return "s43";
+  case UNW_VE_S44:
+    return "s44";
+  case UNW_VE_S45:
+    return "s45";
+  case UNW_VE_S46:
+    return "s46";
+  case UNW_VE_S47:
+    return "s47";
+  case UNW_VE_S48:
+    return "s48";
+  case UNW_VE_S49:
+    return "s49";
+  case UNW_VE_S50:
+    return "s50";
+  case UNW_VE_S51:
+    return "s51";
+  case UNW_VE_S52:
+    return "s52";
+  case UNW_VE_S53:
+    return "s53";
+  case UNW_VE_S54:
+    return "s54";
+  case UNW_VE_S55:
+    return "s55";
+  case UNW_VE_S56:
+    return "s56";
+  case UNW_VE_S57:
+    return "s57";
+  case UNW_VE_S58:
+    return "s58";
+  case UNW_VE_S59:
+    return "s59";
+  case UNW_VE_S60:
+    return "s60";
+  case UNW_VE_S61:
+    return "s61";
+  case UNW_VE_S62:
+    return "s62";
+  case UNW_VE_S63:
+    return "s63";
+  case UNW_VE_V0:
+    return "v0";
+  case UNW_VE_V1:
+    return "v1";
+  case UNW_VE_V2:
+    return "v2";
+  case UNW_VE_V3:
+    return "v3";
+  case UNW_VE_V4:
+    return "v4";
+  case UNW_VE_V5:
+    return "v5";
+  case UNW_VE_V6:
+    return "v6";
+  case UNW_VE_V7:
+    return "v7";
+  case UNW_VE_V8:
+    return "v8";
+  case UNW_VE_V9:
+    return "v9";
+  case UNW_VE_V10:
+    return "v10";
+  case UNW_VE_V11:
+    return "v11";
+  case UNW_VE_V12:
+    return "v12";
+  case UNW_VE_V13:
+    return "v13";
+  case UNW_VE_V14:
+    return "v14";
+  case UNW_VE_V15:
+    return "v15";
+  case UNW_VE_V16:
+    return "v16";
+  case UNW_VE_V17:
+    return "v17";
+  case UNW_VE_V18:
+    return "v18";
+  case UNW_VE_V19:
+    return "v19";
+  case UNW_VE_V20:
+    return "v20";
+  case UNW_VE_V21:
+    return "v21";
+  case UNW_VE_V22:
+    return "v22";
+  case UNW_VE_V23:
+    return "v23";
+  case UNW_VE_V24:
+    return "v24";
+  case UNW_VE_V25:
+    return "v25";
+  case UNW_VE_V26:
+    return "v26";
+  case UNW_VE_V27:
+    return "v27";
+  case UNW_VE_V28:
+    return "v28";
+  case UNW_VE_V29:
+    return "v29";
+  case UNW_VE_V30:
+    return "v30";
+  case UNW_VE_V31:
+    return "v31";
+  case UNW_VE_V32:
+    return "v32";
+  case UNW_VE_V33:
+    return "v33";
+  case UNW_VE_V34:
+    return "v34";
+  case UNW_VE_V35:
+    return "v35";
+  case UNW_VE_V36:
+    return "v36";
+  case UNW_VE_V37:
+    return "v37";
+  case UNW_VE_V38:
+    return "v38";
+  case UNW_VE_V39:
+    return "v39";
+  case UNW_VE_V40:
+    return "v40";
+  case UNW_VE_V41:
+    return "v41";
+  case UNW_VE_V42:
+    return "v42";
+  case UNW_VE_V43:
+    return "v43";
+  case UNW_VE_V44:
+    return "v44";
+  case UNW_VE_V45:
+    return "v45";
+  case UNW_VE_V46:
+    return "v46";
+  case UNW_VE_V47:
+    return "v47";
+  case UNW_VE_V48:
+    return "v48";
+  case UNW_VE_V49:
+    return "v49";
+  case UNW_VE_V50:
+    return "v50";
+  case UNW_VE_V51:
+    return "v51";
+  case UNW_VE_V52:
+    return "v52";
+  case UNW_VE_V53:
+    return "v53";
+  case UNW_VE_V54:
+    return "v54";
+  case UNW_VE_V55:
+    return "v55";
+  case UNW_VE_V56:
+    return "v56";
+  case UNW_VE_V57:
+    return "v57";
+  case UNW_VE_V58:
+    return "v58";
+  case UNW_VE_V59:
+    return "v59";
+  case UNW_VE_V60:
+    return "v60";
+  case UNW_VE_V61:
+    return "v61";
+  case UNW_VE_V62:
+    return "v62";
+  case UNW_VE_V63:
+    return "v63";
+  case UNW_VE_VM0:
+    return "vm0";
+  case UNW_VE_VM1:
+    return "vm1";
+  case UNW_VE_VM2:
+    return "vm2";
+  case UNW_VE_VM3:
+    return "vm3";
+  case UNW_VE_VM4:
+    return "vm4";
+  case UNW_VE_VM5:
+    return "vm5";
+  case UNW_VE_VM6:
+    return "vm6";
+  case UNW_VE_VM7:
+    return "vm7";
+  case UNW_VE_VM8:
+    return "vm8";
+  case UNW_VE_VM9:
+    return "vm9";
+  case UNW_VE_VM10:
+    return "vm10";
+  case UNW_VE_VM11:
+    return "vm11";
+  case UNW_VE_VM12:
+    return "vm12";
+  case UNW_VE_VM13:
+    return "vm13";
+  case UNW_VE_VM14:
+    return "vm14";
+  case UNW_VE_VM15:
+    return "vm15";
+  }
+  return "unknown register";
+}
+#endif // _LIBUNWIND_TARGET_VE
+
 } // namespace libunwind
 
 #endif // __REGISTERS_HPP__
diff --git a/WAVM/ThirdParty/libunwind/src/Unwind-EHABI.cpp b/WAVM/ThirdParty/libunwind/src/Unwind-EHABI.cpp
index f37732c6..257db724 100644
--- a/WAVM/ThirdParty/libunwind/src/Unwind-EHABI.cpp
+++ b/WAVM/ThirdParty/libunwind/src/Unwind-EHABI.cpp
@@ -1,9 +1,8 @@
-//===--------------------------- Unwind-EHABI.cpp -------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
+//===----------------------------------------------------------------------===//
 //
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //
 //  Implements ARM zero-cost C++ exceptions
@@ -21,8 +20,6 @@
 #include <stdlib.h>
 #include <string.h>
 
-#include <type_traits>
-
 #include "config.h"
 #include "libunwind.h"
 #include "libunwind_ext.h"
@@ -34,7 +31,13 @@ namespace {
 // signinficant byte.
 uint8_t getByte(const uint32_t* data, size_t offset) {
   const uint8_t* byteData = reinterpret_cast<const uint8_t*>(data);
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
   return byteData[(offset & ~(size_t)0x03) + (3 - (offset & (size_t)0x03))];
+#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+  return byteData[offset];
+#else
+#error "Unable to determine endianess"
+#endif
 }
 
 const char* getNextWord(const char* data, uint32_t* out) {
@@ -94,9 +97,11 @@ _Unwind_Reason_Code ProcessDescriptors(
       case Descriptor::LU32:
         descriptor = getNextWord(descriptor, &length);
         descriptor = getNextWord(descriptor, &offset);
+        break;
       case Descriptor::LU16:
         descriptor = getNextNibble(descriptor, &length);
         descriptor = getNextNibble(descriptor, &offset);
+        break;
       default:
         assert(false);
         return _URC_FAILURE;
@@ -182,9 +187,14 @@ static _Unwind_Reason_Code unwindOneFrame(_Unwind_State state,
   if (result != _URC_CONTINUE_UNWIND)
     return result;
 
-  if (unw_step(reinterpret_cast<unw_cursor_t*>(context)) != UNW_STEP_SUCCESS)
+  switch (__unw_step(reinterpret_cast<unw_cursor_t *>(context))) {
+  case UNW_STEP_SUCCESS:
+    return _URC_CONTINUE_UNWIND;
+  case UNW_STEP_END:
+    return _URC_END_OF_STACK;
+  default:
     return _URC_FAILURE;
-  return _URC_CONTINUE_UNWIND;
+  }
 }
 
 // Generates mask discriminator for _Unwind_VRS_Pop, e.g. for _UVRSC_CORE /
@@ -251,6 +261,7 @@ _Unwind_VRS_Interpret(_Unwind_Context *context, const uint32_t *data,
                       size_t offset, size_t len) {
   bool wrotePC = false;
   bool finish = false;
+  bool hasReturnAddrAuthCode = false;
   while (offset < len && !finish) {
     uint8_t byte = getByte(data, offset++);
     if ((byte & 0x80) == 0) {
@@ -337,6 +348,10 @@ _Unwind_VRS_Interpret(_Unwind_Context *context, const uint32_t *data,
               break;
             }
             case 0xb4:
+              hasReturnAddrAuthCode = true;
+              _Unwind_VRS_Pop(context, _UVRSC_PSEUDO,
+                              0 /* Return Address Auth Code */, _UVRSD_UINT32);
+              break;
             case 0xb5:
             case 0xb6:
             case 0xb7:
@@ -412,6 +427,16 @@ _Unwind_VRS_Interpret(_Unwind_Context *context, const uint32_t *data,
   if (!wrotePC) {
     uint32_t lr;
     _Unwind_VRS_Get(context, _UVRSC_CORE, UNW_ARM_LR, _UVRSD_UINT32, &lr);
+#ifdef __ARM_FEATURE_PAUTH
+    if (hasReturnAddrAuthCode) {
+      uint32_t sp;
+      uint32_t pac;
+      _Unwind_VRS_Get(context, _UVRSC_CORE, UNW_ARM_SP, _UVRSD_UINT32, &sp);
+      _Unwind_VRS_Get(context, _UVRSC_PSEUDO, UNW_ARM_RA_AUTH_CODE,
+                      _UVRSD_UINT32, &pac);
+      __asm__ __volatile__("autg %0, %1, %2" : : "r"(pac), "r"(lr), "r"(sp) :);
+    }
+#endif
     _Unwind_VRS_Set(context, _UVRSC_CORE, UNW_ARM_IP, _UVRSD_UINT32, &lr);
   }
   return _URC_CONTINUE_UNWIND;
@@ -443,31 +468,33 @@ unwind_phase1(unw_context_t *uc, unw_cursor_t *cursor, _Unwind_Exception *except
   // In this implementation, the phases don't share the VRS backing store.
   // Instead, they are passed the original |uc| and they create a new VRS
   // from scratch thus achieving the same effect.
-  unw_init_local(cursor, uc);
+  __unw_init_local(cursor, uc);
 
   // Walk each frame looking for a place to stop.
   for (bool handlerNotFound = true; handlerNotFound;) {
 
     // See if frame has code to run (has personality routine).
     unw_proc_info_t frameInfo;
-    if (unw_get_proc_info(cursor, &frameInfo) != UNW_ESUCCESS) {
-      _LIBUNWIND_TRACE_UNWINDING("unwind_phase1(ex_ojb=%p): unw_get_proc_info "
-                                 "failed => _URC_FATAL_PHASE1_ERROR",
-                                 static_cast<void *>(exception_object));
+    if (__unw_get_proc_info(cursor, &frameInfo) != UNW_ESUCCESS) {
+      _LIBUNWIND_TRACE_UNWINDING(
+          "unwind_phase1(ex_ojb=%p): __unw_get_proc_info "
+          "failed => _URC_FATAL_PHASE1_ERROR",
+          static_cast<void *>(exception_object));
       return _URC_FATAL_PHASE1_ERROR;
     }
 
+#ifndef NDEBUG
     // When tracing, print state information.
     if (_LIBUNWIND_TRACING_UNWINDING) {
       char functionBuf[512];
       const char *functionName = functionBuf;
       unw_word_t offset;
-      if ((unw_get_proc_name(cursor, functionBuf, sizeof(functionBuf),
-                             &offset) != UNW_ESUCCESS) ||
+      if ((__unw_get_proc_name(cursor, functionBuf, sizeof(functionBuf),
+                               &offset) != UNW_ESUCCESS) ||
           (frameInfo.start_ip + offset > frameInfo.end_ip))
         functionName = ".anonymous.";
       unw_word_t pc;
-      unw_get_reg(cursor, UNW_REG_IP, &pc);
+      __unw_get_reg(cursor, UNW_REG_IP, &pc);
       _LIBUNWIND_TRACE_UNWINDING(
           "unwind_phase1(ex_ojb=%p): pc=0x%" PRIxPTR ", start_ip=0x%" PRIxPTR ", func=%s, "
           "lsda=0x%" PRIxPTR ", personality=0x%" PRIxPTR,
@@ -475,12 +502,13 @@ unwind_phase1(unw_context_t *uc, unw_cursor_t *cursor, _Unwind_Exception *except
           frameInfo.start_ip, functionName,
           frameInfo.lsda, frameInfo.handler);
     }
+#endif
 
     // If there is a personality routine, ask it if it will want to stop at
     // this frame.
     if (frameInfo.handler != 0) {
-      __personality_routine p =
-          (__personality_routine)(long)(frameInfo.handler);
+      _Unwind_Personality_Fn p =
+          (_Unwind_Personality_Fn)(long)(frameInfo.handler);
       _LIBUNWIND_TRACE_UNWINDING(
           "unwind_phase1(ex_ojb=%p): calling personality function %p",
           static_cast<void *>(exception_object),
@@ -537,7 +565,7 @@ static _Unwind_Reason_Code unwind_phase2(unw_context_t *uc, unw_cursor_t *cursor
                                          _Unwind_Exception *exception_object,
                                          bool resume) {
   // See comment at the start of unwind_phase1 regarding VRS integrity.
-  unw_init_local(cursor, uc);
+  __unw_init_local(cursor, uc);
 
   _LIBUNWIND_TRACE_UNWINDING("unwind_phase2(ex_ojb=%p)",
                              static_cast<void *>(exception_object));
@@ -559,29 +587,31 @@ static _Unwind_Reason_Code unwind_phase2(unw_context_t *uc, unw_cursor_t *cursor
       // for. After this, continue unwinding as if normal.
       //
       // See #7.4.6 for details.
-      unw_set_reg(cursor, UNW_REG_IP,
-                  exception_object->unwinder_cache.reserved2);
+      __unw_set_reg(cursor, UNW_REG_IP,
+                    exception_object->unwinder_cache.reserved2);
       resume = false;
     }
 
     // Get info about this frame.
     unw_word_t sp;
     unw_proc_info_t frameInfo;
-    unw_get_reg(cursor, UNW_REG_SP, &sp);
-    if (unw_get_proc_info(cursor, &frameInfo) != UNW_ESUCCESS) {
-      _LIBUNWIND_TRACE_UNWINDING("unwind_phase2(ex_ojb=%p): unw_get_proc_info "
-                                 "failed => _URC_FATAL_PHASE2_ERROR",
-                                 static_cast<void *>(exception_object));
+    __unw_get_reg(cursor, UNW_REG_SP, &sp);
+    if (__unw_get_proc_info(cursor, &frameInfo) != UNW_ESUCCESS) {
+      _LIBUNWIND_TRACE_UNWINDING(
+          "unwind_phase2(ex_ojb=%p): __unw_get_proc_info "
+          "failed => _URC_FATAL_PHASE2_ERROR",
+          static_cast<void *>(exception_object));
       return _URC_FATAL_PHASE2_ERROR;
     }
 
+#ifndef NDEBUG
     // When tracing, print state information.
     if (_LIBUNWIND_TRACING_UNWINDING) {
       char functionBuf[512];
       const char *functionName = functionBuf;
       unw_word_t offset;
-      if ((unw_get_proc_name(cursor, functionBuf, sizeof(functionBuf),
-                             &offset) != UNW_ESUCCESS) ||
+      if ((__unw_get_proc_name(cursor, functionBuf, sizeof(functionBuf),
+                               &offset) != UNW_ESUCCESS) ||
           (frameInfo.start_ip + offset > frameInfo.end_ip))
         functionName = ".anonymous.";
       _LIBUNWIND_TRACE_UNWINDING(
@@ -591,11 +621,12 @@ static _Unwind_Reason_Code unwind_phase2(unw_context_t *uc, unw_cursor_t *cursor
           functionName, sp, frameInfo.lsda,
           frameInfo.handler);
     }
+#endif
 
     // If there is a personality routine, tell it we are unwinding.
     if (frameInfo.handler != 0) {
-      __personality_routine p =
-          (__personality_routine)(long)(frameInfo.handler);
+      _Unwind_Personality_Fn p =
+          (_Unwind_Personality_Fn)(intptr_t)(frameInfo.handler);
       struct _Unwind_Context *context = (struct _Unwind_Context *)(cursor);
       // EHABI #7.2
       exception_object->pr_cache.fnstart = frameInfo.start_ip;
@@ -625,8 +656,8 @@ static _Unwind_Reason_Code unwind_phase2(unw_context_t *uc, unw_cursor_t *cursor
         // We may get control back if landing pad calls _Unwind_Resume().
         if (_LIBUNWIND_TRACING_UNWINDING) {
           unw_word_t pc;
-          unw_get_reg(cursor, UNW_REG_IP, &pc);
-          unw_get_reg(cursor, UNW_REG_SP, &sp);
+          __unw_get_reg(cursor, UNW_REG_IP, &pc);
+          __unw_get_reg(cursor, UNW_REG_SP, &sp);
           _LIBUNWIND_TRACE_UNWINDING("unwind_phase2(ex_ojb=%p): re-entering "
                                      "user code with ip=0x%" PRIxPTR ", sp=0x%" PRIxPTR,
                                      static_cast<void *>(exception_object),
@@ -637,11 +668,11 @@ static _Unwind_Reason_Code unwind_phase2(unw_context_t *uc, unw_cursor_t *cursor
           // EHABI #7.4.1 says we need to preserve pc for when _Unwind_Resume
           // is called back, to find this same frame.
           unw_word_t pc;
-          unw_get_reg(cursor, UNW_REG_IP, &pc);
+          __unw_get_reg(cursor, UNW_REG_IP, &pc);
           exception_object->unwinder_cache.reserved2 = (uint32_t)pc;
         }
-        unw_resume(cursor);
-        // unw_resume() only returns if there was an error.
+        __unw_resume(cursor);
+        // __unw_resume() only returns if there was an error.
         return _URC_FATAL_PHASE2_ERROR;
 
       // # EHABI #7.4.3
@@ -663,6 +694,123 @@ static _Unwind_Reason_Code unwind_phase2(unw_context_t *uc, unw_cursor_t *cursor
   return _URC_FATAL_PHASE2_ERROR;
 }
 
+static _Unwind_Reason_Code
+unwind_phase2_forced(unw_context_t *uc, unw_cursor_t *cursor,
+                     _Unwind_Exception *exception_object, _Unwind_Stop_Fn stop,
+                     void *stop_parameter) {
+  bool endOfStack = false;
+  // See comment at the start of unwind_phase1 regarding VRS integrity.
+  __unw_init_local(cursor, uc);
+  _LIBUNWIND_TRACE_UNWINDING("unwind_phase2_force(ex_ojb=%p)",
+                             static_cast<void *>(exception_object));
+  // Walk each frame until we reach where search phase said to stop
+  while (!endOfStack) {
+    // Update info about this frame.
+    unw_proc_info_t frameInfo;
+    if (__unw_get_proc_info(cursor, &frameInfo) != UNW_ESUCCESS) {
+      _LIBUNWIND_TRACE_UNWINDING("unwind_phase2_forced(ex_ojb=%p): __unw_step "
+                                 "failed => _URC_END_OF_STACK",
+                                 (void *)exception_object);
+      return _URC_FATAL_PHASE2_ERROR;
+    }
+
+#ifndef NDEBUG
+    // When tracing, print state information.
+    if (_LIBUNWIND_TRACING_UNWINDING) {
+      char functionBuf[512];
+      const char *functionName = functionBuf;
+      unw_word_t offset;
+      if ((__unw_get_proc_name(cursor, functionBuf, sizeof(functionBuf),
+                               &offset) != UNW_ESUCCESS) ||
+          (frameInfo.start_ip + offset > frameInfo.end_ip))
+        functionName = ".anonymous.";
+      _LIBUNWIND_TRACE_UNWINDING(
+          "unwind_phase2_forced(ex_ojb=%p): start_ip=0x%" PRIxPTR
+          ", func=%s, lsda=0x%" PRIxPTR ", personality=0x%" PRIxPTR,
+          (void *)exception_object, frameInfo.start_ip, functionName,
+          frameInfo.lsda, frameInfo.handler);
+    }
+#endif
+
+    // Call stop function at each frame.
+    _Unwind_Action action =
+        (_Unwind_Action)(_UA_FORCE_UNWIND | _UA_CLEANUP_PHASE);
+    _Unwind_Reason_Code stopResult =
+        (*stop)(1, action, exception_object->exception_class, exception_object,
+                (_Unwind_Context *)(cursor), stop_parameter);
+    _LIBUNWIND_TRACE_UNWINDING(
+        "unwind_phase2_forced(ex_ojb=%p): stop function returned %d",
+        (void *)exception_object, stopResult);
+    if (stopResult != _URC_NO_REASON) {
+      _LIBUNWIND_TRACE_UNWINDING(
+          "unwind_phase2_forced(ex_ojb=%p): stopped by stop function",
+          (void *)exception_object);
+      return _URC_FATAL_PHASE2_ERROR;
+    }
+
+    // If there is a personality routine, tell it we are unwinding.
+    if (frameInfo.handler != 0) {
+      _Unwind_Personality_Fn p =
+          (_Unwind_Personality_Fn)(uintptr_t)(frameInfo.handler);
+      struct _Unwind_Context *context = (struct _Unwind_Context *)(cursor);
+      // EHABI #7.2
+      exception_object->pr_cache.fnstart = frameInfo.start_ip;
+      exception_object->pr_cache.ehtp =
+          (_Unwind_EHT_Header *)frameInfo.unwind_info;
+      exception_object->pr_cache.additional = frameInfo.flags;
+      _Unwind_Reason_Code personalityResult =
+          (*p)(_US_FORCE_UNWIND | _US_UNWIND_FRAME_STARTING, exception_object,
+               context);
+      switch (personalityResult) {
+      case _URC_CONTINUE_UNWIND:
+        _LIBUNWIND_TRACE_UNWINDING("unwind_phase2_forced(ex_ojb=%p): "
+                                   "personality returned "
+                                   "_URC_CONTINUE_UNWIND",
+                                   (void *)exception_object);
+        // Destructors called, continue unwinding
+        break;
+      case _URC_INSTALL_CONTEXT:
+        _LIBUNWIND_TRACE_UNWINDING("unwind_phase2_forced(ex_ojb=%p): "
+                                   "personality returned "
+                                   "_URC_INSTALL_CONTEXT",
+                                   (void *)exception_object);
+        // We may get control back if landing pad calls _Unwind_Resume().
+        __unw_resume(cursor);
+        break;
+      case _URC_END_OF_STACK:
+        _LIBUNWIND_TRACE_UNWINDING("unwind_phase2_forced(ex_ojb=%p): "
+                                   "personality returned "
+                                   "_URC_END_OF_STACK",
+                                   (void *)exception_object);
+        // Personalty routine did the step and it can't step forward.
+        endOfStack = true;
+        break;
+      default:
+        // Personality routine returned an unknown result code.
+        _LIBUNWIND_TRACE_UNWINDING("unwind_phase2_forced(ex_ojb=%p): "
+                                   "personality returned %d, "
+                                   "_URC_FATAL_PHASE2_ERROR",
+                                   (void *)exception_object, personalityResult);
+        return _URC_FATAL_PHASE2_ERROR;
+      }
+    }
+  }
+
+  // Call stop function one last time and tell it we've reached the end
+  // of the stack.
+  _LIBUNWIND_TRACE_UNWINDING("unwind_phase2_forced(ex_ojb=%p): calling stop "
+                             "function with _UA_END_OF_STACK",
+                             (void *)exception_object);
+  _Unwind_Action lastAction =
+      (_Unwind_Action)(_UA_FORCE_UNWIND | _UA_CLEANUP_PHASE | _UA_END_OF_STACK);
+  (*stop)(1, lastAction, exception_object->exception_class, exception_object,
+          (struct _Unwind_Context *)(cursor), stop_parameter);
+
+  // Clean up phase did not resume at the frame that the search phase said it
+  // would.
+  return _URC_FATAL_PHASE2_ERROR;
+}
+
 /// Called by __cxa_throw.  Only returns if there is a fatal error.
 _LIBUNWIND_EXPORT _Unwind_Reason_Code
 _Unwind_RaiseException(_Unwind_Exception *exception_object) {
@@ -670,7 +818,7 @@ _Unwind_RaiseException(_Unwind_Exception *exception_object) {
                        static_cast<void *>(exception_object));
   unw_context_t uc;
   unw_cursor_t cursor;
-  unw_getcontext(&uc);
+  __unw_getcontext(&uc);
 
   // This field for is for compatibility with GCC to say this isn't a forced
   // unwind. EHABI #7.2
@@ -708,12 +856,15 @@ _Unwind_Resume(_Unwind_Exception *exception_object) {
                        static_cast<void *>(exception_object));
   unw_context_t uc;
   unw_cursor_t cursor;
-  unw_getcontext(&uc);
+  __unw_getcontext(&uc);
 
-  // _Unwind_RaiseException on EHABI will always set the reserved1 field to 0,
-  // which is in the same position as private_1 below.
-  // TODO(ajwong): Who wronte the above? Why is it true?
-  unwind_phase2(&uc, &cursor, exception_object, true);
+  if (exception_object->unwinder_cache.reserved1)
+    unwind_phase2_forced(
+        &uc, &cursor, exception_object,
+        (_Unwind_Stop_Fn)exception_object->unwinder_cache.reserved1,
+        (void *)exception_object->unwinder_cache.reserved3);
+  else
+    unwind_phase2(&uc, &cursor, exception_object, true);
 
   // Clients assume _Unwind_Resume() does not return, so all we can do is abort.
   _LIBUNWIND_ABORT("_Unwind_Resume() can't return");
@@ -725,7 +876,7 @@ _Unwind_GetLanguageSpecificData(struct _Unwind_Context *context) {
   unw_cursor_t *cursor = (unw_cursor_t *)context;
   unw_proc_info_t frameInfo;
   uintptr_t result = 0;
-  if (unw_get_proc_info(cursor, &frameInfo) == UNW_ESUCCESS)
+  if (__unw_get_proc_info(cursor, &frameInfo) == UNW_ESUCCESS)
     result = (uintptr_t)frameInfo.lsda;
   _LIBUNWIND_TRACE_API(
       "_Unwind_GetLanguageSpecificData(context=%p) => 0x%llx",
@@ -765,8 +916,8 @@ _Unwind_VRS_Set(_Unwind_Context *context, _Unwind_VRS_RegClass regclass,
     case _UVRSC_CORE:
       if (representation != _UVRSD_UINT32 || regno > 15)
         return _UVRSR_FAILED;
-      return unw_set_reg(cursor, (unw_regnum_t)(UNW_ARM_R0 + regno),
-                         *(unw_word_t *)valuep) == UNW_ESUCCESS
+      return __unw_set_reg(cursor, (unw_regnum_t)(UNW_ARM_R0 + regno),
+                           *(unw_word_t *)valuep) == UNW_ESUCCESS
                  ? _UVRSR_OK
                  : _UVRSR_FAILED;
     case _UVRSC_VFP:
@@ -776,28 +927,28 @@ _Unwind_VRS_Set(_Unwind_Context *context, _Unwind_VRS_RegClass regclass,
         // Can only touch d0-15 with FSTMFDX.
         if (regno > 15)
           return _UVRSR_FAILED;
-        unw_save_vfp_as_X(cursor);
+        __unw_save_vfp_as_X(cursor);
       } else {
         if (regno > 31)
           return _UVRSR_FAILED;
       }
-      return unw_set_fpreg(cursor, (unw_regnum_t)(UNW_ARM_D0 + regno),
-                           *(unw_fpreg_t *)valuep) == UNW_ESUCCESS
+      return __unw_set_fpreg(cursor, (unw_regnum_t)(UNW_ARM_D0 + regno),
+                             *(unw_fpreg_t *)valuep) == UNW_ESUCCESS
                  ? _UVRSR_OK
                  : _UVRSR_FAILED;
 #if defined(__ARM_WMMX)
     case _UVRSC_WMMXC:
       if (representation != _UVRSD_UINT32 || regno > 3)
         return _UVRSR_FAILED;
-      return unw_set_reg(cursor, (unw_regnum_t)(UNW_ARM_WC0 + regno),
-                         *(unw_word_t *)valuep) == UNW_ESUCCESS
+      return __unw_set_reg(cursor, (unw_regnum_t)(UNW_ARM_WC0 + regno),
+                           *(unw_word_t *)valuep) == UNW_ESUCCESS
                  ? _UVRSR_OK
                  : _UVRSR_FAILED;
     case _UVRSC_WMMXD:
       if (representation != _UVRSD_DOUBLE || regno > 31)
         return _UVRSR_FAILED;
-      return unw_set_fpreg(cursor, (unw_regnum_t)(UNW_ARM_WR0 + regno),
-                           *(unw_fpreg_t *)valuep) == UNW_ESUCCESS
+      return __unw_set_fpreg(cursor, (unw_regnum_t)(UNW_ARM_WR0 + regno),
+                             *(unw_fpreg_t *)valuep) == UNW_ESUCCESS
                  ? _UVRSR_OK
                  : _UVRSR_FAILED;
 #else
@@ -805,6 +956,15 @@ _Unwind_VRS_Set(_Unwind_Context *context, _Unwind_VRS_RegClass regclass,
     case _UVRSC_WMMXD:
       break;
 #endif
+    case _UVRSC_PSEUDO:
+      // There's only one pseudo-register, PAC, with regno == 0.
+      if (representation != _UVRSD_UINT32 || regno != 0)
+        return _UVRSR_FAILED;
+      return __unw_set_reg(cursor, (unw_regnum_t)(UNW_ARM_RA_AUTH_CODE),
+                           *(unw_word_t *)valuep) == UNW_ESUCCESS
+                 ? _UVRSR_OK
+                 : _UVRSR_FAILED;
+      break;
   }
   _LIBUNWIND_ABORT("unsupported register class");
 }
@@ -819,8 +979,8 @@ _Unwind_VRS_Get_Internal(_Unwind_Context *context,
     case _UVRSC_CORE:
       if (representation != _UVRSD_UINT32 || regno > 15)
         return _UVRSR_FAILED;
-      return unw_get_reg(cursor, (unw_regnum_t)(UNW_ARM_R0 + regno),
-                         (unw_word_t *)valuep) == UNW_ESUCCESS
+      return __unw_get_reg(cursor, (unw_regnum_t)(UNW_ARM_R0 + regno),
+                           (unw_word_t *)valuep) == UNW_ESUCCESS
                  ? _UVRSR_OK
                  : _UVRSR_FAILED;
     case _UVRSC_VFP:
@@ -830,28 +990,28 @@ _Unwind_VRS_Get_Internal(_Unwind_Context *context,
         // Can only touch d0-15 with FSTMFDX.
         if (regno > 15)
           return _UVRSR_FAILED;
-        unw_save_vfp_as_X(cursor);
+        __unw_save_vfp_as_X(cursor);
       } else {
         if (regno > 31)
           return _UVRSR_FAILED;
       }
-      return unw_get_fpreg(cursor, (unw_regnum_t)(UNW_ARM_D0 + regno),
-                           (unw_fpreg_t *)valuep) == UNW_ESUCCESS
+      return __unw_get_fpreg(cursor, (unw_regnum_t)(UNW_ARM_D0 + regno),
+                             (unw_fpreg_t *)valuep) == UNW_ESUCCESS
                  ? _UVRSR_OK
                  : _UVRSR_FAILED;
 #if defined(__ARM_WMMX)
     case _UVRSC_WMMXC:
       if (representation != _UVRSD_UINT32 || regno > 3)
         return _UVRSR_FAILED;
-      return unw_get_reg(cursor, (unw_regnum_t)(UNW_ARM_WC0 + regno),
-                         (unw_word_t *)valuep) == UNW_ESUCCESS
+      return __unw_get_reg(cursor, (unw_regnum_t)(UNW_ARM_WC0 + regno),
+                           (unw_word_t *)valuep) == UNW_ESUCCESS
                  ? _UVRSR_OK
                  : _UVRSR_FAILED;
     case _UVRSC_WMMXD:
       if (representation != _UVRSD_DOUBLE || regno > 31)
         return _UVRSR_FAILED;
-      return unw_get_fpreg(cursor, (unw_regnum_t)(UNW_ARM_WR0 + regno),
-                           (unw_fpreg_t *)valuep) == UNW_ESUCCESS
+      return __unw_get_fpreg(cursor, (unw_regnum_t)(UNW_ARM_WR0 + regno),
+                             (unw_fpreg_t *)valuep) == UNW_ESUCCESS
                  ? _UVRSR_OK
                  : _UVRSR_FAILED;
 #else
@@ -859,6 +1019,15 @@ _Unwind_VRS_Get_Internal(_Unwind_Context *context,
     case _UVRSC_WMMXD:
       break;
 #endif
+    case _UVRSC_PSEUDO:
+      // There's only one pseudo-register, PAC, with regno == 0.
+      if (representation != _UVRSD_UINT32 || regno != 0)
+        return _UVRSR_FAILED;
+      return __unw_get_reg(cursor, (unw_regnum_t)(UNW_ARM_RA_AUTH_CODE),
+                           (unw_word_t *)valuep) == UNW_ESUCCESS
+                 ? _UVRSR_OK
+                 : _UVRSR_FAILED;
+      break;
   }
   _LIBUNWIND_ABORT("unsupported register class");
 }
@@ -938,8 +1107,15 @@ _Unwind_VRS_Pop(_Unwind_Context *context, _Unwind_VRS_RegClass regclass,
       // format 1", which is equivalent to FSTMD + a padding word.
       for (uint32_t i = first; i < end; ++i) {
         // SP is only 32-bit aligned so don't copy 64-bit at a time.
-        uint64_t value = *sp++;
-        value |= ((uint64_t)(*sp++)) << 32;
+        uint64_t w0 = *sp++;
+        uint64_t w1 = *sp++;
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+        uint64_t value = (w1 << 32) | w0;
+#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+        uint64_t value = (w0 << 32) | w1;
+#else
+#error "Unable to determine endianess"
+#endif
         if (_Unwind_VRS_Set(context, regclass, i, representation, &value) !=
             _UVRSR_OK)
           return _UVRSR_FAILED;
@@ -949,10 +1125,45 @@ _Unwind_VRS_Pop(_Unwind_Context *context, _Unwind_VRS_RegClass regclass,
       return _Unwind_VRS_Set(context, _UVRSC_CORE, UNW_ARM_SP, _UVRSD_UINT32,
                              &sp);
     }
+    case _UVRSC_PSEUDO: {
+      if (representation != _UVRSD_UINT32 || discriminator != 0)
+        return _UVRSR_FAILED;
+      // Return Address Authentication code (PAC) - discriminator 0
+      uint32_t *sp;
+      if (_Unwind_VRS_Get(context, _UVRSC_CORE, UNW_ARM_SP, _UVRSD_UINT32,
+                          &sp) != _UVRSR_OK) {
+        return _UVRSR_FAILED;
+      }
+      uint32_t pac = *sp++;
+      _Unwind_VRS_Set(context, _UVRSC_CORE, UNW_ARM_SP, _UVRSD_UINT32, &sp);
+      return _Unwind_VRS_Set(context, _UVRSC_CORE, UNW_ARM_RA_AUTH_CODE,
+                             _UVRSD_UINT32, &pac);
+    }
   }
   _LIBUNWIND_ABORT("unsupported register class");
 }
 
+/// Not used by C++.
+/// Unwinds stack, calling "stop" function at each frame.
+/// Could be used to implement longjmp().
+_LIBUNWIND_EXPORT _Unwind_Reason_Code
+_Unwind_ForcedUnwind(_Unwind_Exception *exception_object, _Unwind_Stop_Fn stop,
+                     void *stop_parameter) {
+  _LIBUNWIND_TRACE_API("_Unwind_ForcedUnwind(ex_obj=%p, stop=%p)",
+                       (void *)exception_object, (void *)(uintptr_t)stop);
+  unw_context_t uc;
+  unw_cursor_t cursor;
+  __unw_getcontext(&uc);
+
+  // Mark that this is a forced unwind, so _Unwind_Resume() can do
+  // the right thing.
+  exception_object->unwinder_cache.reserved1 = (uintptr_t)stop;
+  exception_object->unwinder_cache.reserved3 = (uintptr_t)stop_parameter;
+
+  return unwind_phase2_forced(&uc, &cursor, exception_object, stop,
+                              stop_parameter);
+}
+
 /// Called by personality handler during phase 2 to find the start of the
 /// function.
 _LIBUNWIND_EXPORT uintptr_t
@@ -960,7 +1171,7 @@ _Unwind_GetRegionStart(struct _Unwind_Context *context) {
   unw_cursor_t *cursor = (unw_cursor_t *)context;
   unw_proc_info_t frameInfo;
   uintptr_t result = 0;
-  if (unw_get_proc_info(cursor, &frameInfo) == UNW_ESUCCESS)
+  if (__unw_get_proc_info(cursor, &frameInfo) == UNW_ESUCCESS)
     result = (uintptr_t)frameInfo.start_ip;
   _LIBUNWIND_TRACE_API("_Unwind_GetRegionStart(context=%p) => 0x%llX",
                        static_cast<void *>(context), (long long)result);
@@ -983,9 +1194,14 @@ extern "C" _LIBUNWIND_EXPORT _Unwind_Reason_Code
 __gnu_unwind_frame(_Unwind_Exception *exception_object,
                    struct _Unwind_Context *context) {
   unw_cursor_t *cursor = (unw_cursor_t *)context;
-  if (unw_step(cursor) != UNW_STEP_SUCCESS)
+  switch (__unw_step(cursor)) {
+  case UNW_STEP_SUCCESS:
+    return _URC_OK;
+  case UNW_STEP_END:
+    return _URC_END_OF_STACK;
+  default:
     return _URC_FAILURE;
-  return _URC_OK;
+  }
 }
 
 #endif  // defined(_LIBUNWIND_ARM_EHABI)
diff --git a/WAVM/ThirdParty/libunwind/src/Unwind-EHABI.h b/WAVM/ThirdParty/libunwind/src/Unwind-EHABI.h
index fe164ff7..ff3b5fc6 100644
--- a/WAVM/ThirdParty/libunwind/src/Unwind-EHABI.h
+++ b/WAVM/ThirdParty/libunwind/src/Unwind-EHABI.h
@@ -1,9 +1,8 @@
-//===------------------------- Unwind-EHABI.hpp ---------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
+//===----------------------------------------------------------------------===//
 //
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //
 //===----------------------------------------------------------------------===//
diff --git a/WAVM/ThirdParty/libunwind/src/Unwind-seh.cpp b/WAVM/ThirdParty/libunwind/src/Unwind-seh.cpp
new file mode 100644
index 00000000..f00bc472
--- /dev/null
+++ b/WAVM/ThirdParty/libunwind/src/Unwind-seh.cpp
@@ -0,0 +1,491 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+//  Implements SEH-based Itanium C++ exceptions.
+//
+//===----------------------------------------------------------------------===//
+
+#include "config.h"
+
+#if defined(_LIBUNWIND_SUPPORT_SEH_UNWIND)
+
+#include <unwind.h>
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <stdlib.h>
+
+#include <windef.h>
+#include <excpt.h>
+#include <winnt.h>
+#include <ntstatus.h>
+
+#include "libunwind_ext.h"
+#include "UnwindCursor.hpp"
+
+using namespace libunwind;
+
+#define STATUS_USER_DEFINED (1u << 29)
+
+#define STATUS_GCC_MAGIC  (('G' << 16) | ('C' << 8) | 'C')
+
+#define MAKE_CUSTOM_STATUS(s, c) \
+  ((NTSTATUS)(((s) << 30) | STATUS_USER_DEFINED | (c)))
+#define MAKE_GCC_EXCEPTION(c) \
+  MAKE_CUSTOM_STATUS(STATUS_SEVERITY_SUCCESS, STATUS_GCC_MAGIC | ((c) << 24))
+
+/// SEH exception raised by libunwind when the program calls
+/// \c _Unwind_RaiseException.
+#define STATUS_GCC_THROW MAKE_GCC_EXCEPTION(0) // 0x20474343
+/// SEH exception raised by libunwind to initiate phase 2 of exception
+/// handling.
+#define STATUS_GCC_UNWIND MAKE_GCC_EXCEPTION(1) // 0x21474343
+
+static int __unw_init_seh(unw_cursor_t *cursor, CONTEXT *ctx);
+static DISPATCHER_CONTEXT *__unw_seh_get_disp_ctx(unw_cursor_t *cursor);
+static void __unw_seh_set_disp_ctx(unw_cursor_t *cursor,
+                                   DISPATCHER_CONTEXT *disp);
+
+/// Common implementation of SEH-style handler functions used by Itanium-
+/// style frames.  Depending on how and why it was called, it may do one of:
+///  a) Delegate to the given Itanium-style personality function; or
+///  b) Initiate a collided unwind to halt unwinding.
+_LIBUNWIND_EXPORT EXCEPTION_DISPOSITION
+_GCC_specific_handler(PEXCEPTION_RECORD ms_exc, PVOID frame, PCONTEXT ms_ctx,
+                      DISPATCHER_CONTEXT *disp, _Unwind_Personality_Fn pers) {
+  unw_cursor_t cursor;
+  _Unwind_Exception *exc;
+  _Unwind_Action action;
+  struct _Unwind_Context *ctx = nullptr;
+  _Unwind_Reason_Code urc;
+  uintptr_t retval, target;
+  bool ours = false;
+
+  _LIBUNWIND_TRACE_UNWINDING("_GCC_specific_handler(%#010lx(%lx), %p)",
+                             ms_exc->ExceptionCode, ms_exc->ExceptionFlags,
+                             (void *)frame);
+  if (ms_exc->ExceptionCode == STATUS_GCC_UNWIND) {
+    if (IS_TARGET_UNWIND(ms_exc->ExceptionFlags)) {
+      // Set up the upper return value (the lower one and the target PC
+      // were set in the call to RtlUnwindEx()) for the landing pad.
+#ifdef __x86_64__
+      disp->ContextRecord->Rdx = ms_exc->ExceptionInformation[3];
+#elif defined(__arm__)
+      disp->ContextRecord->R1 = ms_exc->ExceptionInformation[3];
+#elif defined(__aarch64__)
+      disp->ContextRecord->X1 = ms_exc->ExceptionInformation[3];
+#endif
+    }
+    // This is the collided unwind to the landing pad. Nothing to do.
+    return ExceptionContinueSearch;
+  }
+
+  if (ms_exc->ExceptionCode == STATUS_GCC_THROW) {
+    // This is (probably) a libunwind-controlled exception/unwind. Recover the
+    // parameters which we set below, and pass them to the personality function.
+    ours = true;
+    exc = (_Unwind_Exception *)ms_exc->ExceptionInformation[0];
+    if (!IS_UNWINDING(ms_exc->ExceptionFlags) && ms_exc->NumberParameters > 1) {
+      ctx = (struct _Unwind_Context *)ms_exc->ExceptionInformation[1];
+      action = (_Unwind_Action)ms_exc->ExceptionInformation[2];
+    }
+  } else {
+    // Foreign exception.
+    // We can't interact with them (we don't know the original target frame
+    // that we should pass on to RtlUnwindEx in _Unwind_Resume), so just
+    // pass without calling our destructors here.
+    return ExceptionContinueSearch;
+  }
+  if (!ctx) {
+    __unw_init_seh(&cursor, disp->ContextRecord);
+    __unw_seh_set_disp_ctx(&cursor, disp);
+    __unw_set_reg(&cursor, UNW_REG_IP, disp->ControlPc - 1);
+    ctx = (struct _Unwind_Context *)&cursor;
+
+    if (!IS_UNWINDING(ms_exc->ExceptionFlags)) {
+      if (ours && ms_exc->NumberParameters > 1)
+        action =  (_Unwind_Action)(_UA_CLEANUP_PHASE | _UA_FORCE_UNWIND);
+      else
+        action = _UA_SEARCH_PHASE;
+    } else {
+      if (ours && ms_exc->ExceptionInformation[1] == (ULONG_PTR)frame)
+        action = (_Unwind_Action)(_UA_CLEANUP_PHASE | _UA_HANDLER_FRAME);
+      else
+        action = _UA_CLEANUP_PHASE;
+    }
+  }
+
+  _LIBUNWIND_TRACE_UNWINDING("_GCC_specific_handler() calling personality "
+                             "function %p(1, %d, %llx, %p, %p)",
+                             (void *)pers, action, exc->exception_class,
+                             (void *)exc, (void *)ctx);
+  urc = pers(1, action, exc->exception_class, exc, ctx);
+  _LIBUNWIND_TRACE_UNWINDING("_GCC_specific_handler() personality returned %d", urc);
+  switch (urc) {
+  case _URC_CONTINUE_UNWIND:
+    // If we're in phase 2, and the personality routine said to continue
+    // at the target frame, we're in real trouble.
+    if (action & _UA_HANDLER_FRAME)
+      _LIBUNWIND_ABORT("Personality continued unwind at the target frame!");
+    return ExceptionContinueSearch;
+  case _URC_HANDLER_FOUND:
+    // If we were called by __libunwind_seh_personality(), indicate that
+    // a handler was found; otherwise, initiate phase 2 by unwinding.
+    if (ours && ms_exc->NumberParameters > 1)
+      return 4 /* ExecptionExecuteHandler in mingw */;
+    // This should never happen in phase 2.
+    if (IS_UNWINDING(ms_exc->ExceptionFlags))
+      _LIBUNWIND_ABORT("Personality indicated exception handler in phase 2!");
+    exc->private_[1] = (ULONG_PTR)frame;
+    if (ours) {
+      ms_exc->NumberParameters = 4;
+      ms_exc->ExceptionInformation[1] = (ULONG_PTR)frame;
+    }
+    // FIXME: Indicate target frame in foreign case!
+    // phase 2: the clean up phase
+    RtlUnwindEx(frame, (PVOID)disp->ControlPc, ms_exc, exc, ms_ctx, disp->HistoryTable);
+    _LIBUNWIND_ABORT("RtlUnwindEx() failed");
+  case _URC_INSTALL_CONTEXT: {
+    // If we were called by __libunwind_seh_personality(), indicate that
+    // a handler was found; otherwise, it's time to initiate a collided
+    // unwind to the target.
+    if (ours && !IS_UNWINDING(ms_exc->ExceptionFlags) && ms_exc->NumberParameters > 1)
+      return 4 /* ExecptionExecuteHandler in mingw */;
+    // This should never happen in phase 1.
+    if (!IS_UNWINDING(ms_exc->ExceptionFlags))
+      _LIBUNWIND_ABORT("Personality installed context during phase 1!");
+#ifdef __x86_64__
+    exc->private_[2] = disp->TargetIp;
+    __unw_get_reg(&cursor, UNW_X86_64_RAX, &retval);
+    __unw_get_reg(&cursor, UNW_X86_64_RDX, &exc->private_[3]);
+#elif defined(__arm__)
+    exc->private_[2] = disp->TargetPc;
+    __unw_get_reg(&cursor, UNW_ARM_R0, &retval);
+    __unw_get_reg(&cursor, UNW_ARM_R1, &exc->private_[3]);
+#elif defined(__aarch64__)
+    exc->private_[2] = disp->TargetPc;
+    __unw_get_reg(&cursor, UNW_AARCH64_X0, &retval);
+    __unw_get_reg(&cursor, UNW_AARCH64_X1, &exc->private_[3]);
+#endif
+    __unw_get_reg(&cursor, UNW_REG_IP, &target);
+    ms_exc->ExceptionCode = STATUS_GCC_UNWIND;
+#ifdef __x86_64__
+    ms_exc->ExceptionInformation[2] = disp->TargetIp;
+#elif defined(__arm__) || defined(__aarch64__)
+    ms_exc->ExceptionInformation[2] = disp->TargetPc;
+#endif
+    ms_exc->ExceptionInformation[3] = exc->private_[3];
+    // Give NTRTL some scratch space to keep track of the collided unwind.
+    // Don't use the one that was passed in; we don't want to overwrite the
+    // context in the DISPATCHER_CONTEXT.
+    CONTEXT new_ctx;
+    RtlUnwindEx(frame, (PVOID)target, ms_exc, (PVOID)retval, &new_ctx, disp->HistoryTable);
+    _LIBUNWIND_ABORT("RtlUnwindEx() failed");
+  }
+  // Anything else indicates a serious problem.
+  default: return ExceptionContinueExecution;
+  }
+}
+
+/// Personality function returned by \c __unw_get_proc_info() in SEH contexts.
+/// This is a wrapper that calls the real SEH handler function, which in
+/// turn (at least, for Itanium-style frames) calls the real Itanium
+/// personality function (see \c _GCC_specific_handler()).
+extern "C" _Unwind_Reason_Code
+__libunwind_seh_personality(int version, _Unwind_Action state,
+                            uint64_t klass, _Unwind_Exception *exc,
+                            struct _Unwind_Context *context) {
+  (void)version;
+  (void)klass;
+  EXCEPTION_RECORD ms_exc;
+  bool phase2 = (state & (_UA_SEARCH_PHASE|_UA_CLEANUP_PHASE)) == _UA_CLEANUP_PHASE;
+  ms_exc.ExceptionCode = STATUS_GCC_THROW;
+  ms_exc.ExceptionFlags = 0;
+  ms_exc.NumberParameters = 3;
+  ms_exc.ExceptionInformation[0] = (ULONG_PTR)exc;
+  ms_exc.ExceptionInformation[1] = (ULONG_PTR)context;
+  ms_exc.ExceptionInformation[2] = state;
+  DISPATCHER_CONTEXT *disp_ctx =
+      __unw_seh_get_disp_ctx((unw_cursor_t *)context);
+  EXCEPTION_DISPOSITION ms_act = disp_ctx->LanguageHandler(&ms_exc,
+                                                           (PVOID)disp_ctx->EstablisherFrame,
+                                                           disp_ctx->ContextRecord,
+                                                           disp_ctx);
+  switch (ms_act) {
+  case ExceptionContinueSearch: return _URC_CONTINUE_UNWIND;
+  case 4 /*ExceptionExecuteHandler*/:
+    return phase2 ? _URC_INSTALL_CONTEXT : _URC_HANDLER_FOUND;
+  default:
+    return phase2 ? _URC_FATAL_PHASE2_ERROR : _URC_FATAL_PHASE1_ERROR;
+  }
+}
+
+static _Unwind_Reason_Code
+unwind_phase2_forced(unw_context_t *uc,
+                     _Unwind_Exception *exception_object,
+                     _Unwind_Stop_Fn stop, void *stop_parameter) {
+  unw_cursor_t cursor2;
+  __unw_init_local(&cursor2, uc);
+
+  // Walk each frame until we reach where search phase said to stop
+  while (__unw_step(&cursor2) > 0) {
+
+    // Update info about this frame.
+    unw_proc_info_t frameInfo;
+    if (__unw_get_proc_info(&cursor2, &frameInfo) != UNW_ESUCCESS) {
+      _LIBUNWIND_TRACE_UNWINDING("unwind_phase2_forced(ex_ojb=%p): __unw_step "
+                                 "failed => _URC_END_OF_STACK",
+                                 (void *)exception_object);
+      return _URC_FATAL_PHASE2_ERROR;
+    }
+
+#ifndef NDEBUG
+    // When tracing, print state information.
+    if (_LIBUNWIND_TRACING_UNWINDING) {
+      char functionBuf[512];
+      const char *functionName = functionBuf;
+      unw_word_t offset;
+      if ((__unw_get_proc_name(&cursor2, functionBuf, sizeof(functionBuf),
+                               &offset) != UNW_ESUCCESS) ||
+          (frameInfo.start_ip + offset > frameInfo.end_ip))
+        functionName = ".anonymous.";
+      _LIBUNWIND_TRACE_UNWINDING(
+          "unwind_phase2_forced(ex_ojb=%p): start_ip=0x%" PRIx64
+          ", func=%s, lsda=0x%" PRIx64 ", personality=0x%" PRIx64,
+          (void *)exception_object, frameInfo.start_ip, functionName,
+          frameInfo.lsda, frameInfo.handler);
+    }
+#endif
+
+    // Call stop function at each frame.
+    _Unwind_Action action =
+        (_Unwind_Action)(_UA_FORCE_UNWIND | _UA_CLEANUP_PHASE);
+    _Unwind_Reason_Code stopResult =
+        (*stop)(1, action, exception_object->exception_class, exception_object,
+                (struct _Unwind_Context *)(&cursor2), stop_parameter);
+    _LIBUNWIND_TRACE_UNWINDING(
+        "unwind_phase2_forced(ex_ojb=%p): stop function returned %d",
+        (void *)exception_object, stopResult);
+    if (stopResult != _URC_NO_REASON) {
+      _LIBUNWIND_TRACE_UNWINDING(
+          "unwind_phase2_forced(ex_ojb=%p): stopped by stop function",
+          (void *)exception_object);
+      return _URC_FATAL_PHASE2_ERROR;
+    }
+
+    // If there is a personality routine, tell it we are unwinding.
+    if (frameInfo.handler != 0) {
+      _Unwind_Personality_Fn p =
+          (_Unwind_Personality_Fn)(intptr_t)(frameInfo.handler);
+      _LIBUNWIND_TRACE_UNWINDING(
+          "unwind_phase2_forced(ex_ojb=%p): calling personality function %p",
+          (void *)exception_object, (void *)(uintptr_t)p);
+      _Unwind_Reason_Code personalityResult =
+          (*p)(1, action, exception_object->exception_class, exception_object,
+               (struct _Unwind_Context *)(&cursor2));
+      switch (personalityResult) {
+      case _URC_CONTINUE_UNWIND:
+        _LIBUNWIND_TRACE_UNWINDING("unwind_phase2_forced(ex_ojb=%p): "
+                                   "personality returned "
+                                   "_URC_CONTINUE_UNWIND",
+                                   (void *)exception_object);
+        // Destructors called, continue unwinding
+        break;
+      case _URC_INSTALL_CONTEXT:
+        _LIBUNWIND_TRACE_UNWINDING("unwind_phase2_forced(ex_ojb=%p): "
+                                   "personality returned "
+                                   "_URC_INSTALL_CONTEXT",
+                                   (void *)exception_object);
+        // We may get control back if landing pad calls _Unwind_Resume().
+        __unw_resume(&cursor2);
+        break;
+      default:
+        // Personality routine returned an unknown result code.
+        _LIBUNWIND_TRACE_UNWINDING("unwind_phase2_forced(ex_ojb=%p): "
+                                   "personality returned %d, "
+                                   "_URC_FATAL_PHASE2_ERROR",
+                                   (void *)exception_object, personalityResult);
+        return _URC_FATAL_PHASE2_ERROR;
+      }
+    }
+  }
+
+  // Call stop function one last time and tell it we've reached the end
+  // of the stack.
+  _LIBUNWIND_TRACE_UNWINDING("unwind_phase2_forced(ex_ojb=%p): calling stop "
+                             "function with _UA_END_OF_STACK",
+                             (void *)exception_object);
+  _Unwind_Action lastAction =
+      (_Unwind_Action)(_UA_FORCE_UNWIND | _UA_CLEANUP_PHASE | _UA_END_OF_STACK);
+  (*stop)(1, lastAction, exception_object->exception_class, exception_object,
+          (struct _Unwind_Context *)(&cursor2), stop_parameter);
+
+  // Clean up phase did not resume at the frame that the search phase said it
+  // would.
+  return _URC_FATAL_PHASE2_ERROR;
+}
+
+/// Called by \c __cxa_throw().  Only returns if there is a fatal error.
+_LIBUNWIND_EXPORT _Unwind_Reason_Code
+_Unwind_RaiseException(_Unwind_Exception *exception_object) {
+  _LIBUNWIND_TRACE_API("_Unwind_RaiseException(ex_obj=%p)",
+                       (void *)exception_object);
+
+  // Mark that this is a non-forced unwind, so _Unwind_Resume()
+  // can do the right thing.
+  memset(exception_object->private_, 0, sizeof(exception_object->private_));
+
+  // phase 1: the search phase
+  // We'll let the system do that for us.
+  RaiseException(STATUS_GCC_THROW, 0, 1, (ULONG_PTR *)&exception_object);
+
+  // If we get here, either something went horribly wrong or we reached the
+  // top of the stack. Either way, let libc++abi call std::terminate().
+  return _URC_END_OF_STACK;
+}
+
+/// When \c _Unwind_RaiseException() is in phase2, it hands control
+/// to the personality function at each frame.  The personality
+/// may force a jump to a landing pad in that function; the landing
+/// pad code may then call \c _Unwind_Resume() to continue with the
+/// unwinding.  Note: the call to \c _Unwind_Resume() is from compiler
+/// geneated user code.  All other \c _Unwind_* routines are called
+/// by the C++ runtime \c __cxa_* routines.
+///
+/// Note: re-throwing an exception (as opposed to continuing the unwind)
+/// is implemented by having the code call \c __cxa_rethrow() which
+/// in turn calls \c _Unwind_Resume_or_Rethrow().
+_LIBUNWIND_EXPORT void
+_Unwind_Resume(_Unwind_Exception *exception_object) {
+  _LIBUNWIND_TRACE_API("_Unwind_Resume(ex_obj=%p)", (void *)exception_object);
+
+  if (exception_object->private_[0] != 0) {
+    unw_context_t uc;
+
+    __unw_getcontext(&uc);
+    unwind_phase2_forced(&uc, exception_object,
+                         (_Unwind_Stop_Fn) exception_object->private_[0],
+                         (void *)exception_object->private_[4]);
+  } else {
+    // Recover the parameters for the unwind from the exception object
+    // so we can start unwinding again.
+    EXCEPTION_RECORD ms_exc;
+    CONTEXT ms_ctx;
+    UNWIND_HISTORY_TABLE hist;
+
+    memset(&ms_exc, 0, sizeof(ms_exc));
+    memset(&hist, 0, sizeof(hist));
+    ms_exc.ExceptionCode = STATUS_GCC_THROW;
+    ms_exc.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
+    ms_exc.NumberParameters = 4;
+    ms_exc.ExceptionInformation[0] = (ULONG_PTR)exception_object;
+    ms_exc.ExceptionInformation[1] = exception_object->private_[1];
+    ms_exc.ExceptionInformation[2] = exception_object->private_[2];
+    ms_exc.ExceptionInformation[3] = exception_object->private_[3];
+    RtlUnwindEx((PVOID)exception_object->private_[1],
+                (PVOID)exception_object->private_[2], &ms_exc,
+                exception_object, &ms_ctx, &hist);
+  }
+
+  // Clients assume _Unwind_Resume() does not return, so all we can do is abort.
+  _LIBUNWIND_ABORT("_Unwind_Resume() can't return");
+}
+
+/// Not used by C++.
+/// Unwinds stack, calling "stop" function at each frame.
+/// Could be used to implement \c longjmp().
+_LIBUNWIND_EXPORT _Unwind_Reason_Code
+_Unwind_ForcedUnwind(_Unwind_Exception *exception_object,
+                     _Unwind_Stop_Fn stop, void *stop_parameter) {
+  _LIBUNWIND_TRACE_API("_Unwind_ForcedUnwind(ex_obj=%p, stop=%p)",
+                       (void *)exception_object, (void *)(uintptr_t)stop);
+  unw_context_t uc;
+  __unw_getcontext(&uc);
+
+  // Mark that this is a forced unwind, so _Unwind_Resume() can do
+  // the right thing.
+  exception_object->private_[0] = (uintptr_t) stop;
+  exception_object->private_[4] = (uintptr_t) stop_parameter;
+
+  // do it
+  return unwind_phase2_forced(&uc, exception_object, stop, stop_parameter);
+}
+
+/// Called by personality handler during phase 2 to get LSDA for current frame.
+_LIBUNWIND_EXPORT uintptr_t
+_Unwind_GetLanguageSpecificData(struct _Unwind_Context *context) {
+  uintptr_t result =
+      (uintptr_t)__unw_seh_get_disp_ctx((unw_cursor_t *)context)->HandlerData;
+  _LIBUNWIND_TRACE_API(
+      "_Unwind_GetLanguageSpecificData(context=%p) => 0x%" PRIxPTR,
+      (void *)context, result);
+  return result;
+}
+
+/// Called by personality handler during phase 2 to find the start of the
+/// function.
+_LIBUNWIND_EXPORT uintptr_t
+_Unwind_GetRegionStart(struct _Unwind_Context *context) {
+  DISPATCHER_CONTEXT *disp = __unw_seh_get_disp_ctx((unw_cursor_t *)context);
+  uintptr_t result = (uintptr_t)disp->FunctionEntry->BeginAddress + disp->ImageBase;
+  _LIBUNWIND_TRACE_API("_Unwind_GetRegionStart(context=%p) => 0x%" PRIxPTR,
+                       (void *)context, result);
+  return result;
+}
+
+static int __unw_init_seh(unw_cursor_t *cursor, CONTEXT *context) {
+#ifdef _LIBUNWIND_TARGET_X86_64
+  new (reinterpret_cast<UnwindCursor<LocalAddressSpace, Registers_x86_64> *>(cursor))
+      UnwindCursor<LocalAddressSpace, Registers_x86_64>(
+          context, LocalAddressSpace::sThisAddressSpace);
+  auto *co = reinterpret_cast<AbstractUnwindCursor *>(cursor);
+  co->setInfoBasedOnIPRegister();
+  return UNW_ESUCCESS;
+#elif defined(_LIBUNWIND_TARGET_ARM)
+  new (reinterpret_cast<UnwindCursor<LocalAddressSpace, Registers_arm> *>(cursor))
+      UnwindCursor<LocalAddressSpace, Registers_arm>(
+          context, LocalAddressSpace::sThisAddressSpace);
+  auto *co = reinterpret_cast<AbstractUnwindCursor *>(cursor);
+  co->setInfoBasedOnIPRegister();
+  return UNW_ESUCCESS;
+#elif defined(_LIBUNWIND_TARGET_AARCH64)
+  new (reinterpret_cast<UnwindCursor<LocalAddressSpace, Registers_arm64> *>(cursor))
+      UnwindCursor<LocalAddressSpace, Registers_arm64>(
+          context, LocalAddressSpace::sThisAddressSpace);
+  auto *co = reinterpret_cast<AbstractUnwindCursor *>(cursor);
+  co->setInfoBasedOnIPRegister();
+  return UNW_ESUCCESS;
+#else
+  return UNW_EINVAL;
+#endif
+}
+
+static DISPATCHER_CONTEXT *__unw_seh_get_disp_ctx(unw_cursor_t *cursor) {
+#ifdef _LIBUNWIND_TARGET_X86_64
+  return reinterpret_cast<UnwindCursor<LocalAddressSpace, Registers_x86_64> *>(cursor)->getDispatcherContext();
+#elif defined(_LIBUNWIND_TARGET_ARM)
+  return reinterpret_cast<UnwindCursor<LocalAddressSpace, Registers_arm> *>(cursor)->getDispatcherContext();
+#elif defined(_LIBUNWIND_TARGET_AARCH64)
+  return reinterpret_cast<UnwindCursor<LocalAddressSpace, Registers_arm64> *>(cursor)->getDispatcherContext();
+#else
+  return nullptr;
+#endif
+}
+
+static void __unw_seh_set_disp_ctx(unw_cursor_t *cursor,
+                                   DISPATCHER_CONTEXT *disp) {
+#ifdef _LIBUNWIND_TARGET_X86_64
+  reinterpret_cast<UnwindCursor<LocalAddressSpace, Registers_x86_64> *>(cursor)->setDispatcherContext(disp);
+#elif defined(_LIBUNWIND_TARGET_ARM)
+  reinterpret_cast<UnwindCursor<LocalAddressSpace, Registers_arm> *>(cursor)->setDispatcherContext(disp);
+#elif defined(_LIBUNWIND_TARGET_AARCH64)
+  reinterpret_cast<UnwindCursor<LocalAddressSpace, Registers_arm64> *>(cursor)->setDispatcherContext(disp);
+#endif
+}
+
+#endif // defined(_LIBUNWIND_SUPPORT_SEH_UNWIND)
diff --git a/WAVM/ThirdParty/libunwind/src/Unwind-sjlj.c b/WAVM/ThirdParty/libunwind/src/Unwind-sjlj.c
index 90cac3f8..d487995b 100644
--- a/WAVM/ThirdParty/libunwind/src/Unwind-sjlj.c
+++ b/WAVM/ThirdParty/libunwind/src/Unwind-sjlj.c
@@ -1,9 +1,8 @@
-//===--------------------------- Unwind-sjlj.c ----------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
+//===----------------------------------------------------------------------===//
 //
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //
 //  Implements setjump-longjump based C++ exceptions
@@ -12,6 +11,7 @@
 
 #include <unwind.h>
 
+#include <inttypes.h>
 #include <stdint.h>
 #include <stdbool.h>
 #include <stdlib.h>
@@ -32,14 +32,26 @@ struct _Unwind_FunctionContext {
   // next function in stack of handlers
   struct _Unwind_FunctionContext *prev;
 
+#if defined(__ve__)
+  // VE requires to store 64 bit pointers in the buffer for SjLj execption.
+  // We expand the size of values defined here.  This size must be matched
+  // to the size returned by TargetMachine::getSjLjDataSize().
+
+  // set by calling function before registering to be the landing pad
+  uint64_t                        resumeLocation;
+
+  // set by personality handler to be parameters passed to landing pad function
+  uint64_t                        resumeParameters[4];
+#else
   // set by calling function before registering to be the landing pad
   uint32_t                        resumeLocation;
 
   // set by personality handler to be parameters passed to landing pad function
   uint32_t                        resumeParameters[4];
+#endif
 
   // set by calling function before registering
-  __personality_routine           personality; // arm offset=24
+  _Unwind_Personality_Fn personality;          // arm offset=24
   uintptr_t                       lsda;        // arm offset=28
 
   // variable length array, contains registers to restore
@@ -52,7 +64,7 @@ struct _Unwind_FunctionContext {
 #else
 # if __STDC_VERSION__ >= 201112L
 #  define _LIBUNWIND_THREAD_LOCAL _Thread_local
-# elif defined(_WIN32)
+# elif defined(_MSC_VER)
 #  define _LIBUNWIND_THREAD_LOCAL __declspec(thread)
 # elif defined(__GNUC__) || defined(__clang__)
 #  define _LIBUNWIND_THREAD_LOCAL __thread
@@ -108,7 +120,8 @@ _Unwind_SjLj_Unregister(struct _Unwind_FunctionContext *fc) {
 static _Unwind_Reason_Code
 unwind_phase1(struct _Unwind_Exception *exception_object) {
   _Unwind_FunctionContext_t c = __Unwind_SjLj_GetTopOfFunctionStack();
-  _LIBUNWIND_TRACE_UNWINDING("unwind_phase1: initial function-context=%p", c);
+  _LIBUNWIND_TRACE_UNWINDING("unwind_phase1: initial function-context=%p",
+                             (void *)c);
 
   // walk each frame looking for a place to stop
   for (bool handlerNotFound = true; handlerNotFound; c = c->prev) {
@@ -117,17 +130,18 @@ unwind_phase1(struct _Unwind_Exception *exception_object) {
     if (c == NULL) {
       _LIBUNWIND_TRACE_UNWINDING("unwind_phase1(ex_ojb=%p): reached "
                                  "bottom => _URC_END_OF_STACK",
-                                  exception_object);
+                                 (void *)exception_object);
       return _URC_END_OF_STACK;
     }
 
-    _LIBUNWIND_TRACE_UNWINDING("unwind_phase1: function-context=%p", c);
+    _LIBUNWIND_TRACE_UNWINDING("unwind_phase1: function-context=%p", (void *)c);
     // if there is a personality routine, ask it if it will want to stop at this
     // frame
     if (c->personality != NULL) {
       _LIBUNWIND_TRACE_UNWINDING("unwind_phase1(ex_ojb=%p): calling "
-                                "personality function %p",
-                                 exception_object, c->personality);
+                                 "personality function %p",
+                                 (void *)exception_object,
+                                 (void *)c->personality);
       _Unwind_Reason_Code personalityResult = (*c->personality)(
           1, _UA_SEARCH_PHASE, exception_object->exception_class,
           exception_object, (struct _Unwind_Context *)c);
@@ -138,12 +152,14 @@ unwind_phase1(struct _Unwind_Exception *exception_object) {
         handlerNotFound = false;
         exception_object->private_2 = (uintptr_t) c;
         _LIBUNWIND_TRACE_UNWINDING("unwind_phase1(ex_ojb=%p): "
-                                   "_URC_HANDLER_FOUND", exception_object);
+                                   "_URC_HANDLER_FOUND",
+                                   (void *)exception_object);
         return _URC_NO_REASON;
 
       case _URC_CONTINUE_UNWIND:
         _LIBUNWIND_TRACE_UNWINDING("unwind_phase1(ex_ojb=%p): "
-                                   "_URC_CONTINUE_UNWIND", exception_object);
+                                   "_URC_CONTINUE_UNWIND",
+                                   (void *)exception_object);
         // continue unwinding
         break;
 
@@ -151,7 +167,7 @@ unwind_phase1(struct _Unwind_Exception *exception_object) {
         // something went wrong
         _LIBUNWIND_TRACE_UNWINDING(
             "unwind_phase1(ex_ojb=%p): _URC_FATAL_PHASE1_ERROR",
-            exception_object);
+            (void *)exception_object);
         return _URC_FATAL_PHASE1_ERROR;
       }
     }
@@ -162,19 +178,21 @@ unwind_phase1(struct _Unwind_Exception *exception_object) {
 
 static _Unwind_Reason_Code
 unwind_phase2(struct _Unwind_Exception *exception_object) {
-  _LIBUNWIND_TRACE_UNWINDING("unwind_phase2(ex_ojb=%p)", exception_object);
+  _LIBUNWIND_TRACE_UNWINDING("unwind_phase2(ex_ojb=%p)",
+                             (void *)exception_object);
 
   // walk each frame until we reach where search phase said to stop
   _Unwind_FunctionContext_t c = __Unwind_SjLj_GetTopOfFunctionStack();
   while (true) {
     _LIBUNWIND_TRACE_UNWINDING("unwind_phase2s(ex_ojb=%p): context=%p",
-                              exception_object, c);
+                               (void *)exception_object, (void *)c);
 
     // check for no more frames
     if (c == NULL) {
-      _LIBUNWIND_TRACE_UNWINDING("unwind_phase2(ex_ojb=%p): unw_step() reached "
-                                "bottom => _URC_END_OF_STACK",
-                                 exception_object);
+      _LIBUNWIND_TRACE_UNWINDING(
+          "unwind_phase2(ex_ojb=%p): __unw_step() reached "
+          "bottom => _URC_END_OF_STACK",
+          (void *)exception_object);
       return _URC_END_OF_STACK;
     }
 
@@ -194,7 +212,7 @@ unwind_phase2(struct _Unwind_Exception *exception_object) {
         // continue unwinding
         _LIBUNWIND_TRACE_UNWINDING(
             "unwind_phase2(ex_ojb=%p): _URC_CONTINUE_UNWIND",
-            exception_object);
+            (void *)exception_object);
         if ((uintptr_t) c == exception_object->private_2) {
           // phase 1 said we would stop at this frame, but we did not...
           _LIBUNWIND_ABORT("during phase1 personality function said it would "
@@ -203,14 +221,14 @@ unwind_phase2(struct _Unwind_Exception *exception_object) {
         break;
       case _URC_INSTALL_CONTEXT:
         _LIBUNWIND_TRACE_UNWINDING("unwind_phase2(ex_ojb=%p): "
-                                  "_URC_INSTALL_CONTEXT, will resume at "
-                                  "landing pad %p",
-                                  exception_object, c->jbuf[1]);
+                                   "_URC_INSTALL_CONTEXT, will resume at "
+                                   "landing pad %p",
+                                   (void *)exception_object, c->jbuf[1]);
         // personality routine says to transfer control to landing pad
         // we may get control back if landing pad calls _Unwind_Resume()
         __Unwind_SjLj_SetTopOfFunctionStack(c);
         __builtin_longjmp(c->jbuf, 1);
-        // unw_resume() only returns if there was an error
+        // __unw_resume() only returns if there was an error
         return _URC_FATAL_PHASE2_ERROR;
       default:
         // something went wrong
@@ -237,9 +255,10 @@ unwind_phase2_forced(struct _Unwind_Exception *exception_object,
 
     // get next frame (skip over first which is _Unwind_RaiseException)
     if (c == NULL) {
-      _LIBUNWIND_TRACE_UNWINDING("unwind_phase2(ex_ojb=%p): unw_step() reached "
-                                 "bottom => _URC_END_OF_STACK",
-                                 exception_object);
+      _LIBUNWIND_TRACE_UNWINDING(
+          "unwind_phase2(ex_ojb=%p): __unw_step() reached "
+          "bottom => _URC_END_OF_STACK",
+          (void *)exception_object);
       return _URC_END_OF_STACK;
     }
 
@@ -251,20 +270,20 @@ unwind_phase2_forced(struct _Unwind_Exception *exception_object,
                 (struct _Unwind_Context *)c, stop_parameter);
     _LIBUNWIND_TRACE_UNWINDING("unwind_phase2_forced(ex_ojb=%p): "
                                "stop function returned %d",
-                                exception_object, stopResult);
+                               (void *)exception_object, stopResult);
     if (stopResult != _URC_NO_REASON) {
       _LIBUNWIND_TRACE_UNWINDING("unwind_phase2_forced(ex_ojb=%p): "
                                  "stopped by stop function",
-                                  exception_object);
+                                 (void *)exception_object);
       return _URC_FATAL_PHASE2_ERROR;
     }
 
     // if there is a personality routine, tell it we are unwinding
     if (c->personality != NULL) {
-      __personality_routine p = (__personality_routine) c->personality;
+      _Unwind_Personality_Fn p = (_Unwind_Personality_Fn)c->personality;
       _LIBUNWIND_TRACE_UNWINDING("unwind_phase2_forced(ex_ojb=%p): "
                                  "calling personality function %p",
-                                  exception_object, p);
+                                 (void *)exception_object, (void *)p);
       _Unwind_Reason_Code personalityResult =
           (*p)(1, action, exception_object->exception_class, exception_object,
                (struct _Unwind_Context *)c);
@@ -272,13 +291,13 @@ unwind_phase2_forced(struct _Unwind_Exception *exception_object,
       case _URC_CONTINUE_UNWIND:
         _LIBUNWIND_TRACE_UNWINDING("unwind_phase2_forced(ex_ojb=%p):  "
                                    "personality returned _URC_CONTINUE_UNWIND",
-                                    exception_object);
+                                   (void *)exception_object);
         // destructors called, continue unwinding
         break;
       case _URC_INSTALL_CONTEXT:
         _LIBUNWIND_TRACE_UNWINDING("unwind_phase2_forced(ex_ojb=%p): "
                                    "personality returned _URC_INSTALL_CONTEXT",
-                                    exception_object);
+                                   (void *)exception_object);
         // we may get control back if landing pad calls _Unwind_Resume()
         __Unwind_SjLj_SetTopOfFunctionStack(c);
         __builtin_longjmp(c->jbuf, 1);
@@ -288,7 +307,7 @@ unwind_phase2_forced(struct _Unwind_Exception *exception_object,
         _LIBUNWIND_TRACE_UNWINDING("unwind_phase2_forced(ex_ojb=%p): "
                                    "personality returned %d, "
                                    "_URC_FATAL_PHASE2_ERROR",
-                                    exception_object, personalityResult);
+                                   (void *)exception_object, personalityResult);
         return _URC_FATAL_PHASE2_ERROR;
       }
     }
@@ -298,8 +317,8 @@ unwind_phase2_forced(struct _Unwind_Exception *exception_object,
   // call stop function one last time and tell it we've reached the end of the
   // stack
   _LIBUNWIND_TRACE_UNWINDING("unwind_phase2_forced(ex_ojb=%p): calling stop "
-                        "function with _UA_END_OF_STACK",
-                        exception_object);
+                             "function with _UA_END_OF_STACK",
+                             (void *)exception_object);
   _Unwind_Action lastAction =
       (_Unwind_Action)(_UA_FORCE_UNWIND | _UA_CLEANUP_PHASE | _UA_END_OF_STACK);
   (*stop)(1, lastAction, exception_object->exception_class, exception_object,
@@ -314,7 +333,8 @@ unwind_phase2_forced(struct _Unwind_Exception *exception_object,
 /// Called by __cxa_throw.  Only returns if there is a fatal error
 _LIBUNWIND_EXPORT _Unwind_Reason_Code
 _Unwind_SjLj_RaiseException(struct _Unwind_Exception *exception_object) {
-  _LIBUNWIND_TRACE_API("_Unwind_SjLj_RaiseException(ex_obj=%p)", exception_object);
+  _LIBUNWIND_TRACE_API("_Unwind_SjLj_RaiseException(ex_obj=%p)",
+                       (void *)exception_object);
 
   // mark that this is a non-forced unwind, so _Unwind_Resume() can do the right
   // thing
@@ -344,7 +364,8 @@ _Unwind_SjLj_RaiseException(struct _Unwind_Exception *exception_object) {
 /// __cxa_rethrow() which in turn calls _Unwind_Resume_or_Rethrow()
 _LIBUNWIND_EXPORT void
 _Unwind_SjLj_Resume(struct _Unwind_Exception *exception_object) {
-  _LIBUNWIND_TRACE_API("_Unwind_SjLj_Resume(ex_obj=%p)", exception_object);
+  _LIBUNWIND_TRACE_API("_Unwind_SjLj_Resume(ex_obj=%p)",
+                       (void *)exception_object);
 
   if (exception_object->private_1 != 0)
     unwind_phase2_forced(exception_object,
@@ -362,8 +383,8 @@ _Unwind_SjLj_Resume(struct _Unwind_Exception *exception_object) {
 _LIBUNWIND_EXPORT _Unwind_Reason_Code
 _Unwind_SjLj_Resume_or_Rethrow(struct _Unwind_Exception *exception_object) {
   _LIBUNWIND_TRACE_API("__Unwind_SjLj_Resume_or_Rethrow(ex_obj=%p), "
-                             "private_1=%ld",
-                              exception_object, exception_object->private_1);
+                       "private_1=%" PRIuPTR,
+                       (void *)exception_object, exception_object->private_1);
   // If this is non-forced and a stopping place was found, then this is a
   // re-throw.
   // Call _Unwind_RaiseException() as if this was a new exception.
@@ -386,7 +407,8 @@ _LIBUNWIND_EXPORT uintptr_t
 _Unwind_GetLanguageSpecificData(struct _Unwind_Context *context) {
   _Unwind_FunctionContext_t ufc = (_Unwind_FunctionContext_t) context;
   _LIBUNWIND_TRACE_API("_Unwind_GetLanguageSpecificData(context=%p) "
-                             "=> 0x%0lX",  context, ufc->lsda);
+                       "=> 0x%" PRIuPTR,
+                       (void *)context, ufc->lsda);
   return ufc->lsda;
 }
 
@@ -394,8 +416,8 @@ _Unwind_GetLanguageSpecificData(struct _Unwind_Context *context) {
 /// Called by personality handler during phase 2 to get register values.
 _LIBUNWIND_EXPORT uintptr_t _Unwind_GetGR(struct _Unwind_Context *context,
                                           int index) {
-  _LIBUNWIND_TRACE_API("_Unwind_GetGR(context=%p, reg=%d)",
-                             context, index);
+  _LIBUNWIND_TRACE_API("_Unwind_GetGR(context=%p, reg=%d)", (void *)context,
+                       index);
   _Unwind_FunctionContext_t ufc = (_Unwind_FunctionContext_t) context;
   return ufc->resumeParameters[index];
 }
@@ -404,8 +426,9 @@ _LIBUNWIND_EXPORT uintptr_t _Unwind_GetGR(struct _Unwind_Context *context,
 /// Called by personality handler during phase 2 to alter register values.
 _LIBUNWIND_EXPORT void _Unwind_SetGR(struct _Unwind_Context *context, int index,
                                      uintptr_t new_value) {
-  _LIBUNWIND_TRACE_API("_Unwind_SetGR(context=%p, reg=%d, value=0x%0lX)"
-                            , context, index, new_value);
+  _LIBUNWIND_TRACE_API("_Unwind_SetGR(context=%p, reg=%d, value=0x%" PRIuPTR
+                       ")",
+                       (void *)context, index, new_value);
   _Unwind_FunctionContext_t ufc = (_Unwind_FunctionContext_t) context;
   ufc->resumeParameters[index] = new_value;
 }
@@ -414,8 +437,8 @@ _LIBUNWIND_EXPORT void _Unwind_SetGR(struct _Unwind_Context *context, int index,
 /// Called by personality handler during phase 2 to get instruction pointer.
 _LIBUNWIND_EXPORT uintptr_t _Unwind_GetIP(struct _Unwind_Context *context) {
   _Unwind_FunctionContext_t ufc = (_Unwind_FunctionContext_t) context;
-  _LIBUNWIND_TRACE_API("_Unwind_GetIP(context=%p) => 0x%lX", context,
-                  ufc->resumeLocation + 1);
+  _LIBUNWIND_TRACE_API("_Unwind_GetIP(context=%p) => 0x%" PRIu32,
+                       (void *)context, ufc->resumeLocation + 1);
   return ufc->resumeLocation + 1;
 }
 
@@ -427,8 +450,9 @@ _LIBUNWIND_EXPORT uintptr_t _Unwind_GetIPInfo(struct _Unwind_Context *context,
                                               int *ipBefore) {
   _Unwind_FunctionContext_t ufc = (_Unwind_FunctionContext_t) context;
   *ipBefore = 0;
-  _LIBUNWIND_TRACE_API("_Unwind_GetIPInfo(context=%p, %p) => 0x%lX",
-                             context, ipBefore, ufc->resumeLocation + 1);
+  _LIBUNWIND_TRACE_API("_Unwind_GetIPInfo(context=%p, %p) => 0x%" PRIu32,
+                       (void *)context, (void *)ipBefore,
+                       ufc->resumeLocation + 1);
   return ufc->resumeLocation + 1;
 }
 
@@ -436,8 +460,8 @@ _LIBUNWIND_EXPORT uintptr_t _Unwind_GetIPInfo(struct _Unwind_Context *context,
 /// Called by personality handler during phase 2 to alter instruction pointer.
 _LIBUNWIND_EXPORT void _Unwind_SetIP(struct _Unwind_Context *context,
                                      uintptr_t new_value) {
-  _LIBUNWIND_TRACE_API("_Unwind_SetIP(context=%p, value=0x%0lX)",
-                             context, new_value);
+  _LIBUNWIND_TRACE_API("_Unwind_SetIP(context=%p, value=0x%" PRIuPTR ")",
+                       (void *)context, new_value);
   _Unwind_FunctionContext_t ufc = (_Unwind_FunctionContext_t) context;
   ufc->resumeLocation = new_value - 1;
 }
@@ -449,7 +473,7 @@ _LIBUNWIND_EXPORT uintptr_t
 _Unwind_GetRegionStart(struct _Unwind_Context *context) {
   // Not supported or needed for sjlj based unwinding
   (void)context;
-  _LIBUNWIND_TRACE_API("_Unwind_GetRegionStart(context=%p)", context);
+  _LIBUNWIND_TRACE_API("_Unwind_GetRegionStart(context=%p)", (void *)context);
   return 0;
 }
 
@@ -459,7 +483,7 @@ _Unwind_GetRegionStart(struct _Unwind_Context *context) {
 _LIBUNWIND_EXPORT void
 _Unwind_DeleteException(struct _Unwind_Exception *exception_object) {
   _LIBUNWIND_TRACE_API("_Unwind_DeleteException(ex_obj=%p)",
-                              exception_object);
+                       (void *)exception_object);
   if (exception_object->exception_cleanup != NULL)
     (*exception_object->exception_cleanup)(_URC_FOREIGN_EXCEPTION_CAUGHT,
                                            exception_object);
@@ -473,7 +497,7 @@ _LIBUNWIND_EXPORT uintptr_t
 _Unwind_GetDataRelBase(struct _Unwind_Context *context) {
   // Not supported or needed for sjlj based unwinding
   (void)context;
-  _LIBUNWIND_TRACE_API("_Unwind_GetDataRelBase(context=%p)", context);
+  _LIBUNWIND_TRACE_API("_Unwind_GetDataRelBase(context=%p)", (void *)context);
   _LIBUNWIND_ABORT("_Unwind_GetDataRelBase() not implemented");
 }
 
@@ -484,14 +508,14 @@ _LIBUNWIND_EXPORT uintptr_t
 _Unwind_GetTextRelBase(struct _Unwind_Context *context) {
   // Not supported or needed for sjlj based unwinding
   (void)context;
-  _LIBUNWIND_TRACE_API("_Unwind_GetTextRelBase(context=%p)", context);
+  _LIBUNWIND_TRACE_API("_Unwind_GetTextRelBase(context=%p)", (void *)context);
   _LIBUNWIND_ABORT("_Unwind_GetTextRelBase() not implemented");
 }
 
 
 /// Called by personality handler to get "Call Frame Area" for current frame.
 _LIBUNWIND_EXPORT uintptr_t _Unwind_GetCFA(struct _Unwind_Context *context) {
-  _LIBUNWIND_TRACE_API("_Unwind_GetCFA(context=%p)", context);
+  _LIBUNWIND_TRACE_API("_Unwind_GetCFA(context=%p)", (void *)context);
   if (context != NULL) {
     _Unwind_FunctionContext_t ufc = (_Unwind_FunctionContext_t) context;
     // Setjmp/longjmp based exceptions don't have a true CFA.
diff --git a/WAVM/ThirdParty/libunwind/src/UnwindCursor.hpp b/WAVM/ThirdParty/libunwind/src/UnwindCursor.hpp
index c3bb75f8..1ca842f3 100644
--- a/WAVM/ThirdParty/libunwind/src/UnwindCursor.hpp
+++ b/WAVM/ThirdParty/libunwind/src/UnwindCursor.hpp
@@ -1,9 +1,8 @@
-//===------------------------- UnwindCursor.hpp ---------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
+//===----------------------------------------------------------------------===//
 //
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //
 // C++ interface to lower levels of libunwind
@@ -12,16 +11,57 @@
 #ifndef __UNWINDCURSOR_HPP__
 #define __UNWINDCURSOR_HPP__
 
-#include <algorithm>
+#include "cet_unwind.h"
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <unwind.h>
 
+#ifdef _WIN32
+  #include <windows.h>
+  #include <ntverp.h>
+#endif
 #ifdef __APPLE__
   #include <mach-o/dyld.h>
 #endif
 
+#if defined(_LIBUNWIND_SUPPORT_SEH_UNWIND)
+// Provide a definition for the DISPATCHER_CONTEXT struct for old (Win7 and
+// earlier) SDKs.
+// MinGW-w64 has always provided this struct.
+  #if defined(_WIN32) && defined(_LIBUNWIND_TARGET_X86_64) && \
+      !defined(__MINGW32__) && VER_PRODUCTBUILD < 8000
+struct _DISPATCHER_CONTEXT {
+  ULONG64 ControlPc;
+  ULONG64 ImageBase;
+  PRUNTIME_FUNCTION FunctionEntry;
+  ULONG64 EstablisherFrame;
+  ULONG64 TargetIp;
+  PCONTEXT ContextRecord;
+  PEXCEPTION_ROUTINE LanguageHandler;
+  PVOID HandlerData;
+  PUNWIND_HISTORY_TABLE HistoryTable;
+  ULONG ScopeIndex;
+  ULONG Fill0;
+};
+  #endif
+
+struct UNWIND_INFO {
+  uint8_t Version : 3;
+  uint8_t Flags : 5;
+  uint8_t SizeOfProlog;
+  uint8_t CountOfCodes;
+  uint8_t FrameRegister : 4;
+  uint8_t FrameOffset : 4;
+  uint16_t UnwindCodes[2];
+};
+
+extern "C" _Unwind_Reason_Code __libunwind_seh_personality(
+    int, _Unwind_Action, uint64_t, _Unwind_Exception *,
+    struct _Unwind_Context *);
+
+#endif
+
 #include "config.h"
 
 #include "AddressSpace.hpp"
@@ -42,9 +82,9 @@ template <typename A>
 class _LIBUNWIND_HIDDEN DwarfFDECache {
   typedef typename A::pint_t pint_t;
 public:
+  static constexpr pint_t kSearchAll = static_cast<pint_t>(-1);
   static pint_t findFDE(pint_t mh, pint_t pc);
-  static void add(pint_t mh, pint_t ip_start, pint_t ip_end, pint_t fde,
-                  bool isMallocAllowed = false);
+  static void add(pint_t mh, pint_t ip_start, pint_t ip_end, pint_t fde);
   static void removeAllIn(pint_t mh);
   static void iterateCacheEntries(void (*func)(unw_word_t ip_start,
                                                unw_word_t ip_end,
@@ -66,7 +106,6 @@ private:
   static void dyldUnloadHook(const struct mach_header *mh, intptr_t slide);
   static bool _registeredForDyldUnloads;
 #endif
-  // Can't use std::vector<> here because this code is below libc++.
   static entry *_buffer;
   static entry *_bufferUsed;
   static entry *_bufferEnd;
@@ -101,7 +140,7 @@ typename A::pint_t DwarfFDECache<A>::findFDE(pint_t mh, pint_t pc) {
   pint_t result = 0;
   _LIBUNWIND_LOG_IF_FALSE(_lock.lock_shared());
   for (entry *p = _buffer; p < _bufferUsed; ++p) {
-    if ((mh == p->mh) || (mh == 0)) {
+    if ((mh == p->mh) || (mh == kSearchAll)) {
       if ((p->ip_start <= pc) && (pc < p->ip_end)) {
         result = p->fde;
         break;
@@ -114,14 +153,10 @@ typename A::pint_t DwarfFDECache<A>::findFDE(pint_t mh, pint_t pc) {
 
 template <typename A>
 void DwarfFDECache<A>::add(pint_t mh, pint_t ip_start, pint_t ip_end,
-                           pint_t fde, bool isMallocAllowed) {
+                           pint_t fde) {
 #if !defined(_LIBUNWIND_NO_HEAP)
   _LIBUNWIND_LOG_IF_FALSE(_lock.lock());
   if (_bufferUsed >= _bufferEnd) {
-    if (!isMallocAllowed) {
-      _LIBUNWIND_LOG_IF_FALSE(_lock.unlock());
-      return;
-    }
     size_t oldSize = (size_t)(_bufferEnd - _buffer);
     size_t newSize = oldSize * 4;
     // Can't use operator new (we are below it).
@@ -415,8 +450,440 @@ public:
 #ifdef __arm__
   virtual void saveVFPAsX() { _LIBUNWIND_ABORT("saveVFPAsX not implemented"); }
 #endif
+
+#if defined(_LIBUNWIND_USE_CET)
+  virtual void *get_registers() {
+    _LIBUNWIND_ABORT("get_registers not implemented");
+  }
+#endif
+};
+
+#if defined(_LIBUNWIND_SUPPORT_SEH_UNWIND) && defined(_WIN32)
+
+/// \c UnwindCursor contains all state (including all register values) during
+/// an unwind.  This is normally stack-allocated inside a unw_cursor_t.
+template <typename A, typename R>
+class UnwindCursor : public AbstractUnwindCursor {
+  typedef typename A::pint_t pint_t;
+public:
+                      UnwindCursor(unw_context_t *context, A &as);
+                      UnwindCursor(CONTEXT *context, A &as);
+                      UnwindCursor(A &as, void *threadArg);
+  virtual             ~UnwindCursor() {}
+  virtual bool        validReg(int);
+  virtual unw_word_t  getReg(int);
+  virtual void        setReg(int, unw_word_t);
+  virtual bool        validFloatReg(int);
+  virtual unw_fpreg_t getFloatReg(int);
+  virtual void        setFloatReg(int, unw_fpreg_t);
+  virtual int         step();
+  virtual void        getInfo(unw_proc_info_t *);
+  virtual void        jumpto();
+  virtual bool        isSignalFrame();
+  virtual bool        getFunctionName(char *buf, size_t len, unw_word_t *off);
+  virtual void        setInfoBasedOnIPRegister(bool isReturnAddress = false);
+  virtual const char *getRegisterName(int num);
+#ifdef __arm__
+  virtual void        saveVFPAsX();
+#endif
+
+  DISPATCHER_CONTEXT *getDispatcherContext() { return &_dispContext; }
+  void setDispatcherContext(DISPATCHER_CONTEXT *disp) { _dispContext = *disp; }
+
+  // libunwind does not and should not depend on C++ library which means that we
+  // need our own defition of inline placement new.
+  static void *operator new(size_t, UnwindCursor<A, R> *p) { return p; }
+
+private:
+
+  pint_t getLastPC() const { return _dispContext.ControlPc; }
+  void setLastPC(pint_t pc) { _dispContext.ControlPc = pc; }
+  RUNTIME_FUNCTION *lookUpSEHUnwindInfo(pint_t pc, pint_t *base) {
+    _dispContext.FunctionEntry = RtlLookupFunctionEntry(pc,
+                                                        &_dispContext.ImageBase,
+                                                        _dispContext.HistoryTable);
+    *base = _dispContext.ImageBase;
+    return _dispContext.FunctionEntry;
+  }
+  bool getInfoFromSEH(pint_t pc);
+  int stepWithSEHData() {
+    _dispContext.LanguageHandler = RtlVirtualUnwind(UNW_FLAG_UHANDLER,
+                                                    _dispContext.ImageBase,
+                                                    _dispContext.ControlPc,
+                                                    _dispContext.FunctionEntry,
+                                                    _dispContext.ContextRecord,
+                                                    &_dispContext.HandlerData,
+                                                    &_dispContext.EstablisherFrame,
+                                                    NULL);
+    // Update some fields of the unwind info now, since we have them.
+    _info.lsda = reinterpret_cast<unw_word_t>(_dispContext.HandlerData);
+    if (_dispContext.LanguageHandler) {
+      _info.handler = reinterpret_cast<unw_word_t>(__libunwind_seh_personality);
+    } else
+      _info.handler = 0;
+    return UNW_STEP_SUCCESS;
+  }
+
+  A                   &_addressSpace;
+  unw_proc_info_t      _info;
+  DISPATCHER_CONTEXT   _dispContext;
+  CONTEXT              _msContext;
+  UNWIND_HISTORY_TABLE _histTable;
+  bool                 _unwindInfoMissing;
 };
 
+
+template <typename A, typename R>
+UnwindCursor<A, R>::UnwindCursor(unw_context_t *context, A &as)
+    : _addressSpace(as), _unwindInfoMissing(false) {
+  static_assert((check_fit<UnwindCursor<A, R>, unw_cursor_t>::does_fit),
+                "UnwindCursor<> does not fit in unw_cursor_t");
+  static_assert((alignof(UnwindCursor<A, R>) <= alignof(unw_cursor_t)),
+                "UnwindCursor<> requires more alignment than unw_cursor_t");
+  memset(&_info, 0, sizeof(_info));
+  memset(&_histTable, 0, sizeof(_histTable));
+  _dispContext.ContextRecord = &_msContext;
+  _dispContext.HistoryTable = &_histTable;
+  // Initialize MS context from ours.
+  R r(context);
+  _msContext.ContextFlags = CONTEXT_CONTROL|CONTEXT_INTEGER|CONTEXT_FLOATING_POINT;
+#if defined(_LIBUNWIND_TARGET_X86_64)
+  _msContext.Rax = r.getRegister(UNW_X86_64_RAX);
+  _msContext.Rcx = r.getRegister(UNW_X86_64_RCX);
+  _msContext.Rdx = r.getRegister(UNW_X86_64_RDX);
+  _msContext.Rbx = r.getRegister(UNW_X86_64_RBX);
+  _msContext.Rsp = r.getRegister(UNW_X86_64_RSP);
+  _msContext.Rbp = r.getRegister(UNW_X86_64_RBP);
+  _msContext.Rsi = r.getRegister(UNW_X86_64_RSI);
+  _msContext.Rdi = r.getRegister(UNW_X86_64_RDI);
+  _msContext.R8 = r.getRegister(UNW_X86_64_R8);
+  _msContext.R9 = r.getRegister(UNW_X86_64_R9);
+  _msContext.R10 = r.getRegister(UNW_X86_64_R10);
+  _msContext.R11 = r.getRegister(UNW_X86_64_R11);
+  _msContext.R12 = r.getRegister(UNW_X86_64_R12);
+  _msContext.R13 = r.getRegister(UNW_X86_64_R13);
+  _msContext.R14 = r.getRegister(UNW_X86_64_R14);
+  _msContext.R15 = r.getRegister(UNW_X86_64_R15);
+  _msContext.Rip = r.getRegister(UNW_REG_IP);
+  union {
+    v128 v;
+    M128A m;
+  } t;
+  t.v = r.getVectorRegister(UNW_X86_64_XMM0);
+  _msContext.Xmm0 = t.m;
+  t.v = r.getVectorRegister(UNW_X86_64_XMM1);
+  _msContext.Xmm1 = t.m;
+  t.v = r.getVectorRegister(UNW_X86_64_XMM2);
+  _msContext.Xmm2 = t.m;
+  t.v = r.getVectorRegister(UNW_X86_64_XMM3);
+  _msContext.Xmm3 = t.m;
+  t.v = r.getVectorRegister(UNW_X86_64_XMM4);
+  _msContext.Xmm4 = t.m;
+  t.v = r.getVectorRegister(UNW_X86_64_XMM5);
+  _msContext.Xmm5 = t.m;
+  t.v = r.getVectorRegister(UNW_X86_64_XMM6);
+  _msContext.Xmm6 = t.m;
+  t.v = r.getVectorRegister(UNW_X86_64_XMM7);
+  _msContext.Xmm7 = t.m;
+  t.v = r.getVectorRegister(UNW_X86_64_XMM8);
+  _msContext.Xmm8 = t.m;
+  t.v = r.getVectorRegister(UNW_X86_64_XMM9);
+  _msContext.Xmm9 = t.m;
+  t.v = r.getVectorRegister(UNW_X86_64_XMM10);
+  _msContext.Xmm10 = t.m;
+  t.v = r.getVectorRegister(UNW_X86_64_XMM11);
+  _msContext.Xmm11 = t.m;
+  t.v = r.getVectorRegister(UNW_X86_64_XMM12);
+  _msContext.Xmm12 = t.m;
+  t.v = r.getVectorRegister(UNW_X86_64_XMM13);
+  _msContext.Xmm13 = t.m;
+  t.v = r.getVectorRegister(UNW_X86_64_XMM14);
+  _msContext.Xmm14 = t.m;
+  t.v = r.getVectorRegister(UNW_X86_64_XMM15);
+  _msContext.Xmm15 = t.m;
+#elif defined(_LIBUNWIND_TARGET_ARM)
+  _msContext.R0 = r.getRegister(UNW_ARM_R0);
+  _msContext.R1 = r.getRegister(UNW_ARM_R1);
+  _msContext.R2 = r.getRegister(UNW_ARM_R2);
+  _msContext.R3 = r.getRegister(UNW_ARM_R3);
+  _msContext.R4 = r.getRegister(UNW_ARM_R4);
+  _msContext.R5 = r.getRegister(UNW_ARM_R5);
+  _msContext.R6 = r.getRegister(UNW_ARM_R6);
+  _msContext.R7 = r.getRegister(UNW_ARM_R7);
+  _msContext.R8 = r.getRegister(UNW_ARM_R8);
+  _msContext.R9 = r.getRegister(UNW_ARM_R9);
+  _msContext.R10 = r.getRegister(UNW_ARM_R10);
+  _msContext.R11 = r.getRegister(UNW_ARM_R11);
+  _msContext.R12 = r.getRegister(UNW_ARM_R12);
+  _msContext.Sp = r.getRegister(UNW_ARM_SP);
+  _msContext.Lr = r.getRegister(UNW_ARM_LR);
+  _msContext.Pc = r.getRegister(UNW_ARM_IP);
+  for (int i = UNW_ARM_D0; i <= UNW_ARM_D31; ++i) {
+    union {
+      uint64_t w;
+      double d;
+    } d;
+    d.d = r.getFloatRegister(i);
+    _msContext.D[i - UNW_ARM_D0] = d.w;
+  }
+#elif defined(_LIBUNWIND_TARGET_AARCH64)
+  for (int i = UNW_AARCH64_X0; i <= UNW_ARM64_X30; ++i)
+    _msContext.X[i - UNW_AARCH64_X0] = r.getRegister(i);
+  _msContext.Sp = r.getRegister(UNW_REG_SP);
+  _msContext.Pc = r.getRegister(UNW_REG_IP);
+  for (int i = UNW_AARCH64_V0; i <= UNW_ARM64_D31; ++i)
+    _msContext.V[i - UNW_AARCH64_V0].D[0] = r.getFloatRegister(i);
+#endif
+}
+
+template <typename A, typename R>
+UnwindCursor<A, R>::UnwindCursor(CONTEXT *context, A &as)
+    : _addressSpace(as), _unwindInfoMissing(false) {
+  static_assert((check_fit<UnwindCursor<A, R>, unw_cursor_t>::does_fit),
+                "UnwindCursor<> does not fit in unw_cursor_t");
+  memset(&_info, 0, sizeof(_info));
+  memset(&_histTable, 0, sizeof(_histTable));
+  _dispContext.ContextRecord = &_msContext;
+  _dispContext.HistoryTable = &_histTable;
+  _msContext = *context;
+}
+
+
+template <typename A, typename R>
+bool UnwindCursor<A, R>::validReg(int regNum) {
+  if (regNum == UNW_REG_IP || regNum == UNW_REG_SP) return true;
+#if defined(_LIBUNWIND_TARGET_X86_64)
+  if (regNum >= UNW_X86_64_RAX && regNum <= UNW_X86_64_R15) return true;
+#elif defined(_LIBUNWIND_TARGET_ARM)
+  if ((regNum >= UNW_ARM_R0 && regNum <= UNW_ARM_R15) ||
+      regNum == UNW_ARM_RA_AUTH_CODE)
+    return true;
+#elif defined(_LIBUNWIND_TARGET_AARCH64)
+  if (regNum >= UNW_AARCH64_X0 && regNum <= UNW_ARM64_X30) return true;
+#endif
+  return false;
+}
+
+template <typename A, typename R>
+unw_word_t UnwindCursor<A, R>::getReg(int regNum) {
+  switch (regNum) {
+#if defined(_LIBUNWIND_TARGET_X86_64)
+  case UNW_REG_IP: return _msContext.Rip;
+  case UNW_X86_64_RAX: return _msContext.Rax;
+  case UNW_X86_64_RDX: return _msContext.Rdx;
+  case UNW_X86_64_RCX: return _msContext.Rcx;
+  case UNW_X86_64_RBX: return _msContext.Rbx;
+  case UNW_REG_SP:
+  case UNW_X86_64_RSP: return _msContext.Rsp;
+  case UNW_X86_64_RBP: return _msContext.Rbp;
+  case UNW_X86_64_RSI: return _msContext.Rsi;
+  case UNW_X86_64_RDI: return _msContext.Rdi;
+  case UNW_X86_64_R8: return _msContext.R8;
+  case UNW_X86_64_R9: return _msContext.R9;
+  case UNW_X86_64_R10: return _msContext.R10;
+  case UNW_X86_64_R11: return _msContext.R11;
+  case UNW_X86_64_R12: return _msContext.R12;
+  case UNW_X86_64_R13: return _msContext.R13;
+  case UNW_X86_64_R14: return _msContext.R14;
+  case UNW_X86_64_R15: return _msContext.R15;
+#elif defined(_LIBUNWIND_TARGET_ARM)
+  case UNW_ARM_R0: return _msContext.R0;
+  case UNW_ARM_R1: return _msContext.R1;
+  case UNW_ARM_R2: return _msContext.R2;
+  case UNW_ARM_R3: return _msContext.R3;
+  case UNW_ARM_R4: return _msContext.R4;
+  case UNW_ARM_R5: return _msContext.R5;
+  case UNW_ARM_R6: return _msContext.R6;
+  case UNW_ARM_R7: return _msContext.R7;
+  case UNW_ARM_R8: return _msContext.R8;
+  case UNW_ARM_R9: return _msContext.R9;
+  case UNW_ARM_R10: return _msContext.R10;
+  case UNW_ARM_R11: return _msContext.R11;
+  case UNW_ARM_R12: return _msContext.R12;
+  case UNW_REG_SP:
+  case UNW_ARM_SP: return _msContext.Sp;
+  case UNW_ARM_LR: return _msContext.Lr;
+  case UNW_REG_IP:
+  case UNW_ARM_IP: return _msContext.Pc;
+#elif defined(_LIBUNWIND_TARGET_AARCH64)
+  case UNW_REG_SP: return _msContext.Sp;
+  case UNW_REG_IP: return _msContext.Pc;
+  default: return _msContext.X[regNum - UNW_AARCH64_X0];
+#endif
+  }
+  _LIBUNWIND_ABORT("unsupported register");
+}
+
+template <typename A, typename R>
+void UnwindCursor<A, R>::setReg(int regNum, unw_word_t value) {
+  switch (regNum) {
+#if defined(_LIBUNWIND_TARGET_X86_64)
+  case UNW_REG_IP: _msContext.Rip = value; break;
+  case UNW_X86_64_RAX: _msContext.Rax = value; break;
+  case UNW_X86_64_RDX: _msContext.Rdx = value; break;
+  case UNW_X86_64_RCX: _msContext.Rcx = value; break;
+  case UNW_X86_64_RBX: _msContext.Rbx = value; break;
+  case UNW_REG_SP:
+  case UNW_X86_64_RSP: _msContext.Rsp = value; break;
+  case UNW_X86_64_RBP: _msContext.Rbp = value; break;
+  case UNW_X86_64_RSI: _msContext.Rsi = value; break;
+  case UNW_X86_64_RDI: _msContext.Rdi = value; break;
+  case UNW_X86_64_R8: _msContext.R8 = value; break;
+  case UNW_X86_64_R9: _msContext.R9 = value; break;
+  case UNW_X86_64_R10: _msContext.R10 = value; break;
+  case UNW_X86_64_R11: _msContext.R11 = value; break;
+  case UNW_X86_64_R12: _msContext.R12 = value; break;
+  case UNW_X86_64_R13: _msContext.R13 = value; break;
+  case UNW_X86_64_R14: _msContext.R14 = value; break;
+  case UNW_X86_64_R15: _msContext.R15 = value; break;
+#elif defined(_LIBUNWIND_TARGET_ARM)
+  case UNW_ARM_R0: _msContext.R0 = value; break;
+  case UNW_ARM_R1: _msContext.R1 = value; break;
+  case UNW_ARM_R2: _msContext.R2 = value; break;
+  case UNW_ARM_R3: _msContext.R3 = value; break;
+  case UNW_ARM_R4: _msContext.R4 = value; break;
+  case UNW_ARM_R5: _msContext.R5 = value; break;
+  case UNW_ARM_R6: _msContext.R6 = value; break;
+  case UNW_ARM_R7: _msContext.R7 = value; break;
+  case UNW_ARM_R8: _msContext.R8 = value; break;
+  case UNW_ARM_R9: _msContext.R9 = value; break;
+  case UNW_ARM_R10: _msContext.R10 = value; break;
+  case UNW_ARM_R11: _msContext.R11 = value; break;
+  case UNW_ARM_R12: _msContext.R12 = value; break;
+  case UNW_REG_SP:
+  case UNW_ARM_SP: _msContext.Sp = value; break;
+  case UNW_ARM_LR: _msContext.Lr = value; break;
+  case UNW_REG_IP:
+  case UNW_ARM_IP: _msContext.Pc = value; break;
+#elif defined(_LIBUNWIND_TARGET_AARCH64)
+  case UNW_REG_SP: _msContext.Sp = value; break;
+  case UNW_REG_IP: _msContext.Pc = value; break;
+  case UNW_AARCH64_X0:
+  case UNW_AARCH64_X1:
+  case UNW_AARCH64_X2:
+  case UNW_AARCH64_X3:
+  case UNW_AARCH64_X4:
+  case UNW_AARCH64_X5:
+  case UNW_AARCH64_X6:
+  case UNW_AARCH64_X7:
+  case UNW_AARCH64_X8:
+  case UNW_AARCH64_X9:
+  case UNW_AARCH64_X10:
+  case UNW_AARCH64_X11:
+  case UNW_AARCH64_X12:
+  case UNW_AARCH64_X13:
+  case UNW_AARCH64_X14:
+  case UNW_AARCH64_X15:
+  case UNW_AARCH64_X16:
+  case UNW_AARCH64_X17:
+  case UNW_AARCH64_X18:
+  case UNW_AARCH64_X19:
+  case UNW_AARCH64_X20:
+  case UNW_AARCH64_X21:
+  case UNW_AARCH64_X22:
+  case UNW_AARCH64_X23:
+  case UNW_AARCH64_X24:
+  case UNW_AARCH64_X25:
+  case UNW_AARCH64_X26:
+  case UNW_AARCH64_X27:
+  case UNW_AARCH64_X28:
+  case UNW_AARCH64_FP:
+  case UNW_AARCH64_LR: _msContext.X[regNum - UNW_ARM64_X0] = value; break;
+#endif
+  default:
+    _LIBUNWIND_ABORT("unsupported register");
+  }
+}
+
+template <typename A, typename R>
+bool UnwindCursor<A, R>::validFloatReg(int regNum) {
+#if defined(_LIBUNWIND_TARGET_ARM)
+  if (regNum >= UNW_ARM_S0 && regNum <= UNW_ARM_S31) return true;
+  if (regNum >= UNW_ARM_D0 && regNum <= UNW_ARM_D31) return true;
+#elif defined(_LIBUNWIND_TARGET_AARCH64)
+  if (regNum >= UNW_AARCH64_V0 && regNum <= UNW_ARM64_D31) return true;
+#else
+  (void)regNum;
+#endif
+  return false;
+}
+
+template <typename A, typename R>
+unw_fpreg_t UnwindCursor<A, R>::getFloatReg(int regNum) {
+#if defined(_LIBUNWIND_TARGET_ARM)
+  if (regNum >= UNW_ARM_S0 && regNum <= UNW_ARM_S31) {
+    union {
+      uint32_t w;
+      float f;
+    } d;
+    d.w = _msContext.S[regNum - UNW_ARM_S0];
+    return d.f;
+  }
+  if (regNum >= UNW_ARM_D0 && regNum <= UNW_ARM_D31) {
+    union {
+      uint64_t w;
+      double d;
+    } d;
+    d.w = _msContext.D[regNum - UNW_ARM_D0];
+    return d.d;
+  }
+  _LIBUNWIND_ABORT("unsupported float register");
+#elif defined(_LIBUNWIND_TARGET_AARCH64)
+  return _msContext.V[regNum - UNW_AARCH64_V0].D[0];
+#else
+  (void)regNum;
+  _LIBUNWIND_ABORT("float registers unimplemented");
+#endif
+}
+
+template <typename A, typename R>
+void UnwindCursor<A, R>::setFloatReg(int regNum, unw_fpreg_t value) {
+#if defined(_LIBUNWIND_TARGET_ARM)
+  if (regNum >= UNW_ARM_S0 && regNum <= UNW_ARM_S31) {
+    union {
+      uint32_t w;
+      float f;
+    } d;
+    d.f = value;
+    _msContext.S[regNum - UNW_ARM_S0] = d.w;
+  }
+  if (regNum >= UNW_ARM_D0 && regNum <= UNW_ARM_D31) {
+    union {
+      uint64_t w;
+      double d;
+    } d;
+    d.d = value;
+    _msContext.D[regNum - UNW_ARM_D0] = d.w;
+  }
+  _LIBUNWIND_ABORT("unsupported float register");
+#elif defined(_LIBUNWIND_TARGET_AARCH64)
+  _msContext.V[regNum - UNW_AARCH64_V0].D[0] = value;
+#else
+  (void)regNum;
+  (void)value;
+  _LIBUNWIND_ABORT("float registers unimplemented");
+#endif
+}
+
+template <typename A, typename R> void UnwindCursor<A, R>::jumpto() {
+  RtlRestoreContext(&_msContext, nullptr);
+}
+
+#ifdef __arm__
+template <typename A, typename R> void UnwindCursor<A, R>::saveVFPAsX() {}
+#endif
+
+template <typename A, typename R>
+const char *UnwindCursor<A, R>::getRegisterName(int regNum) {
+  return R::getRegisterName(regNum);
+}
+
+template <typename A, typename R> bool UnwindCursor<A, R>::isSignalFrame() {
+  return false;
+}
+
+#else  // !defined(_LIBUNWIND_SUPPORT_SEH_UNWIND) || !defined(_WIN32)
+
 /// UnwindCursor contains all state (including all register values) during
 /// an unwind.  This is normally stack allocated inside a unw_cursor_t.
 template <typename A, typename R>
@@ -443,6 +910,13 @@ public:
   virtual void        saveVFPAsX();
 #endif
 
+#if defined(_LIBUNWIND_USE_CET)
+  virtual void *get_registers() { return &_registers; }
+#endif
+  // libunwind does not and should not depend on C++ library which means that we
+  // need our own defition of inline placement new.
+  static void *operator new(size_t, UnwindCursor<A, R> *p) { return p; }
+
 private:
 
 #if defined(_LIBUNWIND_ARM_EHABI)
@@ -463,14 +937,36 @@ private:
   }
 #endif
 
+#if defined(_LIBUNWIND_TARGET_LINUX) && defined(_LIBUNWIND_TARGET_AARCH64)
+  bool setInfoForSigReturn() {
+    R dummy;
+    return setInfoForSigReturn(dummy);
+  }
+  int stepThroughSigReturn() {
+    R dummy;
+    return stepThroughSigReturn(dummy);
+  }
+  bool setInfoForSigReturn(Registers_arm64 &);
+  int stepThroughSigReturn(Registers_arm64 &);
+  template <typename Registers> bool setInfoForSigReturn(Registers &) {
+    return false;
+  }
+  template <typename Registers> int stepThroughSigReturn(Registers &) {
+    return UNW_STEP_END;
+  }
+#endif
+
 #if defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND)
+  bool getInfoFromFdeCie(const typename CFI_Parser<A>::FDE_Info &fdeInfo,
+                         const typename CFI_Parser<A>::CIE_Info &cieInfo,
+                         pint_t pc, uintptr_t dso_base);
   bool getInfoFromDwarfSection(pint_t pc, const UnwindInfoSections &sects,
                                             uint32_t fdeSectionOffsetHint=0);
   int stepWithDwarfFDE() {
     return DwarfInstructions<A, R>::stepWithDwarf(_addressSpace,
                                               (pint_t)this->getReg(UNW_REG_IP),
                                               (pint_t)_info.unwind_info,
-                                              _registers);
+                                              _registers, _isSignalFrame);
   }
 #endif
 
@@ -532,6 +1028,20 @@ private:
   }
 #endif
 
+#if defined(_LIBUNWIND_TARGET_SPARC)
+  int stepWithCompactEncoding(Registers_sparc &) { return UNW_EINVAL; }
+#endif
+
+#if defined(_LIBUNWIND_TARGET_SPARC64)
+  int stepWithCompactEncoding(Registers_sparc64 &) { return UNW_EINVAL; }
+#endif
+
+#if defined (_LIBUNWIND_TARGET_RISCV)
+  int stepWithCompactEncoding(Registers_riscv &) {
+    return UNW_EINVAL;
+  }
+#endif
+
   bool compactSaysUseDwarf(uint32_t *offset=NULL) const {
     R dummy;
     return compactSaysUseDwarf(dummy, offset);
@@ -593,6 +1103,23 @@ private:
     return true;
   }
 #endif
+
+#if defined(_LIBUNWIND_TARGET_SPARC)
+  bool compactSaysUseDwarf(Registers_sparc &, uint32_t *) const { return true; }
+#endif
+
+#if defined(_LIBUNWIND_TARGET_SPARC64)
+  bool compactSaysUseDwarf(Registers_sparc64 &, uint32_t *) const {
+    return true;
+  }
+#endif
+
+#if defined (_LIBUNWIND_TARGET_RISCV)
+  bool compactSaysUseDwarf(Registers_riscv &, uint32_t *) const {
+    return true;
+  }
+#endif
+
 #endif // defined(_LIBUNWIND_SUPPORT_COMPACT_UNWIND)
 
 #if defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND)
@@ -643,6 +1170,12 @@ private:
   }
 #endif
 
+#if defined (_LIBUNWIND_TARGET_HEXAGON)
+  compact_unwind_encoding_t dwarfEncoding(Registers_hexagon &) const {
+    return 0;
+  }
+#endif
+
 #if defined (_LIBUNWIND_TARGET_MIPS_O32)
   compact_unwind_encoding_t dwarfEncoding(Registers_mips_o32 &) const {
     return 0;
@@ -654,14 +1187,48 @@ private:
     return 0;
   }
 #endif
+
+#if defined(_LIBUNWIND_TARGET_SPARC)
+  compact_unwind_encoding_t dwarfEncoding(Registers_sparc &) const { return 0; }
+#endif
+
+#if defined(_LIBUNWIND_TARGET_SPARC64)
+  compact_unwind_encoding_t dwarfEncoding(Registers_sparc64 &) const {
+    return 0;
+  }
+#endif
+
+#if defined (_LIBUNWIND_TARGET_RISCV)
+  compact_unwind_encoding_t dwarfEncoding(Registers_riscv &) const {
+    return 0;
+  }
+#endif
+
 #endif // defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND)
 
+#if defined(_LIBUNWIND_SUPPORT_SEH_UNWIND)
+  // For runtime environments using SEH unwind data without Windows runtime
+  // support.
+  pint_t getLastPC() const { /* FIXME: Implement */ return 0; }
+  void setLastPC(pint_t pc) { /* FIXME: Implement */ }
+  RUNTIME_FUNCTION *lookUpSEHUnwindInfo(pint_t pc, pint_t *base) {
+    /* FIXME: Implement */
+    *base = 0;
+    return nullptr;
+  }
+  bool getInfoFromSEH(pint_t pc);
+  int stepWithSEHData() { /* FIXME: Implement */ return 0; }
+#endif // defined(_LIBUNWIND_SUPPORT_SEH_UNWIND)
+
 
   A               &_addressSpace;
   R                _registers;
   unw_proc_info_t  _info;
   bool             _unwindInfoMissing;
   bool             _isSignalFrame;
+#if defined(_LIBUNWIND_TARGET_LINUX) && defined(_LIBUNWIND_TARGET_AARCH64)
+  bool             _isSigReturn = false;
+#endif
 };
 
 
@@ -671,6 +1238,8 @@ UnwindCursor<A, R>::UnwindCursor(unw_context_t *context, A &as)
       _isSignalFrame(false) {
   static_assert((check_fit<UnwindCursor<A, R>, unw_cursor_t>::does_fit),
                 "UnwindCursor<> does not fit in unw_cursor_t");
+  static_assert((alignof(UnwindCursor<A, R>) <= alignof(unw_cursor_t)),
+                "UnwindCursor<> requires more alignment than unw_cursor_t");
   memset(&_info, 0, sizeof(_info));
 }
 
@@ -732,17 +1301,13 @@ template <typename A, typename R> bool UnwindCursor<A, R>::isSignalFrame() {
   return _isSignalFrame;
 }
 
-#if defined(_LIBUNWIND_ARM_EHABI)
-struct EHABIIndexEntry {
-  uint32_t functionOffset;
-  uint32_t data;
-};
+#endif // defined(_LIBUNWIND_SUPPORT_SEH_UNWIND)
 
+#if defined(_LIBUNWIND_ARM_EHABI)
 template<typename A>
 struct EHABISectionIterator {
   typedef EHABISectionIterator _Self;
 
-  typedef std::random_access_iterator_tag iterator_category;
   typedef typename A::pint_t value_type;
   typedef typename A::pint_t* pointer;
   typedef typename A::pint_t& reference;
@@ -768,7 +1333,7 @@ struct EHABISectionIterator {
   _Self operator+(size_t a) { _Self out = *this; out._i += a; return out; }
   _Self operator-(size_t a) { assert(_i >= a); _Self out = *this; out._i -= a; return out; }
 
-  size_t operator-(const _Self& other) { return _i - other._i; }
+  size_t operator-(const _Self& other) const { return _i - other._i; }
 
   bool operator==(const _Self& other) const {
     assert(_addressSpace == other._addressSpace);
@@ -776,6 +1341,12 @@ struct EHABISectionIterator {
     return _i == other._i;
   }
 
+  bool operator!=(const _Self& other) const {
+    assert(_addressSpace == other._addressSpace);
+    assert(_sects == other._sects);
+    return _i != other._i;
+  }
+
   typename A::pint_t operator*() const { return functionAddress(); }
 
   typename A::pint_t functionAddress() const {
@@ -796,6 +1367,29 @@ struct EHABISectionIterator {
   const UnwindInfoSections* _sects;
 };
 
+namespace {
+
+template <typename A>
+EHABISectionIterator<A> EHABISectionUpperBound(
+    EHABISectionIterator<A> first,
+    EHABISectionIterator<A> last,
+    typename A::pint_t value) {
+  size_t len = last - first;
+  while (len > 0) {
+    size_t l2 = len / 2;
+    EHABISectionIterator<A> m = first + l2;
+    if (value < *m) {
+        len = l2;
+    } else {
+        first = ++m;
+        len -= l2 + 1;
+    }
+  }
+  return first;
+}
+
+}
+
 template <typename A, typename R>
 bool UnwindCursor<A, R>::getInfoFromEHABISection(
     pint_t pc,
@@ -807,7 +1401,7 @@ bool UnwindCursor<A, R>::getInfoFromEHABISection(
   if (begin == end)
     return false;
 
-  EHABISectionIterator<A> itNextPC = std::upper_bound(begin, end, pc);
+  EHABISectionIterator<A> itNextPC = EHABISectionUpperBound(begin, end, pc);
   if (itNextPC == begin)
     return false;
   EHABISectionIterator<A> itThisPC = itNextPC - 1;
@@ -817,8 +1411,7 @@ bool UnwindCursor<A, R>::getInfoFromEHABISection(
   // in the table, we don't really know the function extent and have to choose a
   // value for nextPC. Choosing max() will allow the range check during trace to
   // succeed.
-  pint_t nextPC = (itNextPC == end) ? std::numeric_limits<pint_t>::max()
-                                    : itNextPC.functionAddress();
+  pint_t nextPC = (itNextPC == end) ? UINTPTR_MAX : itNextPC.functionAddress();
   pint_t indexDataAddr = itThisPC.dataAddress();
 
   if (indexDataAddr == 0)
@@ -830,7 +1423,8 @@ bool UnwindCursor<A, R>::getInfoFromEHABISection(
 
   // If the high bit is set, the exception handling table entry is inline inside
   // the index table entry on the second word (aka |indexDataAddr|). Otherwise,
-  // the table points at an offset in the exception handling table (section 5 EHABI).
+  // the table points at an offset in the exception handling table (section 5
+  // EHABI).
   pint_t exceptionTableAddr;
   uint32_t exceptionTableData;
   bool isSingleWordEHT;
@@ -929,13 +1523,39 @@ bool UnwindCursor<A, R>::getInfoFromEHABISection(
   _info.unwind_info = exceptionTableAddr;
   _info.lsda = lsda;
   // flags is pr_cache.additional. See EHABI #7.2 for definition of bit 0.
-  _info.flags = isSingleWordEHT ? 1 : 0 | scope32 ? 0x2 : 0;  // Use enum?
+  _info.flags = (isSingleWordEHT ? 1 : 0) | (scope32 ? 0x2 : 0);  // Use enum?
 
   return true;
 }
 #endif
 
 #if defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND)
+template <typename A, typename R>
+bool UnwindCursor<A, R>::getInfoFromFdeCie(
+    const typename CFI_Parser<A>::FDE_Info &fdeInfo,
+    const typename CFI_Parser<A>::CIE_Info &cieInfo, pint_t pc,
+    uintptr_t dso_base) {
+  typename CFI_Parser<A>::PrologInfo prolog;
+  if (CFI_Parser<A>::parseFDEInstructions(_addressSpace, fdeInfo, cieInfo, pc,
+                                          R::getArch(), &prolog)) {
+    // Save off parsed FDE info
+    _info.start_ip          = fdeInfo.pcStart;
+    _info.end_ip            = fdeInfo.pcEnd;
+    _info.lsda              = fdeInfo.lsda;
+    _info.handler           = cieInfo.personality;
+    // Some frameless functions need SP altered when resuming in function, so
+    // propagate spExtraArgSize.
+    _info.gp                = prolog.spExtraArgSize;
+    _info.flags             = 0;
+    _info.format            = dwarfEncoding();
+    _info.unwind_info       = fdeInfo.fdeStart;
+    _info.unwind_info_size  = static_cast<uint32_t>(fdeInfo.fdeLength);
+    _info.extra             = static_cast<unw_word_t>(dso_base);
+    return true;
+  }
+  return false;
+}
+
 template <typename A, typename R>
 bool UnwindCursor<A, R>::getInfoFromDwarfSection(pint_t pc,
                                                 const UnwindInfoSections &sects,
@@ -947,7 +1567,7 @@ bool UnwindCursor<A, R>::getInfoFromDwarfSection(pint_t pc,
   // If compact encoding table gave offset into dwarf section, go directly there
   if (fdeSectionOffsetHint != 0) {
     foundFDE = CFI_Parser<A>::findFDE(_addressSpace, pc, sects.dwarf_section,
-                                    (uint32_t)sects.dwarf_section_length,
+                                    sects.dwarf_section_length,
                                     sects.dwarf_section + fdeSectionOffsetHint,
                                     &fdeInfo, &cieInfo);
   }
@@ -964,7 +1584,7 @@ bool UnwindCursor<A, R>::getInfoFromDwarfSection(pint_t pc,
     if (cachedFDE != 0) {
       foundFDE =
           CFI_Parser<A>::findFDE(_addressSpace, pc, sects.dwarf_section,
-                                 (uint32_t)sects.dwarf_section_length,
+                                 sects.dwarf_section_length,
                                  cachedFDE, &fdeInfo, &cieInfo);
       foundInCache = foundFDE;
     }
@@ -972,25 +1592,11 @@ bool UnwindCursor<A, R>::getInfoFromDwarfSection(pint_t pc,
   if (!foundFDE) {
     // Still not found, do full scan of __eh_frame section.
     foundFDE = CFI_Parser<A>::findFDE(_addressSpace, pc, sects.dwarf_section,
-                                      (uint32_t)sects.dwarf_section_length, 0,
+                                      sects.dwarf_section_length, 0,
                                       &fdeInfo, &cieInfo);
   }
   if (foundFDE) {
-    typename CFI_Parser<A>::PrologInfo prolog;
-    if (CFI_Parser<A>::parseFDEInstructions(_addressSpace, fdeInfo, cieInfo, pc,
-                                            &prolog)) {
-      // Save off parsed FDE info
-      _info.start_ip          = fdeInfo.pcStart;
-      _info.end_ip            = fdeInfo.pcEnd;
-      _info.lsda              = fdeInfo.lsda;
-      _info.handler           = cieInfo.personality;
-      _info.gp                = prolog.spExtraArgSize;
-      _info.flags             = 0;
-      _info.format            = dwarfEncoding();
-      _info.unwind_info       = fdeInfo.fdeStart;
-      _info.unwind_info_size  = (uint32_t)fdeInfo.fdeLength;
-      _info.extra             = (unw_word_t) sects.dso_base;
-
+    if (getInfoFromFdeCie(fdeInfo, cieInfo, pc, sects.dso_base)) {
       // Add to cache (to make next lookup faster) if we had no hint
       // and there was no index.
       if (!foundInCache && (fdeSectionOffsetHint == 0)) {
@@ -1159,14 +1765,16 @@ bool UnwindCursor<A, R>::getInfoFromCompactEncodingSection(pint_t pc,
     else
       funcEnd = firstLevelNextPageFunctionOffset + sects.dso_base;
     if (pc < funcStart) {
-      _LIBUNWIND_DEBUG_LOG("malformed __unwind_info, pc=0x%llX not in second  "
-                           "level compressed unwind table. funcStart=0x%llX",
+      _LIBUNWIND_DEBUG_LOG("malformed __unwind_info, pc=0x%llX "
+                           "not in second level compressed unwind table. "
+                           "funcStart=0x%llX",
                             (uint64_t) pc, (uint64_t) funcStart);
       return false;
     }
     if (pc > funcEnd) {
-      _LIBUNWIND_DEBUG_LOG("malformed __unwind_info, pc=0x%llX not in second  "
-                          "level compressed unwind table. funcEnd=0x%llX",
+      _LIBUNWIND_DEBUG_LOG("malformed __unwind_info, pc=0x%llX "
+                           "not in second level compressed unwind table. "
+                           "funcEnd=0x%llX",
                            (uint64_t) pc, (uint64_t) funcEnd);
       return false;
     }
@@ -1186,9 +1794,9 @@ bool UnwindCursor<A, R>::getInfoFromCompactEncodingSection(pint_t pc,
                                      pageEncodingIndex * sizeof(uint32_t));
     }
   } else {
-    _LIBUNWIND_DEBUG_LOG("malformed __unwind_info at 0x%0llX bad second "
-                         "level page",
-                          (uint64_t) sects.compact_unwind_section);
+    _LIBUNWIND_DEBUG_LOG(
+        "malformed __unwind_info at 0x%0llX bad second level page",
+        (uint64_t)sects.compact_unwind_section);
     return false;
   }
 
@@ -1223,14 +1831,14 @@ bool UnwindCursor<A, R>::getInfoFromCompactEncodingSection(pint_t pc,
     }
   }
 
-  // extact personality routine, if encoding says function has one
+  // extract personality routine, if encoding says function has one
   uint32_t personalityIndex = (encoding & UNWIND_PERSONALITY_MASK) >>
                               (__builtin_ctz(UNWIND_PERSONALITY_MASK));
   if (personalityIndex != 0) {
     --personalityIndex; // change 1-based to zero-based index
-    if (personalityIndex > sectionHeader.personalityArrayCount()) {
+    if (personalityIndex >= sectionHeader.personalityArrayCount()) {
       _LIBUNWIND_DEBUG_LOG("found encoding 0x%08X with personality index %d,  "
-                            "but personality table has only %d entires",
+                            "but personality table has only %d entries",
                             encoding, personalityIndex,
                             sectionHeader.personalityArrayCount());
       return false;
@@ -1266,15 +1874,74 @@ bool UnwindCursor<A, R>::getInfoFromCompactEncodingSection(pint_t pc,
 #endif // defined(_LIBUNWIND_SUPPORT_COMPACT_UNWIND)
 
 
+#if defined(_LIBUNWIND_SUPPORT_SEH_UNWIND)
+template <typename A, typename R>
+bool UnwindCursor<A, R>::getInfoFromSEH(pint_t pc) {
+  pint_t base;
+  RUNTIME_FUNCTION *unwindEntry = lookUpSEHUnwindInfo(pc, &base);
+  if (!unwindEntry) {
+    _LIBUNWIND_DEBUG_LOG("\tpc not in table, pc=0x%llX", (uint64_t) pc);
+    return false;
+  }
+  _info.gp = 0;
+  _info.flags = 0;
+  _info.format = 0;
+  _info.unwind_info_size = sizeof(RUNTIME_FUNCTION);
+  _info.unwind_info = reinterpret_cast<unw_word_t>(unwindEntry);
+  _info.extra = base;
+  _info.start_ip = base + unwindEntry->BeginAddress;
+#ifdef _LIBUNWIND_TARGET_X86_64
+  _info.end_ip = base + unwindEntry->EndAddress;
+  // Only fill in the handler and LSDA if they're stale.
+  if (pc != getLastPC()) {
+    UNWIND_INFO *xdata = reinterpret_cast<UNWIND_INFO *>(base + unwindEntry->UnwindData);
+    if (xdata->Flags & (UNW_FLAG_EHANDLER|UNW_FLAG_UHANDLER)) {
+      // The personality is given in the UNWIND_INFO itself. The LSDA immediately
+      // follows the UNWIND_INFO. (This follows how both Clang and MSVC emit
+      // these structures.)
+      // N.B. UNWIND_INFO structs are DWORD-aligned.
+      uint32_t lastcode = (xdata->CountOfCodes + 1) & ~1;
+      const uint32_t *handler = reinterpret_cast<uint32_t *>(&xdata->UnwindCodes[lastcode]);
+      _info.lsda = reinterpret_cast<unw_word_t>(handler+1);
+      if (*handler) {
+        _info.handler = reinterpret_cast<unw_word_t>(__libunwind_seh_personality);
+      } else
+        _info.handler = 0;
+    } else {
+      _info.lsda = 0;
+      _info.handler = 0;
+    }
+  }
+#elif defined(_LIBUNWIND_TARGET_ARM)
+  _info.end_ip = _info.start_ip + unwindEntry->FunctionLength;
+  _info.lsda = 0; // FIXME
+  _info.handler = 0; // FIXME
+#endif
+  setLastPC(pc);
+  return true;
+}
+#endif
+
+
 template <typename A, typename R>
 void UnwindCursor<A, R>::setInfoBasedOnIPRegister(bool isReturnAddress) {
-  pint_t pc = (pint_t)this->getReg(UNW_REG_IP);
+#if defined(_LIBUNWIND_TARGET_LINUX) && defined(_LIBUNWIND_TARGET_AARCH64)
+  _isSigReturn = false;
+#endif
+
+  pint_t pc = static_cast<pint_t>(this->getReg(UNW_REG_IP));
 #if defined(_LIBUNWIND_ARM_EHABI)
   // Remove the thumb bit so the IP represents the actual instruction address.
   // This matches the behaviour of _Unwind_GetIP on arm.
   pc &= (pint_t)~0x1;
 #endif
 
+  // Exit early if at the top of the stack.
+  if (pc == 0) {
+    _unwindInfoMissing = true;
+    return;
+  }
+
   // If the last line of a function is a "throw" the compiler sometimes
   // emits no instructions after the call to __cxa_throw.  This means
   // the return address is actually the start of the next function.
@@ -1309,6 +1976,12 @@ void UnwindCursor<A, R>::setInfoBasedOnIPRegister(bool isReturnAddress) {
     }
 #endif // defined(_LIBUNWIND_SUPPORT_COMPACT_UNWIND)
 
+#if defined(_LIBUNWIND_SUPPORT_SEH_UNWIND)
+    // If there is SEH unwind info, look there next.
+    if (this->getInfoFromSEH(pc))
+      return;
+#endif
+
 #if defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND)
     // If there is dwarf unwind info, look there next.
     if (sects.dwarf_section != 0) {
@@ -1329,68 +2002,102 @@ void UnwindCursor<A, R>::setInfoBasedOnIPRegister(bool isReturnAddress) {
 #if defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND)
   // There is no static unwind info for this pc. Look to see if an FDE was
   // dynamically registered for it.
-  pint_t cachedFDE = DwarfFDECache<A>::findFDE(0, pc);
+  pint_t cachedFDE = DwarfFDECache<A>::findFDE(DwarfFDECache<A>::kSearchAll,
+                                               pc);
   if (cachedFDE != 0) {
-    CFI_Parser<LocalAddressSpace>::FDE_Info fdeInfo;
-    CFI_Parser<LocalAddressSpace>::CIE_Info cieInfo;
-    const char *msg = CFI_Parser<A>::decodeFDE(_addressSpace,
-                                                cachedFDE, &fdeInfo, &cieInfo);
-    if (msg == NULL) {
-      typename CFI_Parser<A>::PrologInfo prolog;
-      if (CFI_Parser<A>::parseFDEInstructions(_addressSpace, fdeInfo, cieInfo,
-                                                                pc, &prolog)) {
-        // save off parsed FDE info
-        _info.start_ip         = fdeInfo.pcStart;
-        _info.end_ip           = fdeInfo.pcEnd;
-        _info.lsda             = fdeInfo.lsda;
-        _info.handler          = cieInfo.personality;
-        _info.gp               = prolog.spExtraArgSize;
-                                  // Some frameless functions need SP
-                                  // altered when resuming in function.
-        _info.flags            = 0;
-        _info.format           = dwarfEncoding();
-        _info.unwind_info      = fdeInfo.fdeStart;
-        _info.unwind_info_size = (uint32_t)fdeInfo.fdeLength;
-        _info.extra            = 0;
+    typename CFI_Parser<A>::FDE_Info fdeInfo;
+    typename CFI_Parser<A>::CIE_Info cieInfo;
+    if (!CFI_Parser<A>::decodeFDE(_addressSpace, cachedFDE, &fdeInfo, &cieInfo))
+      if (getInfoFromFdeCie(fdeInfo, cieInfo, pc, 0))
         return;
-      }
-    }
   }
 
   // Lastly, ask AddressSpace object about platform specific ways to locate
   // other FDEs.
   pint_t fde;
   if (_addressSpace.findOtherFDE(pc, fde)) {
-    CFI_Parser<LocalAddressSpace>::FDE_Info fdeInfo;
-    CFI_Parser<LocalAddressSpace>::CIE_Info cieInfo;
+    typename CFI_Parser<A>::FDE_Info fdeInfo;
+    typename CFI_Parser<A>::CIE_Info cieInfo;
     if (!CFI_Parser<A>::decodeFDE(_addressSpace, fde, &fdeInfo, &cieInfo)) {
       // Double check this FDE is for a function that includes the pc.
-      if ((fdeInfo.pcStart <= pc) && (pc < fdeInfo.pcEnd)) {
-        typename CFI_Parser<A>::PrologInfo prolog;
-        if (CFI_Parser<A>::parseFDEInstructions(_addressSpace, fdeInfo,
-                                                cieInfo, pc, &prolog)) {
-          // save off parsed FDE info
-          _info.start_ip         = fdeInfo.pcStart;
-          _info.end_ip           = fdeInfo.pcEnd;
-          _info.lsda             = fdeInfo.lsda;
-          _info.handler          = cieInfo.personality;
-          _info.gp               = prolog.spExtraArgSize;
-          _info.flags            = 0;
-          _info.format           = dwarfEncoding();
-          _info.unwind_info      = fdeInfo.fdeStart;
-          _info.unwind_info_size = (uint32_t)fdeInfo.fdeLength;
-          _info.extra            = 0;
+      if ((fdeInfo.pcStart <= pc) && (pc < fdeInfo.pcEnd))
+        if (getInfoFromFdeCie(fdeInfo, cieInfo, pc, 0))
           return;
-        }
-      }
     }
   }
 #endif // #if defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND)
 
+#if defined(_LIBUNWIND_TARGET_LINUX) && defined(_LIBUNWIND_TARGET_AARCH64)
+  if (setInfoForSigReturn())
+    return;
+#endif
+
   // no unwind info, flag that we can't reliably unwind
   _unwindInfoMissing = true;
 }
 
+#if defined(_LIBUNWIND_TARGET_LINUX) && defined(_LIBUNWIND_TARGET_AARCH64)
+template <typename A, typename R>
+bool UnwindCursor<A, R>::setInfoForSigReturn(Registers_arm64 &) {
+  // Look for the sigreturn trampoline. The trampoline's body is two
+  // specific instructions (see below). Typically the trampoline comes from the
+  // vDSO[1] (i.e. the __kernel_rt_sigreturn function). A libc might provide its
+  // own restorer function, though, or user-mode QEMU might write a trampoline
+  // onto the stack.
+  //
+  // This special code path is a fallback that is only used if the trampoline
+  // lacks proper (e.g. DWARF) unwind info. On AArch64, a new DWARF register
+  // constant for the PC needs to be defined before DWARF can handle a signal
+  // trampoline. This code may segfault if the target PC is unreadable, e.g.:
+  //  - The PC points at a function compiled without unwind info, and which is
+  //    part of an execute-only mapping (e.g. using -Wl,--execute-only).
+  //  - The PC is invalid and happens to point to unreadable or unmapped memory.
+  //
+  // [1] https://github.com/torvalds/linux/blob/master/arch/arm64/kernel/vdso/sigreturn.S
+  const pint_t pc = static_cast<pint_t>(this->getReg(UNW_REG_IP));
+  // Look for instructions: mov x8, #0x8b; svc #0x0
+  if (_addressSpace.get32(pc) == 0xd2801168 &&
+      _addressSpace.get32(pc + 4) == 0xd4000001) {
+    _info = {};
+    _isSigReturn = true;
+    return true;
+  }
+  return false;
+}
+
+template <typename A, typename R>
+int UnwindCursor<A, R>::stepThroughSigReturn(Registers_arm64 &) {
+  // In the signal trampoline frame, sp points to an rt_sigframe[1], which is:
+  //  - 128-byte siginfo struct
+  //  - ucontext struct:
+  //     - 8-byte long (uc_flags)
+  //     - 8-byte pointer (uc_link)
+  //     - 24-byte stack_t
+  //     - 128-byte signal set
+  //     - 8 bytes of padding because sigcontext has 16-byte alignment
+  //     - sigcontext/mcontext_t
+  // [1] https://github.com/torvalds/linux/blob/master/arch/arm64/kernel/signal.c
+  const pint_t kOffsetSpToSigcontext = (128 + 8 + 8 + 24 + 128 + 8); // 304
+
+  // Offsets from sigcontext to each register.
+  const pint_t kOffsetGprs = 8; // offset to "__u64 regs[31]" field
+  const pint_t kOffsetSp = 256; // offset to "__u64 sp" field
+  const pint_t kOffsetPc = 264; // offset to "__u64 pc" field
+
+  pint_t sigctx = _registers.getSP() + kOffsetSpToSigcontext;
+
+  for (int i = 0; i <= 30; ++i) {
+    uint64_t value = _addressSpace.get64(sigctx + kOffsetGprs +
+                                         static_cast<pint_t>(i * 8));
+    _registers.setRegister(UNW_AARCH64_X0 + i, value);
+  }
+  _registers.setSP(_addressSpace.get64(sigctx + kOffsetSp));
+  _registers.setIP(_addressSpace.get64(sigctx + kOffsetPc));
+  _isSignalFrame = true;
+  return UNW_STEP_SUCCESS;
+}
+#endif // defined(_LIBUNWIND_TARGET_LINUX) && defined(_LIBUNWIND_TARGET_AARCH64)
+
 template <typename A, typename R>
 int UnwindCursor<A, R>::step() {
   // Bottom of stack is defined is when unwind info cannot be found.
@@ -1399,25 +2106,33 @@ int UnwindCursor<A, R>::step() {
 
   // Use unwinding info to modify register set as if function returned.
   int result;
+#if defined(_LIBUNWIND_TARGET_LINUX) && defined(_LIBUNWIND_TARGET_AARCH64)
+  if (_isSigReturn) {
+    result = this->stepThroughSigReturn();
+  } else
+#endif
+  {
 #if defined(_LIBUNWIND_SUPPORT_COMPACT_UNWIND)
-  result = this->stepWithCompactEncoding();
+    result = this->stepWithCompactEncoding();
+#elif defined(_LIBUNWIND_SUPPORT_SEH_UNWIND)
+    result = this->stepWithSEHData();
 #elif defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND)
-  result = this->stepWithDwarfFDE();
+    result = this->stepWithDwarfFDE();
 #elif defined(_LIBUNWIND_ARM_EHABI)
-  result = this->stepWithEHABI();
+    result = this->stepWithEHABI();
 #else
   #error Need _LIBUNWIND_SUPPORT_COMPACT_UNWIND or \
+              _LIBUNWIND_SUPPORT_SEH_UNWIND or \
               _LIBUNWIND_SUPPORT_DWARF_UNWIND or \
               _LIBUNWIND_ARM_EHABI
 #endif
+  }
 
   // update info based on new PC
   if (result == UNW_STEP_SUCCESS) {
     this->setInfoBasedOnIPRegister(true);
     if (_unwindInfoMissing)
       return UNW_STEP_END;
-    if (_info.gp)
-      setReg(UNW_REG_SP, getReg(UNW_REG_SP) + _info.gp);
   }
 
   return result;
@@ -1425,7 +2140,10 @@ int UnwindCursor<A, R>::step() {
 
 template <typename A, typename R>
 void UnwindCursor<A, R>::getInfo(unw_proc_info_t *info) {
-  *info = _info;
+  if (_unwindInfoMissing)
+    memset(info, 0, sizeof(*info));
+  else
+    *info = _info;
 }
 
 template <typename A, typename R>
@@ -1435,6 +2153,12 @@ bool UnwindCursor<A, R>::getFunctionName(char *buf, size_t bufLen,
                                          buf, bufLen, offset);
 }
 
+#if defined(_LIBUNWIND_USE_CET)
+extern "C" void *__libunwind_cet_get_registers(unw_cursor_t *cursor) {
+  AbstractUnwindCursor *co = (AbstractUnwindCursor *)cursor;
+  return co->get_registers();
+}
+#endif
 } // namespace libunwind
 
 #endif // __UNWINDCURSOR_HPP__
diff --git a/WAVM/ThirdParty/libunwind/src/UnwindLevel1-gcc-ext.c b/WAVM/ThirdParty/libunwind/src/UnwindLevel1-gcc-ext.c
index 10619ba4..951d5d21 100644
--- a/WAVM/ThirdParty/libunwind/src/UnwindLevel1-gcc-ext.c
+++ b/WAVM/ThirdParty/libunwind/src/UnwindLevel1-gcc-ext.c
@@ -1,9 +1,8 @@
-//===--------------------- UnwindLevel1-gcc-ext.c -------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
+//===----------------------------------------------------------------------===//
 //
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //
 //  Implements gcc extensions to the C++ ABI Exception Handling Level 1.
@@ -25,28 +24,25 @@
 
 #if defined(_LIBUNWIND_BUILD_ZERO_COST_APIS)
 
+#if defined(_LIBUNWIND_SUPPORT_SEH_UNWIND)
+#define PRIVATE_1 private_[0]
+#elif defined(_LIBUNWIND_ARM_EHABI)
+#define PRIVATE_1 unwinder_cache.reserved1
+#else
+#define PRIVATE_1 private_1
+#endif
+
 ///  Called by __cxa_rethrow().
 _LIBUNWIND_EXPORT _Unwind_Reason_Code
 _Unwind_Resume_or_Rethrow(_Unwind_Exception *exception_object) {
-#if defined(_LIBUNWIND_ARM_EHABI)
-  _LIBUNWIND_TRACE_API("_Unwind_Resume_or_Rethrow(ex_obj=%p), private_1=%ld",
-                       (void *)exception_object,
-                       (long)exception_object->unwinder_cache.reserved1);
-#else
-  _LIBUNWIND_TRACE_API("_Unwind_Resume_or_Rethrow(ex_obj=%p), private_1=%ld",
-                       (void *)exception_object,
-                       (long)exception_object->private_1);
-#endif
+  _LIBUNWIND_TRACE_API(
+      "_Unwind_Resume_or_Rethrow(ex_obj=%p), private_1=%" PRIdPTR,
+      (void *)exception_object, (intptr_t)exception_object->PRIVATE_1);
 
-#if defined(_LIBUNWIND_ARM_EHABI)
-  // _Unwind_RaiseException on EHABI will always set the reserved1 field to 0,
-  // which is in the same position as private_1 below.
-  return _Unwind_RaiseException(exception_object);
-#else
   // If this is non-forced and a stopping place was found, then this is a
   // re-throw.
   // Call _Unwind_RaiseException() as if this was a new exception
-  if (exception_object->private_1 == 0) {
+  if (exception_object->PRIVATE_1 == 0) {
     return _Unwind_RaiseException(exception_object);
     // Will return if there is no catch clause, so that __cxa_rethrow can call
     // std::terminate().
@@ -57,10 +53,8 @@ _Unwind_Resume_or_Rethrow(_Unwind_Exception *exception_object) {
   _Unwind_Resume(exception_object);
   _LIBUNWIND_ABORT("_Unwind_Resume_or_Rethrow() called _Unwind_RaiseException()"
                    " which unexpectedly returned");
-#endif
 }
 
-
 /// Called by personality handler during phase 2 to get base address for data
 /// relative encodings.
 _LIBUNWIND_EXPORT uintptr_t
@@ -90,11 +84,11 @@ _LIBUNWIND_EXPORT void *_Unwind_FindEnclosingFunction(void *pc) {
   unw_cursor_t cursor;
   unw_context_t uc;
   unw_proc_info_t info;
-  unw_getcontext(&uc);
-  unw_init_local(&cursor, &uc);
-  unw_set_reg(&cursor, UNW_REG_IP, (unw_word_t)(long) pc);
-  if (unw_get_proc_info(&cursor, &info) == UNW_ESUCCESS)
-    return (void *)(long) info.start_ip;
+  __unw_getcontext(&uc);
+  __unw_init_local(&cursor, &uc);
+  __unw_set_reg(&cursor, UNW_REG_IP, (unw_word_t)(intptr_t)pc);
+  if (__unw_get_proc_info(&cursor, &info) == UNW_ESUCCESS)
+    return (void *)(intptr_t) info.start_ip;
   else
     return NULL;
 }
@@ -105,8 +99,8 @@ _LIBUNWIND_EXPORT _Unwind_Reason_Code
 _Unwind_Backtrace(_Unwind_Trace_Fn callback, void *ref) {
   unw_cursor_t cursor;
   unw_context_t uc;
-  unw_getcontext(&uc);
-  unw_init_local(&cursor, &uc);
+  __unw_getcontext(&uc);
+  __unw_init_local(&cursor, &uc);
 
   _LIBUNWIND_TRACE_API("_Unwind_Backtrace(callback=%p)",
                        (void *)(uintptr_t)callback);
@@ -115,7 +109,7 @@ _Unwind_Backtrace(_Unwind_Trace_Fn callback, void *ref) {
   // Create a mock exception object for force unwinding.
   _Unwind_Exception ex;
   memset(&ex, '\0', sizeof(ex));
-  ex.exception_class = 0x434C4E47554E5700; // CLNGUNW\0
+  strcpy((char *)&ex.exception_class, "CLNGUNW");
 #endif
 
   // walk each frame
@@ -125,7 +119,7 @@ _Unwind_Backtrace(_Unwind_Trace_Fn callback, void *ref) {
 #if !defined(_LIBUNWIND_ARM_EHABI)
     // ask libunwind to get next frame (skip over first frame which is
     // _Unwind_Backtrace())
-    if (unw_step(&cursor) <= 0) {
+    if (__unw_step(&cursor) <= 0) {
       _LIBUNWIND_TRACE_UNWINDING(" _backtrace: ended because cursor reached "
                                  "bottom of stack, returning %d",
                                  _URC_END_OF_STACK);
@@ -134,7 +128,7 @@ _Unwind_Backtrace(_Unwind_Trace_Fn callback, void *ref) {
 #else
     // Get the information for this frame.
     unw_proc_info_t frameInfo;
-    if (unw_get_proc_info(&cursor, &frameInfo) != UNW_ESUCCESS) {
+    if (__unw_get_proc_info(&cursor, &frameInfo) != UNW_ESUCCESS) {
       return _URC_END_OF_STACK;
     }
 
@@ -146,7 +140,7 @@ _Unwind_Backtrace(_Unwind_Trace_Fn callback, void *ref) {
 
     struct _Unwind_Context *context = (struct _Unwind_Context *)&cursor;
     // Get and call the personality function to unwind the frame.
-    __personality_routine handler = (__personality_routine) frameInfo.handler;
+    _Unwind_Personality_Fn handler = (_Unwind_Personality_Fn)frameInfo.handler;
     if (handler == NULL) {
       return _URC_END_OF_STACK;
     }
@@ -161,8 +155,8 @@ _Unwind_Backtrace(_Unwind_Trace_Fn callback, void *ref) {
       char functionName[512];
       unw_proc_info_t frame;
       unw_word_t offset;
-      unw_get_proc_name(&cursor, functionName, 512, &offset);
-      unw_get_proc_info(&cursor, &frame);
+      __unw_get_proc_name(&cursor, functionName, 512, &offset);
+      __unw_get_proc_info(&cursor, &frame);
       _LIBUNWIND_TRACE_UNWINDING(
           " _backtrace: start_ip=0x%" PRIxPTR ", func=%s, lsda=0x%" PRIxPTR ", context=%p",
           frame.start_ip, functionName, frame.lsda,
@@ -188,16 +182,16 @@ _LIBUNWIND_EXPORT const void *_Unwind_Find_FDE(const void *pc,
   unw_cursor_t cursor;
   unw_context_t uc;
   unw_proc_info_t info;
-  unw_getcontext(&uc);
-  unw_init_local(&cursor, &uc);
-  unw_set_reg(&cursor, UNW_REG_IP, (unw_word_t)(long) pc);
-  unw_get_proc_info(&cursor, &info);
+  __unw_getcontext(&uc);
+  __unw_init_local(&cursor, &uc);
+  __unw_set_reg(&cursor, UNW_REG_IP, (unw_word_t)(intptr_t)pc);
+  __unw_get_proc_info(&cursor, &info);
   bases->tbase = (uintptr_t)info.extra;
   bases->dbase = 0; // dbase not used on Mac OS X
   bases->func = (uintptr_t)info.start_ip;
   _LIBUNWIND_TRACE_API("_Unwind_Find_FDE(pc=%p) => %p", pc,
-                  (void *)(long) info.unwind_info);
-  return (void *)(long) info.unwind_info;
+                  (void *)(intptr_t) info.unwind_info);
+  return (void *)(intptr_t) info.unwind_info;
 }
 
 /// Returns the CFA (call frame area, or stack pointer at start of function)
@@ -205,7 +199,7 @@ _LIBUNWIND_EXPORT const void *_Unwind_Find_FDE(const void *pc,
 _LIBUNWIND_EXPORT uintptr_t _Unwind_GetCFA(struct _Unwind_Context *context) {
   unw_cursor_t *cursor = (unw_cursor_t *)context;
   unw_word_t result;
-  unw_get_reg(cursor, UNW_REG_SP, &result);
+  __unw_get_reg(cursor, UNW_REG_SP, &result);
   _LIBUNWIND_TRACE_API("_Unwind_GetCFA(context=%p) => 0x%" PRIxPTR,
                        (void *)context, result);
   return (uintptr_t)result;
@@ -218,7 +212,14 @@ _LIBUNWIND_EXPORT uintptr_t _Unwind_GetCFA(struct _Unwind_Context *context) {
 _LIBUNWIND_EXPORT uintptr_t _Unwind_GetIPInfo(struct _Unwind_Context *context,
                                               int *ipBefore) {
   _LIBUNWIND_TRACE_API("_Unwind_GetIPInfo(context=%p)", (void *)context);
-  *ipBefore = 0;
+  int isSignalFrame = __unw_is_signal_frame((unw_cursor_t *)context);
+  // Negative means some kind of error (probably UNW_ENOINFO), but we have no
+  // good way to report that, and this maintains backward compatibility with the
+  // implementation that hard-coded zero in every case, even signal frames.
+  if (isSignalFrame <= 0)
+    *ipBefore = 0;
+  else
+    *ipBefore = 1;
   return _Unwind_GetIP(context);
 }
 
@@ -230,7 +231,7 @@ _LIBUNWIND_EXPORT uintptr_t _Unwind_GetIPInfo(struct _Unwind_Context *context,
 /// was broken until 10.6.
 _LIBUNWIND_EXPORT void __register_frame(const void *fde) {
   _LIBUNWIND_TRACE_API("__register_frame(%p)", fde);
-  _unw_add_dynamic_fde((unw_word_t)(uintptr_t) fde);
+  __unw_add_dynamic_fde((unw_word_t)(uintptr_t)fde);
 }
 
 
@@ -240,7 +241,7 @@ _LIBUNWIND_EXPORT void __register_frame(const void *fde) {
 /// was broken until 10.6.
 _LIBUNWIND_EXPORT void __deregister_frame(const void *fde) {
   _LIBUNWIND_TRACE_API("__deregister_frame(%p)", fde);
-  _unw_remove_dynamic_fde((unw_word_t)(uintptr_t) fde);
+  __unw_remove_dynamic_fde((unw_word_t)(uintptr_t)fde);
 }
 
 
diff --git a/WAVM/ThirdParty/libunwind/src/UnwindLevel1.c b/WAVM/ThirdParty/libunwind/src/UnwindLevel1.c
index 518577b1..5c1f99d4 100644
--- a/WAVM/ThirdParty/libunwind/src/UnwindLevel1.c
+++ b/WAVM/ThirdParty/libunwind/src/UnwindLevel1.c
@@ -1,13 +1,12 @@
-//===------------------------- UnwindLevel1.c -----------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
+//===----------------------------------------------------------------------===//
 //
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //
 // Implements C++ ABI Exception Handling Level 1 as documented at:
-//      http://mentorembedded.github.io/cxx-abi/abi-eh.html
+//      https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html
 // using libunwind
 //
 //===----------------------------------------------------------------------===//
@@ -26,67 +25,107 @@
 #include <stdio.h>
 #include <string.h>
 
+#include "cet_unwind.h"
+#include "config.h"
 #include "libunwind.h"
+#include "libunwind_ext.h"
 #include "unwind.h"
-#include "config.h"
 
 #if !defined(_LIBUNWIND_ARM_EHABI) && !defined(__USING_SJLJ_EXCEPTIONS__)
 
+#ifndef _LIBUNWIND_SUPPORT_SEH_UNWIND
+
+// When CET is enabled, each "call" instruction will push return address to
+// CET shadow stack, each "ret" instruction will pop current CET shadow stack
+// top and compare it with target address which program will return.
+// In exception handing, some stack frames will be skipped before jumping to
+// landing pad and we must adjust CET shadow stack accordingly.
+// _LIBUNWIND_POP_CET_SSP is used to adjust CET shadow stack pointer and we
+// directly jump to __libunwind_Registerts_x86/x86_64_jumpto instead of using
+// a regular function call to avoid pushing to CET shadow stack again.
+#if !defined(_LIBUNWIND_USE_CET)
+#define __unw_phase2_resume(cursor, fn) __unw_resume((cursor))
+#elif defined(_LIBUNWIND_TARGET_I386)
+#define __unw_phase2_resume(cursor, fn)                                        \
+  do {                                                                         \
+    _LIBUNWIND_POP_CET_SSP((fn));                                              \
+    void *cetRegContext = __libunwind_cet_get_registers((cursor));             \
+    void *cetJumpAddress = __libunwind_cet_get_jump_target();                  \
+    __asm__ volatile("push %%edi\n\t"                                          \
+                     "sub $4, %%esp\n\t"                                       \
+                     "jmp *%%edx\n\t" :: "D"(cetRegContext),                   \
+                     "d"(cetJumpAddress));                                     \
+  } while (0)
+#elif defined(_LIBUNWIND_TARGET_X86_64)
+#define __unw_phase2_resume(cursor, fn)                                        \
+  do {                                                                         \
+    _LIBUNWIND_POP_CET_SSP((fn));                                              \
+    void *cetRegContext = __libunwind_cet_get_registers((cursor));             \
+    void *cetJumpAddress = __libunwind_cet_get_jump_target();                  \
+    __asm__ volatile("jmpq *%%rdx\n\t" :: "D"(cetRegContext),                  \
+                     "d"(cetJumpAddress));                                     \
+  } while (0)
+#endif
+
 static _Unwind_Reason_Code
 unwind_phase1(unw_context_t *uc, unw_cursor_t *cursor, _Unwind_Exception *exception_object) {
-  unw_init_local(cursor, uc);
+  __unw_init_local(cursor, uc);
 
   // Walk each frame looking for a place to stop.
-  bool handlerNotFound = true;
-  while (handlerNotFound) {
+  while (true) {
     // Ask libunwind to get next frame (skip over first which is
     // _Unwind_RaiseException).
-    int stepResult = unw_step(cursor);
+    int stepResult = __unw_step(cursor);
     if (stepResult == 0) {
-      _LIBUNWIND_TRACE_UNWINDING("unwind_phase1(ex_ojb=%p): unw_step() reached "
-                                 "bottom => _URC_END_OF_STACK",
-                                 (void *)exception_object);
+      _LIBUNWIND_TRACE_UNWINDING(
+          "unwind_phase1(ex_ojb=%p): __unw_step() reached "
+          "bottom => _URC_END_OF_STACK",
+          (void *)exception_object);
       return _URC_END_OF_STACK;
     } else if (stepResult < 0) {
-      _LIBUNWIND_TRACE_UNWINDING("unwind_phase1(ex_ojb=%p): unw_step failed => "
-                                 "_URC_FATAL_PHASE1_ERROR",
-                                 (void *)exception_object);
+      _LIBUNWIND_TRACE_UNWINDING(
+          "unwind_phase1(ex_ojb=%p): __unw_step failed => "
+          "_URC_FATAL_PHASE1_ERROR",
+          (void *)exception_object);
       return _URC_FATAL_PHASE1_ERROR;
     }
 
     // See if frame has code to run (has personality routine).
     unw_proc_info_t frameInfo;
     unw_word_t sp;
-    if (unw_get_proc_info(cursor, &frameInfo) != UNW_ESUCCESS) {
-      _LIBUNWIND_TRACE_UNWINDING("unwind_phase1(ex_ojb=%p): unw_get_proc_info "
-                                 "failed => _URC_FATAL_PHASE1_ERROR",
-                                 (void *)exception_object);
+    if (__unw_get_proc_info(cursor, &frameInfo) != UNW_ESUCCESS) {
+      _LIBUNWIND_TRACE_UNWINDING(
+          "unwind_phase1(ex_ojb=%p): __unw_get_proc_info "
+          "failed => _URC_FATAL_PHASE1_ERROR",
+          (void *)exception_object);
       return _URC_FATAL_PHASE1_ERROR;
     }
 
+#ifndef NDEBUG
     // When tracing, print state information.
     if (_LIBUNWIND_TRACING_UNWINDING) {
       char functionBuf[512];
       const char *functionName = functionBuf;
       unw_word_t offset;
-      if ((unw_get_proc_name(cursor, functionBuf, sizeof(functionBuf),
-                             &offset) != UNW_ESUCCESS) ||
+      if ((__unw_get_proc_name(cursor, functionBuf, sizeof(functionBuf),
+                               &offset) != UNW_ESUCCESS) ||
           (frameInfo.start_ip + offset > frameInfo.end_ip))
         functionName = ".anonymous.";
       unw_word_t pc;
-      unw_get_reg(cursor, UNW_REG_IP, &pc);
+      __unw_get_reg(cursor, UNW_REG_IP, &pc);
       _LIBUNWIND_TRACE_UNWINDING(
           "unwind_phase1(ex_ojb=%p): pc=0x%" PRIxPTR ", start_ip=0x%" PRIxPTR
           ", func=%s, lsda=0x%" PRIxPTR ", personality=0x%" PRIxPTR "",
           (void *)exception_object, pc, frameInfo.start_ip, functionName,
           frameInfo.lsda, frameInfo.handler);
     }
+#endif
 
     // If there is a personality routine, ask it if it will want to stop at
     // this frame.
     if (frameInfo.handler != 0) {
-      __personality_routine p =
-          (__personality_routine)(uintptr_t)(frameInfo.handler);
+      _Unwind_Personality_Fn p =
+          (_Unwind_Personality_Fn)(uintptr_t)(frameInfo.handler);
       _LIBUNWIND_TRACE_UNWINDING(
           "unwind_phase1(ex_ojb=%p): calling personality function %p",
           (void *)exception_object, (void *)(uintptr_t)p);
@@ -97,8 +136,7 @@ unwind_phase1(unw_context_t *uc, unw_cursor_t *cursor, _Unwind_Exception *except
       case _URC_HANDLER_FOUND:
         // found a catch clause or locals that need destructing in this frame
         // stop search and remember stack pointer at the frame
-        handlerNotFound = false;
-        unw_get_reg(cursor, UNW_REG_SP, &sp);
+        __unw_get_reg(cursor, UNW_REG_SP, &sp);
         exception_object->private_2 = (uintptr_t)sp;
         _LIBUNWIND_TRACE_UNWINDING(
             "unwind_phase1(ex_ojb=%p): _URC_HANDLER_FOUND",
@@ -127,47 +165,54 @@ unwind_phase1(unw_context_t *uc, unw_cursor_t *cursor, _Unwind_Exception *except
 
 static _Unwind_Reason_Code
 unwind_phase2(unw_context_t *uc, unw_cursor_t *cursor, _Unwind_Exception *exception_object) {
-  unw_init_local(cursor, uc);
+  __unw_init_local(cursor, uc);
 
   _LIBUNWIND_TRACE_UNWINDING("unwind_phase2(ex_ojb=%p)",
                              (void *)exception_object);
 
+  // uc is initialized by __unw_getcontext in the parent frame. The first stack
+  // frame walked is unwind_phase2.
+  unsigned framesWalked = 1;
   // Walk each frame until we reach where search phase said to stop.
   while (true) {
 
     // Ask libunwind to get next frame (skip over first which is
     // _Unwind_RaiseException).
-    int stepResult = unw_step(cursor);
+    int stepResult = __unw_step(cursor);
     if (stepResult == 0) {
-      _LIBUNWIND_TRACE_UNWINDING("unwind_phase2(ex_ojb=%p): unw_step() reached "
-                                 "bottom => _URC_END_OF_STACK",
-                                 (void *)exception_object);
+      _LIBUNWIND_TRACE_UNWINDING(
+          "unwind_phase2(ex_ojb=%p): __unw_step() reached "
+          "bottom => _URC_END_OF_STACK",
+          (void *)exception_object);
       return _URC_END_OF_STACK;
     } else if (stepResult < 0) {
-      _LIBUNWIND_TRACE_UNWINDING("unwind_phase2(ex_ojb=%p): unw_step failed => "
-                                 "_URC_FATAL_PHASE1_ERROR",
-                                 (void *)exception_object);
+      _LIBUNWIND_TRACE_UNWINDING(
+          "unwind_phase2(ex_ojb=%p): __unw_step failed => "
+          "_URC_FATAL_PHASE1_ERROR",
+          (void *)exception_object);
       return _URC_FATAL_PHASE2_ERROR;
     }
 
     // Get info about this frame.
     unw_word_t sp;
     unw_proc_info_t frameInfo;
-    unw_get_reg(cursor, UNW_REG_SP, &sp);
-    if (unw_get_proc_info(cursor, &frameInfo) != UNW_ESUCCESS) {
-      _LIBUNWIND_TRACE_UNWINDING("unwind_phase2(ex_ojb=%p): unw_get_proc_info "
-                                 "failed => _URC_FATAL_PHASE1_ERROR",
-                                 (void *)exception_object);
+    __unw_get_reg(cursor, UNW_REG_SP, &sp);
+    if (__unw_get_proc_info(cursor, &frameInfo) != UNW_ESUCCESS) {
+      _LIBUNWIND_TRACE_UNWINDING(
+          "unwind_phase2(ex_ojb=%p): __unw_get_proc_info "
+          "failed => _URC_FATAL_PHASE1_ERROR",
+          (void *)exception_object);
       return _URC_FATAL_PHASE2_ERROR;
     }
 
+#ifndef NDEBUG
     // When tracing, print state information.
     if (_LIBUNWIND_TRACING_UNWINDING) {
       char functionBuf[512];
       const char *functionName = functionBuf;
       unw_word_t offset;
-      if ((unw_get_proc_name(cursor, functionBuf, sizeof(functionBuf),
-                             &offset) != UNW_ESUCCESS) ||
+      if ((__unw_get_proc_name(cursor, functionBuf, sizeof(functionBuf),
+                               &offset) != UNW_ESUCCESS) ||
           (frameInfo.start_ip + offset > frameInfo.end_ip))
         functionName = ".anonymous.";
       _LIBUNWIND_TRACE_UNWINDING("unwind_phase2(ex_ojb=%p): start_ip=0x%" PRIxPTR
@@ -177,11 +222,13 @@ unwind_phase2(unw_context_t *uc, unw_cursor_t *cursor, _Unwind_Exception *except
                                  functionName, sp, frameInfo.lsda,
                                  frameInfo.handler);
     }
+#endif
 
+    ++framesWalked;
     // If there is a personality routine, tell it we are unwinding.
     if (frameInfo.handler != 0) {
-      __personality_routine p =
-          (__personality_routine)(uintptr_t)(frameInfo.handler);
+      _Unwind_Personality_Fn p =
+          (_Unwind_Personality_Fn)(uintptr_t)(frameInfo.handler);
       _Unwind_Action action = _UA_CLEANUP_PHASE;
       if (sp == exception_object->private_2) {
         // Tell personality this was the frame it marked in phase 1.
@@ -210,15 +257,16 @@ unwind_phase2(unw_context_t *uc, unw_cursor_t *cursor, _Unwind_Exception *except
         // We may get control back if landing pad calls _Unwind_Resume().
         if (_LIBUNWIND_TRACING_UNWINDING) {
           unw_word_t pc;
-          unw_get_reg(cursor, UNW_REG_IP, &pc);
-          unw_get_reg(cursor, UNW_REG_SP, &sp);
+          __unw_get_reg(cursor, UNW_REG_IP, &pc);
+          __unw_get_reg(cursor, UNW_REG_SP, &sp);
           _LIBUNWIND_TRACE_UNWINDING("unwind_phase2(ex_ojb=%p): re-entering "
                                      "user code with ip=0x%" PRIxPTR
                                      ", sp=0x%" PRIxPTR,
                                      (void *)exception_object, pc, sp);
         }
-        unw_resume(cursor);
-        // unw_resume() only returns if there was an error.
+
+        __unw_phase2_resume(cursor, framesWalked);
+        // __unw_phase2_resume() only returns if there was an error.
         return _URC_FATAL_PHASE2_ERROR;
       default:
         // Personality routine returned an unknown result code.
@@ -238,27 +286,31 @@ static _Unwind_Reason_Code
 unwind_phase2_forced(unw_context_t *uc, unw_cursor_t *cursor,
                      _Unwind_Exception *exception_object,
                      _Unwind_Stop_Fn stop, void *stop_parameter) {
-  unw_init_local(cursor, uc);
+  __unw_init_local(cursor, uc);
 
+  // uc is initialized by __unw_getcontext in the parent frame. The first stack
+  // frame walked is unwind_phase2_forced.
+  unsigned framesWalked = 1;
   // Walk each frame until we reach where search phase said to stop
-  while (unw_step(cursor) > 0) {
+  while (__unw_step(cursor) > 0) {
 
     // Update info about this frame.
     unw_proc_info_t frameInfo;
-    if (unw_get_proc_info(cursor, &frameInfo) != UNW_ESUCCESS) {
-      _LIBUNWIND_TRACE_UNWINDING("unwind_phase2_forced(ex_ojb=%p): unw_step "
+    if (__unw_get_proc_info(cursor, &frameInfo) != UNW_ESUCCESS) {
+      _LIBUNWIND_TRACE_UNWINDING("unwind_phase2_forced(ex_ojb=%p): __unw_step "
                                  "failed => _URC_END_OF_STACK",
                                  (void *)exception_object);
       return _URC_FATAL_PHASE2_ERROR;
     }
 
+#ifndef NDEBUG
     // When tracing, print state information.
     if (_LIBUNWIND_TRACING_UNWINDING) {
       char functionBuf[512];
       const char *functionName = functionBuf;
       unw_word_t offset;
-      if ((unw_get_proc_name(cursor, functionBuf, sizeof(functionBuf),
-                             &offset) != UNW_ESUCCESS) ||
+      if ((__unw_get_proc_name(cursor, functionBuf, sizeof(functionBuf),
+                               &offset) != UNW_ESUCCESS) ||
           (frameInfo.start_ip + offset > frameInfo.end_ip))
         functionName = ".anonymous.";
       _LIBUNWIND_TRACE_UNWINDING(
@@ -267,6 +319,7 @@ unwind_phase2_forced(unw_context_t *uc, unw_cursor_t *cursor,
           (void *)exception_object, frameInfo.start_ip, functionName,
           frameInfo.lsda, frameInfo.handler);
     }
+#endif
 
     // Call stop function at each frame.
     _Unwind_Action action =
@@ -284,10 +337,11 @@ unwind_phase2_forced(unw_context_t *uc, unw_cursor_t *cursor,
       return _URC_FATAL_PHASE2_ERROR;
     }
 
+    ++framesWalked;
     // If there is a personality routine, tell it we are unwinding.
     if (frameInfo.handler != 0) {
-      __personality_routine p =
-          (__personality_routine)(long)(frameInfo.handler);
+      _Unwind_Personality_Fn p =
+          (_Unwind_Personality_Fn)(intptr_t)(frameInfo.handler);
       _LIBUNWIND_TRACE_UNWINDING(
           "unwind_phase2_forced(ex_ojb=%p): calling personality function %p",
           (void *)exception_object, (void *)(uintptr_t)p);
@@ -308,7 +362,7 @@ unwind_phase2_forced(unw_context_t *uc, unw_cursor_t *cursor,
                                    "_URC_INSTALL_CONTEXT",
                                    (void *)exception_object);
         // We may get control back if landing pad calls _Unwind_Resume().
-        unw_resume(cursor);
+        __unw_phase2_resume(cursor, framesWalked);
         break;
       default:
         // Personality routine returned an unknown result code.
@@ -344,7 +398,7 @@ _Unwind_RaiseException(_Unwind_Exception *exception_object) {
                        (void *)exception_object);
   unw_context_t uc;
   unw_cursor_t cursor;
-  unw_getcontext(&uc);
+  __unw_getcontext(&uc);
 
   // Mark that this is a non-forced unwind, so _Unwind_Resume()
   // can do the right thing.
@@ -378,7 +432,7 @@ _Unwind_Resume(_Unwind_Exception *exception_object) {
   _LIBUNWIND_TRACE_API("_Unwind_Resume(ex_obj=%p)", (void *)exception_object);
   unw_context_t uc;
   unw_cursor_t cursor;
-  unw_getcontext(&uc);
+  __unw_getcontext(&uc);
 
   if (exception_object->private_1 != 0)
     unwind_phase2_forced(&uc, &cursor, exception_object,
@@ -403,7 +457,7 @@ _Unwind_ForcedUnwind(_Unwind_Exception *exception_object,
                        (void *)exception_object, (void *)(uintptr_t)stop);
   unw_context_t uc;
   unw_cursor_t cursor;
-  unw_getcontext(&uc);
+  __unw_getcontext(&uc);
 
   // Mark that this is a forced unwind, so _Unwind_Resume() can do
   // the right thing.
@@ -421,7 +475,7 @@ _Unwind_GetLanguageSpecificData(struct _Unwind_Context *context) {
   unw_cursor_t *cursor = (unw_cursor_t *)context;
   unw_proc_info_t frameInfo;
   uintptr_t result = 0;
-  if (unw_get_proc_info(cursor, &frameInfo) == UNW_ESUCCESS)
+  if (__unw_get_proc_info(cursor, &frameInfo) == UNW_ESUCCESS)
     result = (uintptr_t)frameInfo.lsda;
   _LIBUNWIND_TRACE_API(
       "_Unwind_GetLanguageSpecificData(context=%p) => 0x%" PRIxPTR,
@@ -442,13 +496,14 @@ _Unwind_GetRegionStart(struct _Unwind_Context *context) {
   unw_cursor_t *cursor = (unw_cursor_t *)context;
   unw_proc_info_t frameInfo;
   uintptr_t result = 0;
-  if (unw_get_proc_info(cursor, &frameInfo) == UNW_ESUCCESS)
+  if (__unw_get_proc_info(cursor, &frameInfo) == UNW_ESUCCESS)
     result = (uintptr_t)frameInfo.start_ip;
   _LIBUNWIND_TRACE_API("_Unwind_GetRegionStart(context=%p) => 0x%" PRIxPTR,
                        (void *)context, result);
   return result;
 }
 
+#endif // !_LIBUNWIND_SUPPORT_SEH_UNWIND
 
 /// Called by personality handler during phase 2 if a foreign exception
 // is caught.
@@ -466,7 +521,7 @@ _LIBUNWIND_EXPORT uintptr_t
 _Unwind_GetGR(struct _Unwind_Context *context, int index) {
   unw_cursor_t *cursor = (unw_cursor_t *)context;
   unw_word_t result;
-  unw_get_reg(cursor, index, &result);
+  __unw_get_reg(cursor, index, &result);
   _LIBUNWIND_TRACE_API("_Unwind_GetGR(context=%p, reg=%d) => 0x%" PRIxPTR,
                        (void *)context, index, result);
   return (uintptr_t)result;
@@ -479,14 +534,14 @@ _LIBUNWIND_EXPORT void _Unwind_SetGR(struct _Unwind_Context *context, int index,
                        ")",
                        (void *)context, index, value);
   unw_cursor_t *cursor = (unw_cursor_t *)context;
-  unw_set_reg(cursor, index, value);
+  __unw_set_reg(cursor, index, value);
 }
 
 /// Called by personality handler during phase 2 to get instruction pointer.
 _LIBUNWIND_EXPORT uintptr_t _Unwind_GetIP(struct _Unwind_Context *context) {
   unw_cursor_t *cursor = (unw_cursor_t *)context;
   unw_word_t result;
-  unw_get_reg(cursor, UNW_REG_IP, &result);
+  __unw_get_reg(cursor, UNW_REG_IP, &result);
   _LIBUNWIND_TRACE_API("_Unwind_GetIP(context=%p) => 0x%" PRIxPTR,
                        (void *)context, result);
   return (uintptr_t)result;
@@ -500,7 +555,7 @@ _LIBUNWIND_EXPORT void _Unwind_SetIP(struct _Unwind_Context *context,
   _LIBUNWIND_TRACE_API("_Unwind_SetIP(context=%p, value=0x%0" PRIxPTR ")",
                        (void *)context, value);
   unw_cursor_t *cursor = (unw_cursor_t *)context;
-  unw_set_reg(cursor, UNW_REG_IP, value);
+  __unw_set_reg(cursor, UNW_REG_IP, value);
 }
 
 #endif // !defined(_LIBUNWIND_ARM_EHABI) && !defined(__USING_SJLJ_EXCEPTIONS__)
diff --git a/WAVM/ThirdParty/libunwind/src/UnwindRegistersRestore.S b/WAVM/ThirdParty/libunwind/src/UnwindRegistersRestore.S
index a3ba4d14..1df97f5f 100644
--- a/WAVM/ThirdParty/libunwind/src/UnwindRegistersRestore.S
+++ b/WAVM/ThirdParty/libunwind/src/UnwindRegistersRestore.S
@@ -1,9 +1,8 @@
-//===-------------------- UnwindRegistersRestore.S ------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
+//===----------------------------------------------------------------------===//
 //
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
@@ -14,14 +13,10 @@
 #if !defined(__USING_SJLJ_EXCEPTIONS__)
 
 #if defined(__i386__)
-DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind13Registers_x866jumptoEv)
+DEFINE_LIBUNWIND_FUNCTION(__libunwind_Registers_x86_jumpto)
 #
-# void libunwind::Registers_x86::jumpto()
+# extern "C" void __libunwind_Registers_x86_jumpto(Registers_x86 *);
 #
-#if defined(_WIN32)
-# On windows, the 'this' pointer is passed in ecx instead of on the stack
-  movl   %ecx, %eax
-#else
 # On entry:
 #  +                       +
 #  +-----------------------+
@@ -30,8 +25,9 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind13Registers_x866jumptoEv)
 #  + return address        +
 #  +-----------------------+   <-- SP
 #  +                       +
+
+  _LIBUNWIND_CET_ENDBR
   movl   4(%esp), %eax
-#endif
   # set up eax and ret on new stack location
   movl  28(%eax), %edx # edx holds new stack pointer
   subl  $8,%edx
@@ -52,7 +48,8 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind13Registers_x866jumptoEv)
   # skip ss
   # skip eflags
   pop    %eax  # eax was already pushed on new stack
-  ret        # eip was already pushed on new stack
+  pop    %ecx
+  jmp    *%ecx
   # skip cs
   # skip ds
   # skip es
@@ -61,9 +58,9 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind13Registers_x866jumptoEv)
 
 #elif defined(__x86_64__)
 
-DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind16Registers_x86_646jumptoEv)
+DEFINE_LIBUNWIND_FUNCTION(__libunwind_Registers_x86_64_jumpto)
 #
-# void libunwind::Registers_x86_64::jumpto()
+# extern "C" void __libunwind_Registers_x86_64_jumpto(Registers_x86_64 *);
 #
 #if defined(_WIN64)
 # On entry, thread_state pointer is in rcx; move it into rdi
@@ -76,6 +73,7 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind16Registers_x86_646jumptoEv)
 # On entry, thread_state pointer is in rdi
 #endif
 
+  _LIBUNWIND_CET_ENDBR
   movq  56(%rdi), %rax # rax holds new stack pointer
   subq  $16, %rax
   movq  %rax, 56(%rdi)
@@ -125,12 +123,13 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind16Registers_x86_646jumptoEv)
 #endif
   movq  56(%rdi), %rsp  # cut back rsp to new location
   pop    %rdi      # rdi was saved here earlier
-  ret            # rip was saved here
+  pop    %rcx
+  jmpq   *%rcx
 
 
 #elif defined(__powerpc64__)
 
-DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind15Registers_ppc646jumptoEv)
+DEFINE_LIBUNWIND_FUNCTION(_ZN9libunwind15Registers_ppc646jumptoEv)
 //
 // void libunwind::Registers_ppc64::jumpto()
 //
@@ -140,7 +139,7 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind15Registers_ppc646jumptoEv)
 
 // load register (GPR)
 #define PPC64_LR(n) \
-  ld    %r##n, (8 * (n + 2))(%r3)
+  ld    n, (8 * (n + 2))(3)
 
   // restore integral registers
   // skip r0 for now
@@ -176,18 +175,18 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind15Registers_ppc646jumptoEv)
   PPC64_LR(30)
   PPC64_LR(31)
 
-#ifdef PPC64_HAS_VMX
+#if defined(__VSX__)
 
   // restore VS registers
   // (note that this also restores floating point registers and V registers,
   // because part of VS is mapped to these registers)
 
-  addi  %r4, %r3, PPC64_OFFS_FP
+  addi  4, 3, PPC64_OFFS_FP
 
 // load VS register
 #define PPC64_LVS(n)         \
-  lxvd2x  %vs##n, 0, %r4    ;\
-  addi    %r4, %r4, 16
+  lxvd2x  n, 0, 4           ;\
+  addi    4, 4, 16
 
   // restore the first 32 VS regs (and also all floating point regs)
   PPC64_LVS(0)
@@ -226,23 +225,23 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind15Registers_ppc646jumptoEv)
   // use VRSAVE to conditionally restore the remaining VS regs,
   // that are where the V regs are mapped
 
-  ld    %r5, PPC64_OFFS_VRSAVE(%r3)   // test VRsave
-  cmpwi %r5, 0
+  ld    5, PPC64_OFFS_VRSAVE(3)   // test VRsave
+  cmpwi 5, 0
   beq   Lnovec
 
 // conditionally load VS
 #define PPC64_CLVS_BOTTOM(n)               \
   beq    Ldone##n                         ;\
-  addi   %r4, %r3, PPC64_OFFS_FP + n * 16 ;\
-  lxvd2x %vs##n, 0, %r4                   ;\
+  addi   4, 3, PPC64_OFFS_FP + n * 16     ;\
+  lxvd2x n, 0, 4                          ;\
 Ldone##n:
 
-#define PPC64_CLVSl(n)           \
-  andis. %r0, %r5, (1<<(47-n))  ;\
+#define PPC64_CLVSl(n)                    \
+  andis. 0, 5, (1 PPC_LEFT_SHIFT(47-n))  ;\
 PPC64_CLVS_BOTTOM(n)
 
-#define PPC64_CLVSh(n)           \
-  andi.  %r0, %r5, (1<<(63-n))  ;\
+#define PPC64_CLVSh(n)                    \
+  andi.  0, 5, (1 PPC_LEFT_SHIFT(63-n))  ;\
 PPC64_CLVS_BOTTOM(n)
 
   PPC64_CLVSl(32)
@@ -282,7 +281,7 @@ PPC64_CLVS_BOTTOM(n)
 
 // load FP register
 #define PPC64_LF(n) \
-  lfd   %f##n, (PPC64_OFFS_FP + n * 16)(%r3)
+  lfd   n, (PPC64_OFFS_FP + n * 16)(3)
 
   // restore float registers
   PPC64_LF(0)
@@ -318,31 +317,32 @@ PPC64_CLVS_BOTTOM(n)
   PPC64_LF(30)
   PPC64_LF(31)
 
+#if defined(__ALTIVEC__)
   // restore vector registers if any are in use
-  ld    %r5, PPC64_OFFS_VRSAVE(%r3)   // test VRsave
-  cmpwi %r5, 0
+  ld    5, PPC64_OFFS_VRSAVE(3)   // test VRsave
+  cmpwi 5, 0
   beq   Lnovec
 
-  subi  %r4, %r1, 16
+  subi  4, 1, 16
   // r4 is now a 16-byte aligned pointer into the red zone
   // the _vectorScalarRegisters may not be 16-byte aligned
   // so copy via red zone temp buffer
 
 #define PPC64_CLV_UNALIGNED_BOTTOM(n)            \
   beq    Ldone##n                               ;\
-  ld     %r0, (PPC64_OFFS_V + n * 16)(%r3)      ;\
-  std    %r0, 0(%r4)                            ;\
-  ld     %r0, (PPC64_OFFS_V + n * 16 + 8)(%r3)  ;\
-  std    %r0, 8(%r4)                            ;\
-  lvx    %v##n, 0, %r4                          ;\
+  ld     0, (PPC64_OFFS_V + n * 16)(3)          ;\
+  std    0, 0(4)                                ;\
+  ld     0, (PPC64_OFFS_V + n * 16 + 8)(3)      ;\
+  std    0, 8(4)                                ;\
+  lvx    n, 0, 4                                ;\
 Ldone  ## n:
 
-#define PPC64_CLV_UNALIGNEDl(n)  \
-  andis. %r0, %r5, (1<<(15-n))  ;\
+#define PPC64_CLV_UNALIGNEDl(n)                 \
+  andis. 0, 5, (1 PPC_LEFT_SHIFT(15-n))        ;\
 PPC64_CLV_UNALIGNED_BOTTOM(n)
 
-#define PPC64_CLV_UNALIGNEDh(n)  \
-  andi.  %r0, %r5, (1<<(31-n))  ;\
+#define PPC64_CLV_UNALIGNEDh(n)                \
+  andi.  0, 5, (1 PPC_LEFT_SHIFT(31-n))       ;\
 PPC64_CLV_UNALIGNED_BOTTOM(n)
 
   PPC64_CLV_UNALIGNEDl(0)
@@ -379,12 +379,13 @@ PPC64_CLV_UNALIGNED_BOTTOM(n)
   PPC64_CLV_UNALIGNEDh(31)
 
 #endif
+#endif
 
 Lnovec:
-  ld    %r0, PPC64_OFFS_CR(%r3)
-  mtcr  %r0
-  ld    %r0, PPC64_OFFS_SRR0(%r3)
-  mtctr %r0
+  ld    0, PPC64_OFFS_CR(3)
+  mtcr  0
+  ld    0, PPC64_OFFS_SRR0(3)
+  mtctr 0
 
   PPC64_LR(0)
   PPC64_LR(5)
@@ -393,122 +394,125 @@ Lnovec:
   PPC64_LR(3)
   bctr
 
-#elif defined(__ppc__)
-
-DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind13Registers_ppc6jumptoEv)
-;
-; void libunwind::Registers_ppc::jumpto()
-;
-; On entry:
-;  thread_state pointer is in r3
-;
-
-  ; restore integral registerrs
-  ; skip r0 for now
-  ; skip r1 for now
-  lwz     r2, 16(r3)
-  ; skip r3 for now
-  ; skip r4 for now
-  ; skip r5 for now
-  lwz     r6, 32(r3)
-  lwz     r7, 36(r3)
-  lwz     r8, 40(r3)
-  lwz     r9, 44(r3)
-  lwz    r10, 48(r3)
-  lwz    r11, 52(r3)
-  lwz    r12, 56(r3)
-  lwz    r13, 60(r3)
-  lwz    r14, 64(r3)
-  lwz    r15, 68(r3)
-  lwz    r16, 72(r3)
-  lwz    r17, 76(r3)
-  lwz    r18, 80(r3)
-  lwz    r19, 84(r3)
-  lwz    r20, 88(r3)
-  lwz    r21, 92(r3)
-  lwz    r22, 96(r3)
-  lwz    r23,100(r3)
-  lwz    r24,104(r3)
-  lwz    r25,108(r3)
-  lwz    r26,112(r3)
-  lwz    r27,116(r3)
-  lwz    r28,120(r3)
-  lwz    r29,124(r3)
-  lwz    r30,128(r3)
-  lwz    r31,132(r3)
-
-  ; restore float registers
-  lfd    f0, 160(r3)
-  lfd    f1, 168(r3)
-  lfd    f2, 176(r3)
-  lfd    f3, 184(r3)
-  lfd    f4, 192(r3)
-  lfd    f5, 200(r3)
-  lfd    f6, 208(r3)
-  lfd    f7, 216(r3)
-  lfd    f8, 224(r3)
-  lfd    f9, 232(r3)
-  lfd    f10,240(r3)
-  lfd    f11,248(r3)
-  lfd    f12,256(r3)
-  lfd    f13,264(r3)
-  lfd    f14,272(r3)
-  lfd    f15,280(r3)
-  lfd    f16,288(r3)
-  lfd    f17,296(r3)
-  lfd    f18,304(r3)
-  lfd    f19,312(r3)
-  lfd    f20,320(r3)
-  lfd    f21,328(r3)
-  lfd    f22,336(r3)
-  lfd    f23,344(r3)
-  lfd    f24,352(r3)
-  lfd    f25,360(r3)
-  lfd    f26,368(r3)
-  lfd    f27,376(r3)
-  lfd    f28,384(r3)
-  lfd    f29,392(r3)
-  lfd    f30,400(r3)
-  lfd    f31,408(r3)
-
-  ; restore vector registers if any are in use
-  lwz    r5,156(r3)  ; test VRsave
-  cmpwi  r5,0
-  beq    Lnovec
-
-  subi  r4,r1,16
-  rlwinm  r4,r4,0,0,27  ; mask low 4-bits
-  ; r4 is now a 16-byte aligned pointer into the red zone
-  ; the _vectorRegisters may not be 16-byte aligned so copy via red zone temp buffer
-
-
-#define LOAD_VECTOR_UNALIGNEDl(_index) \
-  andis.  r0,r5,(1<<(15-_index))  @\
-  beq    Ldone  ## _index     @\
-  lwz    r0, 424+_index*16(r3)  @\
-  stw    r0, 0(r4)        @\
-  lwz    r0, 424+_index*16+4(r3)  @\
-  stw    r0, 4(r4)        @\
-  lwz    r0, 424+_index*16+8(r3)  @\
-  stw    r0, 8(r4)        @\
-  lwz    r0, 424+_index*16+12(r3)@\
-  stw    r0, 12(r4)        @\
-  lvx    v ## _index,0,r4    @\
-Ldone  ## _index:
-
-#define LOAD_VECTOR_UNALIGNEDh(_index) \
-  andi.  r0,r5,(1<<(31-_index))  @\
-  beq    Ldone  ## _index    @\
-  lwz    r0, 424+_index*16(r3)  @\
-  stw    r0, 0(r4)        @\
-  lwz    r0, 424+_index*16+4(r3)  @\
-  stw    r0, 4(r4)        @\
-  lwz    r0, 424+_index*16+8(r3)  @\
-  stw    r0, 8(r4)        @\
-  lwz    r0, 424+_index*16+12(r3)@\
-  stw    r0, 12(r4)        @\
-  lvx    v ## _index,0,r4    @\
-  Ldone  ## _index:
+#elif defined(__powerpc__)
+
+DEFINE_LIBUNWIND_FUNCTION(_ZN9libunwind13Registers_ppc6jumptoEv)
+//
+// void libunwind::Registers_ppc::jumpto()
+//
+// On entry:
+//  thread_state pointer is in r3
+//
+
+  // restore integral registerrs
+  // skip r0 for now
+  // skip r1 for now
+  lwz     2,  16(3)
+  // skip r3 for now
+  // skip r4 for now
+  // skip r5 for now
+  lwz     6,  32(3)
+  lwz     7,  36(3)
+  lwz     8,  40(3)
+  lwz     9,  44(3)
+  lwz     10, 48(3)
+  lwz     11, 52(3)
+  lwz     12, 56(3)
+  lwz     13, 60(3)
+  lwz     14, 64(3)
+  lwz     15, 68(3)
+  lwz     16, 72(3)
+  lwz     17, 76(3)
+  lwz     18, 80(3)
+  lwz     19, 84(3)
+  lwz     20, 88(3)
+  lwz     21, 92(3)
+  lwz     22, 96(3)
+  lwz     23,100(3)
+  lwz     24,104(3)
+  lwz     25,108(3)
+  lwz     26,112(3)
+  lwz     27,116(3)
+  lwz     28,120(3)
+  lwz     29,124(3)
+  lwz     30,128(3)
+  lwz     31,132(3)
+
+#ifndef __NO_FPRS__
+  // restore float registers
+  lfd     0, 160(3)
+  lfd     1, 168(3)
+  lfd     2, 176(3)
+  lfd     3, 184(3)
+  lfd     4, 192(3)
+  lfd     5, 200(3)
+  lfd     6, 208(3)
+  lfd     7, 216(3)
+  lfd     8, 224(3)
+  lfd     9, 232(3)
+  lfd     10,240(3)
+  lfd     11,248(3)
+  lfd     12,256(3)
+  lfd     13,264(3)
+  lfd     14,272(3)
+  lfd     15,280(3)
+  lfd     16,288(3)
+  lfd     17,296(3)
+  lfd     18,304(3)
+  lfd     19,312(3)
+  lfd     20,320(3)
+  lfd     21,328(3)
+  lfd     22,336(3)
+  lfd     23,344(3)
+  lfd     24,352(3)
+  lfd     25,360(3)
+  lfd     26,368(3)
+  lfd     27,376(3)
+  lfd     28,384(3)
+  lfd     29,392(3)
+  lfd     30,400(3)
+  lfd     31,408(3)
+#endif
+
+#if defined(__ALTIVEC__)
+  // restore vector registers if any are in use
+  lwz     5, 156(3)       // test VRsave
+  cmpwi   5, 0
+  beq     Lnovec
+
+  subi    4, 1, 16
+  rlwinm  4, 4, 0, 0, 27  // mask low 4-bits
+  // r4 is now a 16-byte aligned pointer into the red zone
+  // the _vectorRegisters may not be 16-byte aligned so copy via red zone temp buffer
+
+
+#define LOAD_VECTOR_UNALIGNEDl(_index)          \
+  andis.  0, 5, (1 PPC_LEFT_SHIFT(15-_index)) SEPARATOR \
+  beq     Ldone ## _index             SEPARATOR \
+  lwz     0, 424+_index*16(3)         SEPARATOR \
+  stw     0, 0(%r4)                   SEPARATOR \
+  lwz     0, 424+_index*16+4(%r3)     SEPARATOR \
+  stw     0, 4(%r4)                   SEPARATOR \
+  lwz     0, 424+_index*16+8(%r3)     SEPARATOR \
+  stw     0, 8(%r4)                   SEPARATOR \
+  lwz     0, 424+_index*16+12(%r3)    SEPARATOR \
+  stw     0, 12(%r4)                  SEPARATOR \
+  lvx     _index, 0, 4                SEPARATOR \
+  Ldone ## _index:
+
+#define LOAD_VECTOR_UNALIGNEDh(_index)          \
+  andi.   0, 5, (1 PPC_LEFT_SHIFT(31-_index)) SEPARATOR \
+  beq     Ldone ## _index             SEPARATOR \
+  lwz     0, 424+_index*16(3)         SEPARATOR \
+  stw     0, 0(4)                     SEPARATOR \
+  lwz     0, 424+_index*16+4(3)       SEPARATOR \
+  stw     0, 4(4)                     SEPARATOR \
+  lwz     0, 424+_index*16+8(3)       SEPARATOR \
+  stw     0, 8(%r4)                   SEPARATOR \
+  lwz     0, 424+_index*16+12(3)      SEPARATOR \
+  stw     0, 12(4)                    SEPARATOR \
+  lvx     _index, 0, 4                SEPARATOR \
+  Ldone ## _index:
 
 
   LOAD_VECTOR_UNALIGNEDl(0)
@@ -543,31 +547,32 @@ Ldone  ## _index:
   LOAD_VECTOR_UNALIGNEDh(29)
   LOAD_VECTOR_UNALIGNEDh(30)
   LOAD_VECTOR_UNALIGNEDh(31)
+#endif
 
 Lnovec:
-  lwz    r0, 136(r3) ; __cr
-  mtocrf  255,r0
-  lwz    r0, 148(r3) ; __ctr
-  mtctr  r0
-  lwz    r0, 0(r3)  ; __ssr0
-  mtctr  r0
-  lwz    r0, 8(r3)  ; do r0 now
-  lwz    r5,28(r3)  ; do r5 now
-  lwz    r4,24(r3)  ; do r4 now
-  lwz    r1,12(r3)  ; do sp now
-  lwz    r3,20(r3)  ; do r3 last
+  lwz     0, 136(3)   // __cr
+  mtcr    0
+  lwz     0, 148(3)   // __ctr
+  mtctr   0
+  lwz     0,   0(3)   // __ssr0
+  mtctr   0
+  lwz     0,   8(3)   // do r0 now
+  lwz     5,  28(3)   // do r5 now
+  lwz     4,  24(3)   // do r4 now
+  lwz     1,  12(3)   // do sp now
+  lwz     3,  20(3)   // do r3 last
   bctr
 
-#elif defined(__arm64__) || defined(__aarch64__)
+#elif defined(__aarch64__)
 
 //
-// void libunwind::Registers_arm64::jumpto()
+// extern "C" void __libunwind_Registers_arm64_jumpto(Registers_arm64 *);
 //
 // On entry:
 //  thread_state pointer is in x0
 //
   .p2align 2
-DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind15Registers_arm646jumptoEv)
+DEFINE_LIBUNWIND_FUNCTION(__libunwind_Registers_arm64_jumpto)
   // skip restore of x0,x1 for now
   ldp    x2, x3,  [x0, #0x010]
   ldp    x4, x5,  [x0, #0x020]
@@ -576,7 +581,8 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind15Registers_arm646jumptoEv)
   ldp    x10,x11, [x0, #0x050]
   ldp    x12,x13, [x0, #0x060]
   ldp    x14,x15, [x0, #0x070]
-  ldp    x16,x17, [x0, #0x080]
+  // x16 and x17 were clobbered by the call into the unwinder, so no point in
+  // restoring them.
   ldp    x18,x19, [x0, #0x090]
   ldp    x20,x21, [x0, #0x0A0]
   ldp    x22,x23, [x0, #0x0B0]
@@ -584,8 +590,6 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind15Registers_arm646jumptoEv)
   ldp    x26,x27, [x0, #0x0D0]
   ldp    x28,x29, [x0, #0x0E0]
   ldr    x30,     [x0, #0x100]  // restore pc into lr
-  ldr    x1,      [x0, #0x0F8]
-  mov    sp,x1                  // restore sp
 
   ldp    d0, d1,  [x0, #0x110]
   ldp    d2, d3,  [x0, #0x120]
@@ -605,12 +609,21 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind15Registers_arm646jumptoEv)
   ldr    d30,     [x0, #0x200]
   ldr    d31,     [x0, #0x208]
 
+  // Finally, restore sp. This must be done after the the last read from the
+  // context struct, because it is allocated on the stack, and an exception
+  // could clobber the de-allocated portion of the stack after sp has been
+  // restored.
+  ldr    x16,     [x0, #0x0F8]
   ldp    x0, x1,  [x0, #0x000]  // restore x0,x1
+  mov    sp,x16                 // restore sp
   ret    x30                    // jump to pc
 
 #elif defined(__arm__) && !defined(__APPLE__)
 
 #if !defined(__ARM_ARCH_ISA_ARM)
+#if (__ARM_ARCH_ISA_THUMB == 2)
+  .syntax unified
+#endif
   .thumb
 #endif
 
@@ -621,7 +634,7 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind15Registers_arm646jumptoEv)
 @  thread_state pointer is in r0
 @
   .p2align 2
-DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind13Registers_arm20restoreCoreAndJumpToEv)
+DEFINE_LIBUNWIND_FUNCTION(_ZN9libunwind13Registers_arm20restoreCoreAndJumpToEv)
 #if !defined(__ARM_ARCH_ISA_ARM) && __ARM_ARCH_ISA_THUMB == 1
   @ r8-r11: ldm into r1-r4, then mov to r8-r11
   adds r0, #0x20
@@ -647,7 +660,13 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind13Registers_arm20restoreCoreAndJu
   ldr sp, [lr, #52]
   ldr lr, [lr, #60]  @ restore pc into lr
 #endif
+#if defined(__ARM_FEATURE_BTI_DEFAULT) && !defined(__ARM_ARCH_ISA_ARM)
+  // 'bx' is not BTI setting when used with lr, therefore r12 is used instead
+  mov r12, lr
+  JMP(r12)
+#else
   JMP(lr)
+#endif
 
 @
 @ static void libunwind::Registers_arm::restoreVFPWithFLDMD(unw_fpreg_t* values)
@@ -659,7 +678,7 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind13Registers_arm20restoreCoreAndJu
 #if defined(__ELF__)
   .fpu vfpv3-d16
 #endif
-DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind13Registers_arm19restoreVFPWithFLDMDEPy)
+DEFINE_LIBUNWIND_FUNCTION(_ZN9libunwind13Registers_arm19restoreVFPWithFLDMDEPv)
   @ VFP and iwMMX instructions are only available when compiling with the flags
   @ that enable them. We do not want to do that in the library (because we do not
   @ want the compiler to generate instructions that access those) but this is
@@ -680,7 +699,7 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind13Registers_arm19restoreVFPWithFL
 #if defined(__ELF__)
   .fpu vfpv3-d16
 #endif
-DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind13Registers_arm19restoreVFPWithFLDMXEPy)
+DEFINE_LIBUNWIND_FUNCTION(_ZN9libunwind13Registers_arm19restoreVFPWithFLDMXEPv)
   vldmia r0, {d0-d15} @ fldmiax is deprecated in ARMv7+ and now behaves like vldmia
   JMP(lr)
 
@@ -694,7 +713,7 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind13Registers_arm19restoreVFPWithFL
 #if defined(__ELF__)
   .fpu vfpv3
 #endif
-DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind13Registers_arm12restoreVFPv3EPy)
+DEFINE_LIBUNWIND_FUNCTION(_ZN9libunwind13Registers_arm12restoreVFPv3EPv)
   vldmia r0, {d16-d31}
   JMP(lr)
 
@@ -710,7 +729,7 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind13Registers_arm12restoreVFPv3EPy)
 #if defined(__ELF__)
   .arch armv5te
 #endif
-DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind13Registers_arm12restoreiWMMXEPy)
+DEFINE_LIBUNWIND_FUNCTION(_ZN9libunwind13Registers_arm12restoreiWMMXEPv)
   ldcl p1, cr0, [r0], #8  @ wldrd wR0, [r0], #8
   ldcl p1, cr1, [r0], #8  @ wldrd wR1, [r0], #8
   ldcl p1, cr2, [r0], #8  @ wldrd wR2, [r0], #8
@@ -739,7 +758,7 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind13Registers_arm12restoreiWMMXEPy)
 #if defined(__ELF__)
   .arch armv5te
 #endif
-DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind13Registers_arm19restoreiWMMXControlEPj)
+DEFINE_LIBUNWIND_FUNCTION(_ZN9libunwind13Registers_arm19restoreiWMMXControlEPj)
   ldc2 p1, cr8, [r0], #4  @ wldrw wCGR0, [r0], #4
   ldc2 p1, cr9, [r0], #4  @ wldrw wCGR1, [r0], #4
   ldc2 p1, cr10, [r0], #4  @ wldrw wCGR2, [r0], #4
@@ -750,7 +769,7 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind13Registers_arm19restoreiWMMXCont
 
 #elif defined(__or1k__)
 
-DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind14Registers_or1k6jumptoEv)
+DEFINE_LIBUNWIND_FUNCTION(_ZN9libunwind14Registers_or1k6jumptoEv)
 #
 # void libunwind::Registers_or1k::jumpto()
 #
@@ -758,7 +777,7 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind14Registers_or1k6jumptoEv)
 #  thread_state pointer is in r3
 #
 
-  # restore integral registerrs
+  # restore integral registers
   l.lwz     r0,  0(r3)
   l.lwz     r1,  4(r3)
   l.lwz     r2,  8(r3)
@@ -768,7 +787,7 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind14Registers_or1k6jumptoEv)
   l.lwz     r6, 24(r3)
   l.lwz     r7, 28(r3)
   l.lwz     r8, 32(r3)
-  l.lwz     r9, 36(r3)
+  # skip r9
   l.lwz    r10, 40(r3)
   l.lwz    r11, 44(r3)
   l.lwz    r12, 48(r3)
@@ -792,6 +811,9 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind14Registers_or1k6jumptoEv)
   l.lwz    r30,120(r3)
   l.lwz    r31,124(r3)
 
+  # load new pc into ra
+  l.lwz    r9, 128(r3)
+
   # at last, restore r3
   l.lwz    r3,  12(r3)
 
@@ -799,8 +821,49 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind14Registers_or1k6jumptoEv)
   l.jr     r9
    l.nop
 
-#elif defined(__mips__) && defined(_ABIO32) && _MIPS_SIM == _ABIO32 &&         \
-    defined(__mips_soft_float)
+#elif defined(__hexagon__)
+# On entry:
+#  thread_state pointer is in r2
+DEFINE_LIBUNWIND_FUNCTION(_ZN9libunwind17Registers_hexagon6jumptoEv)
+#
+# void libunwind::Registers_hexagon::jumpto()
+#
+  r8 = memw(r0+#32)
+  r9 = memw(r0+#36)
+  r10 = memw(r0+#40)
+  r11 = memw(r0+#44)
+
+  r12 = memw(r0+#48)
+  r13 = memw(r0+#52)
+  r14 = memw(r0+#56)
+  r15 = memw(r0+#60)
+
+  r16 = memw(r0+#64)
+  r17 = memw(r0+#68)
+  r18 = memw(r0+#72)
+  r19 = memw(r0+#76)
+
+  r20 = memw(r0+#80)
+  r21 = memw(r0+#84)
+  r22 = memw(r0+#88)
+  r23 = memw(r0+#92)
+
+  r24 = memw(r0+#96)
+  r25 = memw(r0+#100)
+  r26 = memw(r0+#104)
+  r27 = memw(r0+#108)
+
+  r28 = memw(r0+#112)
+  r29 = memw(r0+#116)
+  r30 = memw(r0+#120)
+  r31 = memw(r0+#132)
+
+  r1 = memw(r0+#128)
+  c4 = r1   // Predicate register
+  r1 = memw(r0+#4)
+  r0 = memw(r0)
+  jumpr r31
+#elif defined(__mips__) && defined(_ABIO32) && _MIPS_SIM == _ABIO32
 
 //
 // void libunwind::Registers_mips_o32::jumpto()
@@ -808,11 +871,64 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind14Registers_or1k6jumptoEv)
 // On entry:
 //  thread state pointer is in a0 ($4)
 //
-DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind18Registers_mips_o326jumptoEv)
+DEFINE_LIBUNWIND_FUNCTION(_ZN9libunwind18Registers_mips_o326jumptoEv)
   .set push
   .set noat
   .set noreorder
   .set nomacro
+#ifdef __mips_hard_float
+#if __mips_fpr != 64
+  ldc1  $f0, (4 * 36 + 8 * 0)($4)
+  ldc1  $f2, (4 * 36 + 8 * 2)($4)
+  ldc1  $f4, (4 * 36 + 8 * 4)($4)
+  ldc1  $f6, (4 * 36 + 8 * 6)($4)
+  ldc1  $f8, (4 * 36 + 8 * 8)($4)
+  ldc1  $f10, (4 * 36 + 8 * 10)($4)
+  ldc1  $f12, (4 * 36 + 8 * 12)($4)
+  ldc1  $f14, (4 * 36 + 8 * 14)($4)
+  ldc1  $f16, (4 * 36 + 8 * 16)($4)
+  ldc1  $f18, (4 * 36 + 8 * 18)($4)
+  ldc1  $f20, (4 * 36 + 8 * 20)($4)
+  ldc1  $f22, (4 * 36 + 8 * 22)($4)
+  ldc1  $f24, (4 * 36 + 8 * 24)($4)
+  ldc1  $f26, (4 * 36 + 8 * 26)($4)
+  ldc1  $f28, (4 * 36 + 8 * 28)($4)
+  ldc1  $f30, (4 * 36 + 8 * 30)($4)
+#else
+  ldc1  $f0, (4 * 36 + 8 * 0)($4)
+  ldc1  $f1, (4 * 36 + 8 * 1)($4)
+  ldc1  $f2, (4 * 36 + 8 * 2)($4)
+  ldc1  $f3, (4 * 36 + 8 * 3)($4)
+  ldc1  $f4, (4 * 36 + 8 * 4)($4)
+  ldc1  $f5, (4 * 36 + 8 * 5)($4)
+  ldc1  $f6, (4 * 36 + 8 * 6)($4)
+  ldc1  $f7, (4 * 36 + 8 * 7)($4)
+  ldc1  $f8, (4 * 36 + 8 * 8)($4)
+  ldc1  $f9, (4 * 36 + 8 * 9)($4)
+  ldc1  $f10, (4 * 36 + 8 * 10)($4)
+  ldc1  $f11, (4 * 36 + 8 * 11)($4)
+  ldc1  $f12, (4 * 36 + 8 * 12)($4)
+  ldc1  $f13, (4 * 36 + 8 * 13)($4)
+  ldc1  $f14, (4 * 36 + 8 * 14)($4)
+  ldc1  $f15, (4 * 36 + 8 * 15)($4)
+  ldc1  $f16, (4 * 36 + 8 * 16)($4)
+  ldc1  $f17, (4 * 36 + 8 * 17)($4)
+  ldc1  $f18, (4 * 36 + 8 * 18)($4)
+  ldc1  $f19, (4 * 36 + 8 * 19)($4)
+  ldc1  $f20, (4 * 36 + 8 * 20)($4)
+  ldc1  $f21, (4 * 36 + 8 * 21)($4)
+  ldc1  $f22, (4 * 36 + 8 * 22)($4)
+  ldc1  $f23, (4 * 36 + 8 * 23)($4)
+  ldc1  $f24, (4 * 36 + 8 * 24)($4)
+  ldc1  $f25, (4 * 36 + 8 * 25)($4)
+  ldc1  $f26, (4 * 36 + 8 * 26)($4)
+  ldc1  $f27, (4 * 36 + 8 * 27)($4)
+  ldc1  $f28, (4 * 36 + 8 * 28)($4)
+  ldc1  $f29, (4 * 36 + 8 * 29)($4)
+  ldc1  $f30, (4 * 36 + 8 * 30)($4)
+  ldc1  $f31, (4 * 36 + 8 * 31)($4)
+#endif
+#endif
   // restore hi and lo
   lw    $8, (4 * 33)($4)
   mthi  $8
@@ -856,7 +972,7 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind18Registers_mips_o326jumptoEv)
   lw    $4, (4 * 4)($4)
   .set pop
 
-#elif defined(__mips64) && defined(__mips_soft_float)
+#elif defined(__mips64)
 
 //
 // void libunwind::Registers_mips_newabi::jumpto()
@@ -864,11 +980,45 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind18Registers_mips_o326jumptoEv)
 // On entry:
 //  thread state pointer is in a0 ($4)
 //
-DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind21Registers_mips_newabi6jumptoEv)
+DEFINE_LIBUNWIND_FUNCTION(_ZN9libunwind21Registers_mips_newabi6jumptoEv)
   .set push
   .set noat
   .set noreorder
   .set nomacro
+#ifdef __mips_hard_float
+  ldc1  $f0, (8 * 35)($4)
+  ldc1  $f1, (8 * 36)($4)
+  ldc1  $f2, (8 * 37)($4)
+  ldc1  $f3, (8 * 38)($4)
+  ldc1  $f4, (8 * 39)($4)
+  ldc1  $f5, (8 * 40)($4)
+  ldc1  $f6, (8 * 41)($4)
+  ldc1  $f7, (8 * 42)($4)
+  ldc1  $f8, (8 * 43)($4)
+  ldc1  $f9, (8 * 44)($4)
+  ldc1  $f10, (8 * 45)($4)
+  ldc1  $f11, (8 * 46)($4)
+  ldc1  $f12, (8 * 47)($4)
+  ldc1  $f13, (8 * 48)($4)
+  ldc1  $f14, (8 * 49)($4)
+  ldc1  $f15, (8 * 50)($4)
+  ldc1  $f16, (8 * 51)($4)
+  ldc1  $f17, (8 * 52)($4)
+  ldc1  $f18, (8 * 53)($4)
+  ldc1  $f19, (8 * 54)($4)
+  ldc1  $f20, (8 * 55)($4)
+  ldc1  $f21, (8 * 56)($4)
+  ldc1  $f22, (8 * 57)($4)
+  ldc1  $f23, (8 * 58)($4)
+  ldc1  $f24, (8 * 59)($4)
+  ldc1  $f25, (8 * 60)($4)
+  ldc1  $f26, (8 * 61)($4)
+  ldc1  $f27, (8 * 62)($4)
+  ldc1  $f28, (8 * 63)($4)
+  ldc1  $f29, (8 * 64)($4)
+  ldc1  $f30, (8 * 65)($4)
+  ldc1  $f31, (8 * 66)($4)
+#endif
   // restore hi and lo
   ld    $8, (8 * 33)($4)
   mthi  $8
@@ -912,6 +1062,156 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind21Registers_mips_newabi6jumptoEv)
   ld    $4, (8 * 4)($4)
   .set pop
 
+#elif defined(__sparc__) && defined(__arch64__)
+
+DEFINE_LIBUNWIND_FUNCTION(_ZN9libunwind17Registers_sparc646jumptoEv)
+//
+// void libunwind::Registers_sparc64::jumpto()
+//
+// On entry:
+//  thread_state pointer is in %o0
+//
+  .register %g2, #scratch
+  .register %g3, #scratch
+  .register %g6, #scratch
+  .register %g7, #scratch
+  flushw
+  ldx  [%o0 + 0x08], %g1
+  ldx  [%o0 + 0x10], %g2
+  ldx  [%o0 + 0x18], %g3
+  ldx  [%o0 + 0x20], %g4
+  ldx  [%o0 + 0x28], %g5
+  ldx  [%o0 + 0x30], %g6
+  ldx  [%o0 + 0x38], %g7
+  ldx  [%o0 + 0x48], %o1
+  ldx  [%o0 + 0x50], %o2
+  ldx  [%o0 + 0x58], %o3
+  ldx  [%o0 + 0x60], %o4
+  ldx  [%o0 + 0x68], %o5
+  ldx  [%o0 + 0x70], %o6
+  ldx  [%o0 + 0x78], %o7
+  ldx  [%o0 + 0x80], %l0
+  ldx  [%o0 + 0x88], %l1
+  ldx  [%o0 + 0x90], %l2
+  ldx  [%o0 + 0x98], %l3
+  ldx  [%o0 + 0xa0], %l4
+  ldx  [%o0 + 0xa8], %l5
+  ldx  [%o0 + 0xb0], %l6
+  ldx  [%o0 + 0xb8], %l7
+  ldx  [%o0 + 0xc0], %i0
+  ldx  [%o0 + 0xc8], %i1
+  ldx  [%o0 + 0xd0], %i2
+  ldx  [%o0 + 0xd8], %i3
+  ldx  [%o0 + 0xe0], %i4
+  ldx  [%o0 + 0xe8], %i5
+  ldx  [%o0 + 0xf0], %i6
+  ldx  [%o0 + 0xf8], %i7
+  jmp  %o7
+   ldx [%o0 + 0x40], %o0
+
+#elif defined(__sparc__)
+
+//
+// void libunwind::Registers_sparc_o32::jumpto()
+//
+// On entry:
+//  thread_state pointer is in o0
+//
+DEFINE_LIBUNWIND_FUNCTION(_ZN9libunwind15Registers_sparc6jumptoEv)
+  ta 3
+  ldd [%o0 + 64],  %l0
+  ldd [%o0 + 72],  %l2
+  ldd [%o0 + 80],  %l4
+  ldd [%o0 + 88],  %l6
+  ldd [%o0 + 96],  %i0
+  ldd [%o0 + 104], %i2
+  ldd [%o0 + 112], %i4
+  ldd [%o0 + 120], %i6
+  ld  [%o0 + 60],  %o7
+  jmp %o7
+   nop
+
+#elif defined(__riscv)
+
+//
+// void libunwind::Registers_riscv::jumpto()
+//
+// On entry:
+//  thread_state pointer is in a0
+//
+  .p2align 2
+DEFINE_LIBUNWIND_FUNCTION(_ZN9libunwind15Registers_riscv6jumptoEv)
+# if defined(__riscv_flen)
+  FLOAD    f0, (RISCV_FOFFSET + RISCV_FSIZE * 0)(a0)
+  FLOAD    f1, (RISCV_FOFFSET + RISCV_FSIZE * 1)(a0)
+  FLOAD    f2, (RISCV_FOFFSET + RISCV_FSIZE * 2)(a0)
+  FLOAD    f3, (RISCV_FOFFSET + RISCV_FSIZE * 3)(a0)
+  FLOAD    f4, (RISCV_FOFFSET + RISCV_FSIZE * 4)(a0)
+  FLOAD    f5, (RISCV_FOFFSET + RISCV_FSIZE * 5)(a0)
+  FLOAD    f6, (RISCV_FOFFSET + RISCV_FSIZE * 6)(a0)
+  FLOAD    f7, (RISCV_FOFFSET + RISCV_FSIZE * 7)(a0)
+  FLOAD    f8, (RISCV_FOFFSET + RISCV_FSIZE * 8)(a0)
+  FLOAD    f9, (RISCV_FOFFSET + RISCV_FSIZE * 9)(a0)
+  FLOAD    f10, (RISCV_FOFFSET + RISCV_FSIZE * 10)(a0)
+  FLOAD    f11, (RISCV_FOFFSET + RISCV_FSIZE * 11)(a0)
+  FLOAD    f12, (RISCV_FOFFSET + RISCV_FSIZE * 12)(a0)
+  FLOAD    f13, (RISCV_FOFFSET + RISCV_FSIZE * 13)(a0)
+  FLOAD    f14, (RISCV_FOFFSET + RISCV_FSIZE * 14)(a0)
+  FLOAD    f15, (RISCV_FOFFSET + RISCV_FSIZE * 15)(a0)
+  FLOAD    f16, (RISCV_FOFFSET + RISCV_FSIZE * 16)(a0)
+  FLOAD    f17, (RISCV_FOFFSET + RISCV_FSIZE * 17)(a0)
+  FLOAD    f18, (RISCV_FOFFSET + RISCV_FSIZE * 18)(a0)
+  FLOAD    f19, (RISCV_FOFFSET + RISCV_FSIZE * 19)(a0)
+  FLOAD    f20, (RISCV_FOFFSET + RISCV_FSIZE * 20)(a0)
+  FLOAD    f21, (RISCV_FOFFSET + RISCV_FSIZE * 21)(a0)
+  FLOAD    f22, (RISCV_FOFFSET + RISCV_FSIZE * 22)(a0)
+  FLOAD    f23, (RISCV_FOFFSET + RISCV_FSIZE * 23)(a0)
+  FLOAD    f24, (RISCV_FOFFSET + RISCV_FSIZE * 24)(a0)
+  FLOAD    f25, (RISCV_FOFFSET + RISCV_FSIZE * 25)(a0)
+  FLOAD    f26, (RISCV_FOFFSET + RISCV_FSIZE * 26)(a0)
+  FLOAD    f27, (RISCV_FOFFSET + RISCV_FSIZE * 27)(a0)
+  FLOAD    f28, (RISCV_FOFFSET + RISCV_FSIZE * 28)(a0)
+  FLOAD    f29, (RISCV_FOFFSET + RISCV_FSIZE * 29)(a0)
+  FLOAD    f30, (RISCV_FOFFSET + RISCV_FSIZE * 30)(a0)
+  FLOAD    f31, (RISCV_FOFFSET + RISCV_FSIZE * 31)(a0)
+# endif
+
+  // x0 is zero
+  ILOAD    x1, (RISCV_ISIZE * 0)(a0) // restore pc into ra
+  ILOAD    x2, (RISCV_ISIZE * 2)(a0)
+  ILOAD    x3, (RISCV_ISIZE * 3)(a0)
+  ILOAD    x4, (RISCV_ISIZE * 4)(a0)
+  ILOAD    x5, (RISCV_ISIZE * 5)(a0)
+  ILOAD    x6, (RISCV_ISIZE * 6)(a0)
+  ILOAD    x7, (RISCV_ISIZE * 7)(a0)
+  ILOAD    x8, (RISCV_ISIZE * 8)(a0)
+  ILOAD    x9, (RISCV_ISIZE * 9)(a0)
+  // skip a0 for now
+  ILOAD    x11, (RISCV_ISIZE * 11)(a0)
+  ILOAD    x12, (RISCV_ISIZE * 12)(a0)
+  ILOAD    x13, (RISCV_ISIZE * 13)(a0)
+  ILOAD    x14, (RISCV_ISIZE * 14)(a0)
+  ILOAD    x15, (RISCV_ISIZE * 15)(a0)
+  ILOAD    x16, (RISCV_ISIZE * 16)(a0)
+  ILOAD    x17, (RISCV_ISIZE * 17)(a0)
+  ILOAD    x18, (RISCV_ISIZE * 18)(a0)
+  ILOAD    x19, (RISCV_ISIZE * 19)(a0)
+  ILOAD    x20, (RISCV_ISIZE * 20)(a0)
+  ILOAD    x21, (RISCV_ISIZE * 21)(a0)
+  ILOAD    x22, (RISCV_ISIZE * 22)(a0)
+  ILOAD    x23, (RISCV_ISIZE * 23)(a0)
+  ILOAD    x24, (RISCV_ISIZE * 24)(a0)
+  ILOAD    x25, (RISCV_ISIZE * 25)(a0)
+  ILOAD    x26, (RISCV_ISIZE * 26)(a0)
+  ILOAD    x27, (RISCV_ISIZE * 27)(a0)
+  ILOAD    x28, (RISCV_ISIZE * 28)(a0)
+  ILOAD    x29, (RISCV_ISIZE * 29)(a0)
+  ILOAD    x30, (RISCV_ISIZE * 30)(a0)
+  ILOAD    x31, (RISCV_ISIZE * 31)(a0)
+  ILOAD    x10, (RISCV_ISIZE * 10)(a0)   // restore a0
+
+  ret                       // jump to ra
+
 #endif
 
 #endif /* !defined(__USING_SJLJ_EXCEPTIONS__) */
diff --git a/WAVM/ThirdParty/libunwind/src/UnwindRegistersSave.S b/WAVM/ThirdParty/libunwind/src/UnwindRegistersSave.S
index 1b6cff84..b3948923 100644
--- a/WAVM/ThirdParty/libunwind/src/UnwindRegistersSave.S
+++ b/WAVM/ThirdParty/libunwind/src/UnwindRegistersSave.S
@@ -1,9 +1,8 @@
-//===------------------------ UnwindRegistersSave.S -----------------------===//
-//
-//                     The LLVM Compiler Infrastructure
+//===----------------------------------------------------------------------===//
 //
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
@@ -16,7 +15,7 @@
 #if defined(__i386__)
 
 #
-# extern int unw_getcontext(unw_context_t* thread_state)
+# extern int __unw_getcontext(unw_context_t* thread_state)
 #
 # On entry:
 #   +                       +
@@ -27,7 +26,9 @@
 #   +-----------------------+   <-- SP
 #   +                       +
 #
-DEFINE_LIBUNWIND_FUNCTION(unw_getcontext)
+DEFINE_LIBUNWIND_FUNCTION(__unw_getcontext)
+
+  _LIBUNWIND_CET_ENDBR
   push  %eax
   movl  8(%esp), %eax
   movl  %ebx,  4(%eax)
@@ -57,12 +58,12 @@ DEFINE_LIBUNWIND_FUNCTION(unw_getcontext)
 #elif defined(__x86_64__)
 
 #
-# extern int unw_getcontext(unw_context_t* thread_state)
+# extern int __unw_getcontext(unw_context_t* thread_state)
 #
 # On entry:
 #  thread_state pointer is in rdi
 #
-DEFINE_LIBUNWIND_FUNCTION(unw_getcontext)
+DEFINE_LIBUNWIND_FUNCTION(__unw_getcontext)
 #if defined(_WIN64)
 #define PTR %rcx
 #define TMP %rdx
@@ -71,6 +72,7 @@ DEFINE_LIBUNWIND_FUNCTION(unw_getcontext)
 #define TMP %rsi
 #endif
 
+  _LIBUNWIND_CET_ENDBR
   movq  %rax,   (PTR)
   movq  %rbx,  8(PTR)
   movq  %rcx, 16(PTR)
@@ -116,16 +118,15 @@ DEFINE_LIBUNWIND_FUNCTION(unw_getcontext)
   xorl  %eax, %eax    # return UNW_ESUCCESS
   ret
 
-#elif defined(__mips__) && defined(_ABIO32) && _MIPS_SIM == _ABIO32 &&         \
-    defined(__mips_soft_float)
+#elif defined(__mips__) && defined(_ABIO32) && _MIPS_SIM == _ABIO32
 
 #
-# extern int unw_getcontext(unw_context_t* thread_state)
+# extern int __unw_getcontext(unw_context_t* thread_state)
 #
 # On entry:
 #  thread_state pointer is in a0 ($4)
 #
-DEFINE_LIBUNWIND_FUNCTION(unw_getcontext)
+DEFINE_LIBUNWIND_FUNCTION(__unw_getcontext)
   .set push
   .set noat
   .set noreorder
@@ -168,20 +169,73 @@ DEFINE_LIBUNWIND_FUNCTION(unw_getcontext)
   sw    $8,  (4 * 33)($4)
   mflo  $8
   sw    $8,  (4 * 34)($4)
+#ifdef __mips_hard_float
+#if __mips_fpr != 64
+  sdc1  $f0, (4 * 36 + 8 * 0)($4)
+  sdc1  $f2, (4 * 36 + 8 * 2)($4)
+  sdc1  $f4, (4 * 36 + 8 * 4)($4)
+  sdc1  $f6, (4 * 36 + 8 * 6)($4)
+  sdc1  $f8, (4 * 36 + 8 * 8)($4)
+  sdc1  $f10, (4 * 36 + 8 * 10)($4)
+  sdc1  $f12, (4 * 36 + 8 * 12)($4)
+  sdc1  $f14, (4 * 36 + 8 * 14)($4)
+  sdc1  $f16, (4 * 36 + 8 * 16)($4)
+  sdc1  $f18, (4 * 36 + 8 * 18)($4)
+  sdc1  $f20, (4 * 36 + 8 * 20)($4)
+  sdc1  $f22, (4 * 36 + 8 * 22)($4)
+  sdc1  $f24, (4 * 36 + 8 * 24)($4)
+  sdc1  $f26, (4 * 36 + 8 * 26)($4)
+  sdc1  $f28, (4 * 36 + 8 * 28)($4)
+  sdc1  $f30, (4 * 36 + 8 * 30)($4)
+#else
+  sdc1  $f0, (4 * 36 + 8 * 0)($4)
+  sdc1  $f1, (4 * 36 + 8 * 1)($4)
+  sdc1  $f2, (4 * 36 + 8 * 2)($4)
+  sdc1  $f3, (4 * 36 + 8 * 3)($4)
+  sdc1  $f4, (4 * 36 + 8 * 4)($4)
+  sdc1  $f5, (4 * 36 + 8 * 5)($4)
+  sdc1  $f6, (4 * 36 + 8 * 6)($4)
+  sdc1  $f7, (4 * 36 + 8 * 7)($4)
+  sdc1  $f8, (4 * 36 + 8 * 8)($4)
+  sdc1  $f9, (4 * 36 + 8 * 9)($4)
+  sdc1  $f10, (4 * 36 + 8 * 10)($4)
+  sdc1  $f11, (4 * 36 + 8 * 11)($4)
+  sdc1  $f12, (4 * 36 + 8 * 12)($4)
+  sdc1  $f13, (4 * 36 + 8 * 13)($4)
+  sdc1  $f14, (4 * 36 + 8 * 14)($4)
+  sdc1  $f15, (4 * 36 + 8 * 15)($4)
+  sdc1  $f16, (4 * 36 + 8 * 16)($4)
+  sdc1  $f17, (4 * 36 + 8 * 17)($4)
+  sdc1  $f18, (4 * 36 + 8 * 18)($4)
+  sdc1  $f19, (4 * 36 + 8 * 19)($4)
+  sdc1  $f20, (4 * 36 + 8 * 20)($4)
+  sdc1  $f21, (4 * 36 + 8 * 21)($4)
+  sdc1  $f22, (4 * 36 + 8 * 22)($4)
+  sdc1  $f23, (4 * 36 + 8 * 23)($4)
+  sdc1  $f24, (4 * 36 + 8 * 24)($4)
+  sdc1  $f25, (4 * 36 + 8 * 25)($4)
+  sdc1  $f26, (4 * 36 + 8 * 26)($4)
+  sdc1  $f27, (4 * 36 + 8 * 27)($4)
+  sdc1  $f28, (4 * 36 + 8 * 28)($4)
+  sdc1  $f29, (4 * 36 + 8 * 29)($4)
+  sdc1  $f30, (4 * 36 + 8 * 30)($4)
+  sdc1  $f31, (4 * 36 + 8 * 31)($4)
+#endif
+#endif
   jr	$31
   # return UNW_ESUCCESS
   or    $2, $0, $0
   .set pop
 
-#elif defined(__mips64) && defined(__mips_soft_float)
+#elif defined(__mips64)
 
 #
-# extern int unw_getcontext(unw_context_t* thread_state)
+# extern int __unw_getcontext(unw_context_t* thread_state)
 #
 # On entry:
 #  thread_state pointer is in a0 ($4)
 #
-DEFINE_LIBUNWIND_FUNCTION(unw_getcontext)
+DEFINE_LIBUNWIND_FUNCTION(__unw_getcontext)
   .set push
   .set noat
   .set noreorder
@@ -224,6 +278,40 @@ DEFINE_LIBUNWIND_FUNCTION(unw_getcontext)
   sd    $8,  (8 * 33)($4)
   mflo  $8
   sd    $8,  (8 * 34)($4)
+#ifdef __mips_hard_float
+  sdc1  $f0, (8 * 35)($4)
+  sdc1  $f1, (8 * 36)($4)
+  sdc1  $f2, (8 * 37)($4)
+  sdc1  $f3, (8 * 38)($4)
+  sdc1  $f4, (8 * 39)($4)
+  sdc1  $f5, (8 * 40)($4)
+  sdc1  $f6, (8 * 41)($4)
+  sdc1  $f7, (8 * 42)($4)
+  sdc1  $f8, (8 * 43)($4)
+  sdc1  $f9, (8 * 44)($4)
+  sdc1  $f10, (8 * 45)($4)
+  sdc1  $f11, (8 * 46)($4)
+  sdc1  $f12, (8 * 47)($4)
+  sdc1  $f13, (8 * 48)($4)
+  sdc1  $f14, (8 * 49)($4)
+  sdc1  $f15, (8 * 50)($4)
+  sdc1  $f16, (8 * 51)($4)
+  sdc1  $f17, (8 * 52)($4)
+  sdc1  $f18, (8 * 53)($4)
+  sdc1  $f19, (8 * 54)($4)
+  sdc1  $f20, (8 * 55)($4)
+  sdc1  $f21, (8 * 56)($4)
+  sdc1  $f22, (8 * 57)($4)
+  sdc1  $f23, (8 * 58)($4)
+  sdc1  $f24, (8 * 59)($4)
+  sdc1  $f25, (8 * 60)($4)
+  sdc1  $f26, (8 * 61)($4)
+  sdc1  $f27, (8 * 62)($4)
+  sdc1  $f28, (8 * 63)($4)
+  sdc1  $f29, (8 * 64)($4)
+  sdc1  $f30, (8 * 65)($4)
+  sdc1  $f31, (8 * 66)($4)
+#endif
   jr	$31
   # return UNW_ESUCCESS
   or    $2, $0, $0
@@ -232,30 +320,30 @@ DEFINE_LIBUNWIND_FUNCTION(unw_getcontext)
 # elif defined(__mips__)
 
 #
-# extern int unw_getcontext(unw_context_t* thread_state)
+# extern int __unw_getcontext(unw_context_t* thread_state)
 #
 # Just trap for the time being.
-DEFINE_LIBUNWIND_FUNCTION(unw_getcontext)
+DEFINE_LIBUNWIND_FUNCTION(__unw_getcontext)
   teq $0, $0
 
 #elif defined(__powerpc64__)
 
 //
-// extern int unw_getcontext(unw_context_t* thread_state)
+// extern int __unw_getcontext(unw_context_t* thread_state)
 //
 // On entry:
 //  thread_state pointer is in r3
 //
-DEFINE_LIBUNWIND_FUNCTION(unw_getcontext)
+DEFINE_LIBUNWIND_FUNCTION(__unw_getcontext)
 
 // store register (GPR)
 #define PPC64_STR(n) \
-  std   %r##n, (8 * (n + 2))(%r3)
+  std   n, (8 * (n + 2))(3)
 
   // save GPRs
   PPC64_STR(0)
-  mflr  %r0
-  std   %r0, PPC64_OFFS_SRR0(%r3) // store lr as ssr0
+  mflr  0
+  std   0, PPC64_OFFS_SRR0(3) // store lr as ssr0
   PPC64_STR(1)
   PPC64_STR(2)
   PPC64_STR(3)
@@ -288,28 +376,28 @@ DEFINE_LIBUNWIND_FUNCTION(unw_getcontext)
   PPC64_STR(30)
   PPC64_STR(31)
 
-  mfcr  %r0
-  std   %r0,  PPC64_OFFS_CR(%r3)
-  mfxer %r0
-  std   %r0,  PPC64_OFFS_XER(%r3)
-  mflr  %r0
-  std   %r0,  PPC64_OFFS_LR(%r3)
-  mfctr %r0
-  std   %r0,  PPC64_OFFS_CTR(%r3)
-  mfvrsave    %r0
-  std   %r0,  PPC64_OFFS_VRSAVE(%r3)
-
-#ifdef PPC64_HAS_VMX
+  mfcr  0
+  std   0,  PPC64_OFFS_CR(3)
+  mfxer 0
+  std   0,  PPC64_OFFS_XER(3)
+  mflr  0
+  std   0,  PPC64_OFFS_LR(3)
+  mfctr 0
+  std   0,  PPC64_OFFS_CTR(3)
+  mfvrsave    0
+  std   0,  PPC64_OFFS_VRSAVE(3)
+
+#if defined(__VSX__)
   // save VS registers
   // (note that this also saves floating point registers and V registers,
   // because part of VS is mapped to these registers)
 
-  addi  %r4, %r3, PPC64_OFFS_FP
+  addi  4, 3, PPC64_OFFS_FP
 
 // store VS register
 #define PPC64_STVS(n)      \
-  stxvd2x %vs##n, 0, %r4  ;\
-  addi    %r4, %r4, 16
+  stxvd2x n, 0, 4         ;\
+  addi    4, 4, 16
 
   PPC64_STVS(0)
   PPC64_STVS(1)
@@ -380,7 +468,7 @@ DEFINE_LIBUNWIND_FUNCTION(unw_getcontext)
 
 // store FP register
 #define PPC64_STF(n) \
-  stfd  %f##n, (PPC64_OFFS_FP + n * 16)(%r3)
+  stfd  n, (PPC64_OFFS_FP + n * 16)(3)
 
   // save float registers
   PPC64_STF(0)
@@ -416,19 +504,20 @@ DEFINE_LIBUNWIND_FUNCTION(unw_getcontext)
   PPC64_STF(30)
   PPC64_STF(31)
 
+#if defined(__ALTIVEC__)
   // save vector registers
 
   // Use 16-bytes below the stack pointer as an
   // aligned buffer to save each vector register.
   // Note that the stack pointer is always 16-byte aligned.
-  subi  %r4, %r1, 16
+  subi  4, 1, 16
 
-#define PPC64_STV_UNALIGNED(n)                 \
-  stvx  %v##n, 0, %r4                         ;\
-  ld    %r5, 0(%r4)                           ;\
-  std   %r5, (PPC64_OFFS_V + n * 16)(%r3)     ;\
-  ld    %r5, 8(%r4)                           ;\
-  std   %r5, (PPC64_OFFS_V + n * 16 + 8)(%r3)
+#define PPC64_STV_UNALIGNED(n)             \
+  stvx  n, 0, 4                           ;\
+  ld    5, 0(4)                           ;\
+  std   5, (PPC64_OFFS_V + n * 16)(3)     ;\
+  ld    5, 8(4)                           ;\
+  std   5, (PPC64_OFFS_V + n * 16 + 8)(3)
 
   PPC64_STV_UNALIGNED(0)
   PPC64_STV_UNALIGNED(1)
@@ -463,165 +552,171 @@ DEFINE_LIBUNWIND_FUNCTION(unw_getcontext)
   PPC64_STV_UNALIGNED(30)
   PPC64_STV_UNALIGNED(31)
 
+#endif
 #endif
 
-  li    %r3,  0   // return UNW_ESUCCESS
+  li    3,  0   // return UNW_ESUCCESS
   blr
 
 
-#elif defined(__ppc__)
-
-;
-; extern int unw_getcontext(unw_context_t* thread_state)
-;
-; On entry:
-;  thread_state pointer is in r3
-;
-DEFINE_LIBUNWIND_FUNCTION(unw_getcontext)
-  stw    r0,  8(r3)
-  mflr  r0
-  stw    r0,  0(r3)  ; store lr as ssr0
-  stw    r1, 12(r3)
-  stw    r2, 16(r3)
-  stw    r3, 20(r3)
-  stw    r4, 24(r3)
-  stw    r5, 28(r3)
-  stw    r6, 32(r3)
-  stw    r7, 36(r3)
-  stw    r8, 40(r3)
-  stw    r9, 44(r3)
-  stw     r10, 48(r3)
-  stw     r11, 52(r3)
-  stw     r12, 56(r3)
-  stw     r13, 60(r3)
-  stw     r14, 64(r3)
-  stw     r15, 68(r3)
-  stw     r16, 72(r3)
-  stw     r17, 76(r3)
-  stw     r18, 80(r3)
-  stw     r19, 84(r3)
-  stw     r20, 88(r3)
-  stw     r21, 92(r3)
-  stw     r22, 96(r3)
-  stw     r23,100(r3)
-  stw     r24,104(r3)
-  stw     r25,108(r3)
-  stw     r26,112(r3)
-  stw     r27,116(r3)
-  stw     r28,120(r3)
-  stw     r29,124(r3)
-  stw     r30,128(r3)
-  stw     r31,132(r3)
-
-  ; save VRSave register
-  mfspr  r0,256
-  stw    r0,156(r3)
-  ; save CR registers
-  mfcr  r0
-  stw    r0,136(r3)
-  ; save CTR register
-  mfctr  r0
-  stw    r0,148(r3)
-
-  ; save float registers
-  stfd    f0, 160(r3)
-  stfd    f1, 168(r3)
-  stfd    f2, 176(r3)
-  stfd    f3, 184(r3)
-  stfd    f4, 192(r3)
-  stfd    f5, 200(r3)
-  stfd    f6, 208(r3)
-  stfd    f7, 216(r3)
-  stfd    f8, 224(r3)
-  stfd    f9, 232(r3)
-  stfd    f10,240(r3)
-  stfd    f11,248(r3)
-  stfd    f12,256(r3)
-  stfd    f13,264(r3)
-  stfd    f14,272(r3)
-  stfd    f15,280(r3)
-  stfd    f16,288(r3)
-  stfd    f17,296(r3)
-  stfd    f18,304(r3)
-  stfd    f19,312(r3)
-  stfd    f20,320(r3)
-  stfd    f21,328(r3)
-  stfd    f22,336(r3)
-  stfd    f23,344(r3)
-  stfd    f24,352(r3)
-  stfd    f25,360(r3)
-  stfd    f26,368(r3)
-  stfd    f27,376(r3)
-  stfd    f28,384(r3)
-  stfd    f29,392(r3)
-  stfd    f30,400(r3)
-  stfd    f31,408(r3)
-
-
-  ; save vector registers
-
-  subi  r4,r1,16
-  rlwinm  r4,r4,0,0,27  ; mask low 4-bits
-  ; r4 is now a 16-byte aligned pointer into the red zone
+#elif defined(__powerpc__)
+
+//
+// extern int unw_getcontext(unw_context_t* thread_state)
+//
+// On entry:
+//  thread_state pointer is in r3
+//
+DEFINE_LIBUNWIND_FUNCTION(__unw_getcontext)
+  stw     0,   8(3)
+  mflr    0
+  stw     0,   0(3) // store lr as ssr0
+  stw     1,  12(3)
+  stw     2,  16(3)
+  stw     3,  20(3)
+  stw     4,  24(3)
+  stw     5,  28(3)
+  stw     6,  32(3)
+  stw     7,  36(3)
+  stw     8,  40(3)
+  stw     9,  44(3)
+  stw     10, 48(3)
+  stw     11, 52(3)
+  stw     12, 56(3)
+  stw     13, 60(3)
+  stw     14, 64(3)
+  stw     15, 68(3)
+  stw     16, 72(3)
+  stw     17, 76(3)
+  stw     18, 80(3)
+  stw     19, 84(3)
+  stw     20, 88(3)
+  stw     21, 92(3)
+  stw     22, 96(3)
+  stw     23,100(3)
+  stw     24,104(3)
+  stw     25,108(3)
+  stw     26,112(3)
+  stw     27,116(3)
+  stw     28,120(3)
+  stw     29,124(3)
+  stw     30,128(3)
+  stw     31,132(3)
+
+#if defined(__ALTIVEC__)
+  // save VRSave register
+  mfspr   0, 256
+  stw     0, 156(3)
+#endif
+  // save CR registers
+  mfcr    0
+  stw     0, 136(3)
+  // save CTR register
+  mfctr   0
+  stw     0, 148(3)
+
+#if !defined(__NO_FPRS__)
+  // save float registers
+  stfd    0, 160(3)
+  stfd    1, 168(3)
+  stfd    2, 176(3)
+  stfd    3, 184(3)
+  stfd    4, 192(3)
+  stfd    5, 200(3)
+  stfd    6, 208(3)
+  stfd    7, 216(3)
+  stfd    8, 224(3)
+  stfd    9, 232(3)
+  stfd    10,240(3)
+  stfd    11,248(3)
+  stfd    12,256(3)
+  stfd    13,264(3)
+  stfd    14,272(3)
+  stfd    15,280(3)
+  stfd    16,288(3)
+  stfd    17,296(3)
+  stfd    18,304(3)
+  stfd    19,312(3)
+  stfd    20,320(3)
+  stfd    21,328(3)
+  stfd    22,336(3)
+  stfd    23,344(3)
+  stfd    24,352(3)
+  stfd    25,360(3)
+  stfd    26,368(3)
+  stfd    27,376(3)
+  stfd    28,384(3)
+  stfd    29,392(3)
+  stfd    30,400(3)
+  stfd    31,408(3)
+#endif
+
+#if defined(__ALTIVEC__)
+  // save vector registers
+
+  subi    4, 1, 16
+  rlwinm  4, 4, 0, 0, 27  // mask low 4-bits
+  // r4 is now a 16-byte aligned pointer into the red zone
 
 #define SAVE_VECTOR_UNALIGNED(_vec, _offset) \
-  stvx  _vec,0,r4           @\
-  lwz    r5, 0(r4)          @\
-  stw    r5, _offset(r3)    @\
-  lwz    r5, 4(r4)          @\
-  stw    r5, _offset+4(r3)  @\
-  lwz    r5, 8(r4)          @\
-  stw    r5, _offset+8(r3)  @\
-  lwz    r5, 12(r4)         @\
-  stw    r5, _offset+12(r3)
-
-  SAVE_VECTOR_UNALIGNED( v0, 424+0x000)
-  SAVE_VECTOR_UNALIGNED( v1, 424+0x010)
-  SAVE_VECTOR_UNALIGNED( v2, 424+0x020)
-  SAVE_VECTOR_UNALIGNED( v3, 424+0x030)
-  SAVE_VECTOR_UNALIGNED( v4, 424+0x040)
-  SAVE_VECTOR_UNALIGNED( v5, 424+0x050)
-  SAVE_VECTOR_UNALIGNED( v6, 424+0x060)
-  SAVE_VECTOR_UNALIGNED( v7, 424+0x070)
-  SAVE_VECTOR_UNALIGNED( v8, 424+0x080)
-  SAVE_VECTOR_UNALIGNED( v9, 424+0x090)
-  SAVE_VECTOR_UNALIGNED(v10, 424+0x0A0)
-  SAVE_VECTOR_UNALIGNED(v11, 424+0x0B0)
-  SAVE_VECTOR_UNALIGNED(v12, 424+0x0C0)
-  SAVE_VECTOR_UNALIGNED(v13, 424+0x0D0)
-  SAVE_VECTOR_UNALIGNED(v14, 424+0x0E0)
-  SAVE_VECTOR_UNALIGNED(v15, 424+0x0F0)
-  SAVE_VECTOR_UNALIGNED(v16, 424+0x100)
-  SAVE_VECTOR_UNALIGNED(v17, 424+0x110)
-  SAVE_VECTOR_UNALIGNED(v18, 424+0x120)
-  SAVE_VECTOR_UNALIGNED(v19, 424+0x130)
-  SAVE_VECTOR_UNALIGNED(v20, 424+0x140)
-  SAVE_VECTOR_UNALIGNED(v21, 424+0x150)
-  SAVE_VECTOR_UNALIGNED(v22, 424+0x160)
-  SAVE_VECTOR_UNALIGNED(v23, 424+0x170)
-  SAVE_VECTOR_UNALIGNED(v24, 424+0x180)
-  SAVE_VECTOR_UNALIGNED(v25, 424+0x190)
-  SAVE_VECTOR_UNALIGNED(v26, 424+0x1A0)
-  SAVE_VECTOR_UNALIGNED(v27, 424+0x1B0)
-  SAVE_VECTOR_UNALIGNED(v28, 424+0x1C0)
-  SAVE_VECTOR_UNALIGNED(v29, 424+0x1D0)
-  SAVE_VECTOR_UNALIGNED(v30, 424+0x1E0)
-  SAVE_VECTOR_UNALIGNED(v31, 424+0x1F0)
-
-  li  r3, 0    ; return UNW_ESUCCESS
+  stvx    _vec, 0, 4               SEPARATOR \
+  lwz     5, 0(4)                  SEPARATOR \
+  stw     5, _offset(3)            SEPARATOR \
+  lwz     5, 4(4)                  SEPARATOR \
+  stw     5, _offset+4(3)          SEPARATOR \
+  lwz     5, 8(4)                  SEPARATOR \
+  stw     5, _offset+8(3)          SEPARATOR \
+  lwz     5, 12(4)                 SEPARATOR \
+  stw     5, _offset+12(3)
+
+  SAVE_VECTOR_UNALIGNED( 0, 424+0x000)
+  SAVE_VECTOR_UNALIGNED( 1, 424+0x010)
+  SAVE_VECTOR_UNALIGNED( 2, 424+0x020)
+  SAVE_VECTOR_UNALIGNED( 3, 424+0x030)
+  SAVE_VECTOR_UNALIGNED( 4, 424+0x040)
+  SAVE_VECTOR_UNALIGNED( 5, 424+0x050)
+  SAVE_VECTOR_UNALIGNED( 6, 424+0x060)
+  SAVE_VECTOR_UNALIGNED( 7, 424+0x070)
+  SAVE_VECTOR_UNALIGNED( 8, 424+0x080)
+  SAVE_VECTOR_UNALIGNED( 9, 424+0x090)
+  SAVE_VECTOR_UNALIGNED(10, 424+0x0A0)
+  SAVE_VECTOR_UNALIGNED(11, 424+0x0B0)
+  SAVE_VECTOR_UNALIGNED(12, 424+0x0C0)
+  SAVE_VECTOR_UNALIGNED(13, 424+0x0D0)
+  SAVE_VECTOR_UNALIGNED(14, 424+0x0E0)
+  SAVE_VECTOR_UNALIGNED(15, 424+0x0F0)
+  SAVE_VECTOR_UNALIGNED(16, 424+0x100)
+  SAVE_VECTOR_UNALIGNED(17, 424+0x110)
+  SAVE_VECTOR_UNALIGNED(18, 424+0x120)
+  SAVE_VECTOR_UNALIGNED(19, 424+0x130)
+  SAVE_VECTOR_UNALIGNED(20, 424+0x140)
+  SAVE_VECTOR_UNALIGNED(21, 424+0x150)
+  SAVE_VECTOR_UNALIGNED(22, 424+0x160)
+  SAVE_VECTOR_UNALIGNED(23, 424+0x170)
+  SAVE_VECTOR_UNALIGNED(24, 424+0x180)
+  SAVE_VECTOR_UNALIGNED(25, 424+0x190)
+  SAVE_VECTOR_UNALIGNED(26, 424+0x1A0)
+  SAVE_VECTOR_UNALIGNED(27, 424+0x1B0)
+  SAVE_VECTOR_UNALIGNED(28, 424+0x1C0)
+  SAVE_VECTOR_UNALIGNED(29, 424+0x1D0)
+  SAVE_VECTOR_UNALIGNED(30, 424+0x1E0)
+  SAVE_VECTOR_UNALIGNED(31, 424+0x1F0)
+#endif
+
+  li      3, 0  // return UNW_ESUCCESS
   blr
 
 
-#elif defined(__arm64__) || defined(__aarch64__)
+#elif defined(__aarch64__)
 
 //
-// extern int unw_getcontext(unw_context_t* thread_state)
+// extern int __unw_getcontext(unw_context_t* thread_state)
 //
 // On entry:
 //  thread_state pointer is in x0
 //
   .p2align 2
-DEFINE_LIBUNWIND_FUNCTION(unw_getcontext)
+DEFINE_LIBUNWIND_FUNCTION(__unw_getcontext)
   stp    x0, x1,  [x0, #0x000]
   stp    x2, x3,  [x0, #0x010]
   stp    x4, x5,  [x0, #0x020]
@@ -665,11 +760,14 @@ DEFINE_LIBUNWIND_FUNCTION(unw_getcontext)
 #elif defined(__arm__) && !defined(__APPLE__)
 
 #if !defined(__ARM_ARCH_ISA_ARM)
+#if (__ARM_ARCH_ISA_THUMB == 2)
+  .syntax unified
+#endif
   .thumb
 #endif
 
 @
-@ extern int unw_getcontext(unw_context_t* thread_state)
+@ extern int __unw_getcontext(unw_context_t* thread_state)
 @
 @ On entry:
 @  thread_state pointer is in r0
@@ -678,10 +776,10 @@ DEFINE_LIBUNWIND_FUNCTION(unw_getcontext)
 @ EHABI #7.4.5 notes that in general all VRS registers should be restored
 @ however this is very hard to do for VFP registers because it is unknown
 @ to the library how many registers are implemented by the architecture.
-@ Instead, VFP registers are demand saved by logic external to unw_getcontext.
+@ Instead, VFP registers are demand saved by logic external to __unw_getcontext.
 @
   .p2align 2
-DEFINE_LIBUNWIND_FUNCTION(unw_getcontext)
+DEFINE_LIBUNWIND_FUNCTION(__unw_getcontext)
 #if !defined(__ARM_ARCH_ISA_ARM) && __ARM_ARCH_ISA_THUMB == 1
   stm r0!, {r0-r7}
   mov r1, r8
@@ -722,7 +820,7 @@ DEFINE_LIBUNWIND_FUNCTION(unw_getcontext)
 #if defined(__ELF__)
   .fpu vfpv3-d16
 #endif
-DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind13Registers_arm16saveVFPWithFSTMDEPy)
+DEFINE_LIBUNWIND_FUNCTION(_ZN9libunwind13Registers_arm16saveVFPWithFSTMDEPv)
   vstmia r0, {d0-d15}
   JMP(lr)
 
@@ -736,7 +834,7 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind13Registers_arm16saveVFPWithFSTMD
 #if defined(__ELF__)
   .fpu vfpv3-d16
 #endif
-DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind13Registers_arm16saveVFPWithFSTMXEPy)
+DEFINE_LIBUNWIND_FUNCTION(_ZN9libunwind13Registers_arm16saveVFPWithFSTMXEPv)
   vstmia r0, {d0-d15} @ fstmiax is deprecated in ARMv7+ and now behaves like vstmia
   JMP(lr)
 
@@ -750,7 +848,7 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind13Registers_arm16saveVFPWithFSTMX
 #if defined(__ELF__)
   .fpu vfpv3
 #endif
-DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind13Registers_arm9saveVFPv3EPy)
+DEFINE_LIBUNWIND_FUNCTION(_ZN9libunwind13Registers_arm9saveVFPv3EPv)
   @ VFP and iwMMX instructions are only available when compiling with the flags
   @ that enable them. We do not want to do that in the library (because we do not
   @ want the compiler to generate instructions that access those) but this is
@@ -773,7 +871,7 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind13Registers_arm9saveVFPv3EPy)
 #if defined(__ELF__)
   .arch armv5te
 #endif
-DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind13Registers_arm9saveiWMMXEPy)
+DEFINE_LIBUNWIND_FUNCTION(_ZN9libunwind13Registers_arm9saveiWMMXEPv)
   stcl p1, cr0, [r0], #8  @ wstrd wR0, [r0], #8
   stcl p1, cr1, [r0], #8  @ wstrd wR1, [r0], #8
   stcl p1, cr2, [r0], #8  @ wstrd wR2, [r0], #8
@@ -802,7 +900,7 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind13Registers_arm9saveiWMMXEPy)
 #if defined(__ELF__)
   .arch armv5te
 #endif
-DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind13Registers_arm16saveiWMMXControlEPj)
+DEFINE_LIBUNWIND_FUNCTION(_ZN9libunwind13Registers_arm16saveiWMMXControlEPj)
   stc2 p1, cr8, [r0], #4  @ wstrw wCGR0, [r0], #4
   stc2 p1, cr9, [r0], #4  @ wstrw wCGR1, [r0], #4
   stc2 p1, cr10, [r0], #4  @ wstrw wCGR2, [r0], #4
@@ -814,12 +912,12 @@ DEFINE_LIBUNWIND_PRIVATE_FUNCTION(_ZN9libunwind13Registers_arm16saveiWMMXControl
 #elif defined(__or1k__)
 
 #
-# extern int unw_getcontext(unw_context_t* thread_state)
+# extern int __unw_getcontext(unw_context_t* thread_state)
 #
 # On entry:
 #  thread_state pointer is in r3
 #
-DEFINE_LIBUNWIND_FUNCTION(unw_getcontext)
+DEFINE_LIBUNWIND_FUNCTION(__unw_getcontext)
   l.sw       0(r3), r0
   l.sw       4(r3), r1
   l.sw       8(r3), r2
@@ -852,9 +950,228 @@ DEFINE_LIBUNWIND_FUNCTION(unw_getcontext)
   l.sw     116(r3), r29
   l.sw     120(r3), r30
   l.sw     124(r3), r31
+  # store ra to pc
+  l.sw     128(r3), r9
+  # zero epcr
+  l.sw     132(r3), r0
+
+#elif defined(__hexagon__)
+#
+# extern int unw_getcontext(unw_context_t* thread_state)
+#
+# On entry:
+#  thread_state pointer is in r0
+#
+#define OFFSET(offset) (offset/4)
+DEFINE_LIBUNWIND_FUNCTION(__unw_getcontext)
+  memw(r0+#32) = r8
+  memw(r0+#36) = r9
+  memw(r0+#40) = r10
+  memw(r0+#44) = r11
+
+  memw(r0+#48) = r12
+  memw(r0+#52) = r13
+  memw(r0+#56) = r14
+  memw(r0+#60) = r15
+
+  memw(r0+#64) = r16
+  memw(r0+#68) = r17
+  memw(r0+#72) = r18
+  memw(r0+#76) = r19
+
+  memw(r0+#80) = r20
+  memw(r0+#84) = r21
+  memw(r0+#88) = r22
+  memw(r0+#92) = r23
+
+  memw(r0+#96) = r24
+  memw(r0+#100) = r25
+  memw(r0+#104) = r26
+  memw(r0+#108) = r27
+
+  memw(r0+#112) = r28
+  memw(r0+#116) = r29
+  memw(r0+#120) = r30
+  memw(r0+#124) = r31
+  r1 = c4   // Predicate register
+  memw(r0+#128) = r1
+  r1 = memw(r30)           // *FP == Saved FP
+  r1 = r31
+  memw(r0+#132) = r1
+
+  jumpr r31
+
+#elif defined(__sparc__) && defined(__arch64__)
+
+#
+# extern int __unw_getcontext(unw_context_t* thread_state)
+#
+# On entry:
+#  thread_state pointer is in %o0
+#
+DEFINE_LIBUNWIND_FUNCTION(__unw_getcontext)
+  .register %g2, #scratch
+  .register %g3, #scratch
+  .register %g6, #scratch
+  .register %g7, #scratch
+  stx  %g1, [%o0 + 0x08]
+  stx  %g2, [%o0 + 0x10]
+  stx  %g3, [%o0 + 0x18]
+  stx  %g4, [%o0 + 0x20]
+  stx  %g5, [%o0 + 0x28]
+  stx  %g6, [%o0 + 0x30]
+  stx  %g7, [%o0 + 0x38]
+  stx  %o0, [%o0 + 0x40]
+  stx  %o1, [%o0 + 0x48]
+  stx  %o2, [%o0 + 0x50]
+  stx  %o3, [%o0 + 0x58]
+  stx  %o4, [%o0 + 0x60]
+  stx  %o5, [%o0 + 0x68]
+  stx  %o6, [%o0 + 0x70]
+  stx  %o7, [%o0 + 0x78]
+  stx  %l0, [%o0 + 0x80]
+  stx  %l1, [%o0 + 0x88]
+  stx  %l2, [%o0 + 0x90]
+  stx  %l3, [%o0 + 0x98]
+  stx  %l4, [%o0 + 0xa0]
+  stx  %l5, [%o0 + 0xa8]
+  stx  %l6, [%o0 + 0xb0]
+  stx  %l7, [%o0 + 0xb8]
+  stx  %i0, [%o0 + 0xc0]
+  stx  %i1, [%o0 + 0xc8]
+  stx  %i2, [%o0 + 0xd0]
+  stx  %i3, [%o0 + 0xd8]
+  stx  %i4, [%o0 + 0xe0]
+  stx  %i5, [%o0 + 0xe8]
+  stx  %i6, [%o0 + 0xf0]
+  stx  %i7, [%o0 + 0xf8]
+
+  # save StackGhost cookie
+  mov  %i7, %g4
+  save %sp, -176, %sp
+  # register window flush necessary even without StackGhost
+  flushw
+  restore
+  ldx  [%sp + 2047 + 0x78], %g5
+  xor  %g4, %g5, %g4
+  stx  %g4, [%o0 + 0x100]
+  retl
+  # return UNW_ESUCCESS
+   clr %o0
+
+#elif defined(__sparc__)
+
+#
+# extern int __unw_getcontext(unw_context_t* thread_state)
+#
+# On entry:
+#  thread_state pointer is in o0
+#
+DEFINE_LIBUNWIND_FUNCTION(__unw_getcontext)
+  ta 3
+  add %o7, 8, %o7
+  std %g0, [%o0 +   0]
+  std %g2, [%o0 +   8]
+  std %g4, [%o0 +  16]
+  std %g6, [%o0 +  24]
+  std %o0, [%o0 +  32]
+  std %o2, [%o0 +  40]
+  std %o4, [%o0 +  48]
+  std %o6, [%o0 +  56]
+  std %l0, [%o0 +  64]
+  std %l2, [%o0 +  72]
+  std %l4, [%o0 +  80]
+  std %l6, [%o0 +  88]
+  std %i0, [%o0 +  96]
+  std %i2, [%o0 + 104]
+  std %i4, [%o0 + 112]
+  std %i6, [%o0 + 120]
+  jmp %o7
+   clr %o0                   // return UNW_ESUCCESS
+
+#elif defined(__riscv)
+
+#
+# extern int __unw_getcontext(unw_context_t* thread_state)
+#
+# On entry:
+#  thread_state pointer is in a0
+#
+DEFINE_LIBUNWIND_FUNCTION(__unw_getcontext)
+  ISTORE    x1, (RISCV_ISIZE * 0)(a0) // store ra as pc
+  ISTORE    x1, (RISCV_ISIZE * 1)(a0)
+  ISTORE    x2, (RISCV_ISIZE * 2)(a0)
+  ISTORE    x3, (RISCV_ISIZE * 3)(a0)
+  ISTORE    x4, (RISCV_ISIZE * 4)(a0)
+  ISTORE    x5, (RISCV_ISIZE * 5)(a0)
+  ISTORE    x6, (RISCV_ISIZE * 6)(a0)
+  ISTORE    x7, (RISCV_ISIZE * 7)(a0)
+  ISTORE    x8, (RISCV_ISIZE * 8)(a0)
+  ISTORE    x9, (RISCV_ISIZE * 9)(a0)
+  ISTORE    x10, (RISCV_ISIZE * 10)(a0)
+  ISTORE    x11, (RISCV_ISIZE * 11)(a0)
+  ISTORE    x12, (RISCV_ISIZE * 12)(a0)
+  ISTORE    x13, (RISCV_ISIZE * 13)(a0)
+  ISTORE    x14, (RISCV_ISIZE * 14)(a0)
+  ISTORE    x15, (RISCV_ISIZE * 15)(a0)
+  ISTORE    x16, (RISCV_ISIZE * 16)(a0)
+  ISTORE    x17, (RISCV_ISIZE * 17)(a0)
+  ISTORE    x18, (RISCV_ISIZE * 18)(a0)
+  ISTORE    x19, (RISCV_ISIZE * 19)(a0)
+  ISTORE    x20, (RISCV_ISIZE * 20)(a0)
+  ISTORE    x21, (RISCV_ISIZE * 21)(a0)
+  ISTORE    x22, (RISCV_ISIZE * 22)(a0)
+  ISTORE    x23, (RISCV_ISIZE * 23)(a0)
+  ISTORE    x24, (RISCV_ISIZE * 24)(a0)
+  ISTORE    x25, (RISCV_ISIZE * 25)(a0)
+  ISTORE    x26, (RISCV_ISIZE * 26)(a0)
+  ISTORE    x27, (RISCV_ISIZE * 27)(a0)
+  ISTORE    x28, (RISCV_ISIZE * 28)(a0)
+  ISTORE    x29, (RISCV_ISIZE * 29)(a0)
+  ISTORE    x30, (RISCV_ISIZE * 30)(a0)
+  ISTORE    x31, (RISCV_ISIZE * 31)(a0)
+
+# if defined(__riscv_flen)
+  FSTORE    f0, (RISCV_FOFFSET + RISCV_FSIZE * 0)(a0)
+  FSTORE    f1, (RISCV_FOFFSET + RISCV_FSIZE * 1)(a0)
+  FSTORE    f2, (RISCV_FOFFSET + RISCV_FSIZE * 2)(a0)
+  FSTORE    f3, (RISCV_FOFFSET + RISCV_FSIZE * 3)(a0)
+  FSTORE    f4, (RISCV_FOFFSET + RISCV_FSIZE * 4)(a0)
+  FSTORE    f5, (RISCV_FOFFSET + RISCV_FSIZE * 5)(a0)
+  FSTORE    f6, (RISCV_FOFFSET + RISCV_FSIZE * 6)(a0)
+  FSTORE    f7, (RISCV_FOFFSET + RISCV_FSIZE * 7)(a0)
+  FSTORE    f8, (RISCV_FOFFSET + RISCV_FSIZE * 8)(a0)
+  FSTORE    f9, (RISCV_FOFFSET + RISCV_FSIZE * 9)(a0)
+  FSTORE    f10, (RISCV_FOFFSET + RISCV_FSIZE * 10)(a0)
+  FSTORE    f11, (RISCV_FOFFSET + RISCV_FSIZE * 11)(a0)
+  FSTORE    f12, (RISCV_FOFFSET + RISCV_FSIZE * 12)(a0)
+  FSTORE    f13, (RISCV_FOFFSET + RISCV_FSIZE * 13)(a0)
+  FSTORE    f14, (RISCV_FOFFSET + RISCV_FSIZE * 14)(a0)
+  FSTORE    f15, (RISCV_FOFFSET + RISCV_FSIZE * 15)(a0)
+  FSTORE    f16, (RISCV_FOFFSET + RISCV_FSIZE * 16)(a0)
+  FSTORE    f17, (RISCV_FOFFSET + RISCV_FSIZE * 17)(a0)
+  FSTORE    f18, (RISCV_FOFFSET + RISCV_FSIZE * 18)(a0)
+  FSTORE    f19, (RISCV_FOFFSET + RISCV_FSIZE * 19)(a0)
+  FSTORE    f20, (RISCV_FOFFSET + RISCV_FSIZE * 20)(a0)
+  FSTORE    f21, (RISCV_FOFFSET + RISCV_FSIZE * 21)(a0)
+  FSTORE    f22, (RISCV_FOFFSET + RISCV_FSIZE * 22)(a0)
+  FSTORE    f23, (RISCV_FOFFSET + RISCV_FSIZE * 23)(a0)
+  FSTORE    f24, (RISCV_FOFFSET + RISCV_FSIZE * 24)(a0)
+  FSTORE    f25, (RISCV_FOFFSET + RISCV_FSIZE * 25)(a0)
+  FSTORE    f26, (RISCV_FOFFSET + RISCV_FSIZE * 26)(a0)
+  FSTORE    f27, (RISCV_FOFFSET + RISCV_FSIZE * 27)(a0)
+  FSTORE    f28, (RISCV_FOFFSET + RISCV_FSIZE * 28)(a0)
+  FSTORE    f29, (RISCV_FOFFSET + RISCV_FSIZE * 29)(a0)
+  FSTORE    f30, (RISCV_FOFFSET + RISCV_FSIZE * 30)(a0)
+  FSTORE    f31, (RISCV_FOFFSET + RISCV_FSIZE * 31)(a0)
+# endif
+
+  li     a0, 0  // return UNW_ESUCCESS
+  ret           // jump to ra
 #endif
 
+  WEAK_ALIAS(__unw_getcontext, unw_getcontext)
+
 #endif /* !defined(__USING_SJLJ_EXCEPTIONS__) */
 
 NO_EXEC_STACK_DIRECTIVE
-
diff --git a/WAVM/ThirdParty/libunwind/src/Unwind_AppleExtras.cpp b/WAVM/ThirdParty/libunwind/src/Unwind_AppleExtras.cpp
index 39f379c5..ffb49a89 100644
--- a/WAVM/ThirdParty/libunwind/src/Unwind_AppleExtras.cpp
+++ b/WAVM/ThirdParty/libunwind/src/Unwind_AppleExtras.cpp
@@ -1,43 +1,13 @@
-//===--------------------- Unwind_AppleExtras.cpp -------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
+//===----------------------------------------------------------------------===//
 //
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //
 //===----------------------------------------------------------------------===//
 
 #include "config.h"
-#include "AddressSpace.hpp"
-#include "DwarfParser.hpp"
-
-
-// private keymgr stuff
-#define KEYMGR_GCC3_DW2_OBJ_LIST 302
-extern "C" {
- extern void _keymgr_set_and_unlock_processwide_ptr(int key, void *ptr);
- extern void *_keymgr_get_and_lock_processwide_ptr(int key);
-}
-
-// undocumented libgcc "struct object"
-struct libgcc_object {
-  void          *start;
-  void          *unused1;
-  void          *unused2;
-  void          *fde;
-  unsigned long  encoding;
-  void          *fde_end;
-  libgcc_object *next;
-};
-
-// undocumented libgcc "struct km_object_info" referenced by
-// KEYMGR_GCC3_DW2_OBJ_LIST
-struct libgcc_object_info {
-  libgcc_object   *seen_objects;
-  libgcc_object   *unseen_objects;
-  unsigned         spare[2];
-};
 
 
 // static linker symbols to prevent wrong two level namespace for _Unwind symbols
@@ -57,7 +27,7 @@ struct libgcc_object_info {
           __attribute__((visibility("default"))) const char sym##_tmp42 = 0; \
        extern const char sym##_tmp43 __asm("$ld$hide$os4.3$_" #sym ); \
           __attribute__((visibility("default"))) const char sym##_tmp43 = 0;
-#elif defined(__arm64__)
+#elif defined(__aarch64__)
   #define NOT_HERE_BEFORE_10_6(sym)
   #define NEVER_HERE(sym)
 #else
@@ -141,44 +111,3 @@ NOT_HERE_BEFORE_5_0(_Unwind_SjLj_Resume_or_Rethrow)
 NOT_HERE_BEFORE_5_0(_Unwind_SjLj_Unregister)
 
 #endif // defined(_LIBUNWIND_BUILD_SJLJ_APIS)
-
-
-namespace libunwind {
-
-_LIBUNWIND_HIDDEN
-bool checkKeyMgrRegisteredFDEs(uintptr_t pc, void *&fde) {
-#if __MAC_OS_X_VERSION_MIN_REQUIRED
-  // lastly check for old style keymgr registration of dynamically generated
-  // FDEs acquire exclusive access to libgcc_object_info
-  libgcc_object_info *head = (libgcc_object_info *)
-                _keymgr_get_and_lock_processwide_ptr(KEYMGR_GCC3_DW2_OBJ_LIST);
-  if (head != NULL) {
-    // look at each FDE in keymgr
-    for (libgcc_object *ob = head->unseen_objects; ob != NULL; ob = ob->next) {
-      CFI_Parser<LocalAddressSpace>::FDE_Info fdeInfo;
-      CFI_Parser<LocalAddressSpace>::CIE_Info cieInfo;
-      const char *msg = CFI_Parser<LocalAddressSpace>::decodeFDE(
-                                      LocalAddressSpace::sThisAddressSpace,
-                                      (uintptr_t)ob->fde, &fdeInfo, &cieInfo);
-      if (msg == NULL) {
-        // Check if this FDE is for a function that includes the pc
-        if ((fdeInfo.pcStart <= pc) && (pc < fdeInfo.pcEnd)) {
-          fde = (void*)fdeInfo.pcStart;
-          _keymgr_set_and_unlock_processwide_ptr(KEYMGR_GCC3_DW2_OBJ_LIST,
-                                                 head);
-          return true;
-        }
-      }
-    }
-  }
-  // release libgcc_object_info
-  _keymgr_set_and_unlock_processwide_ptr(KEYMGR_GCC3_DW2_OBJ_LIST, head);
-#else
-  (void)pc;
-  (void)fde;
-#endif
-  return false;
-}
-
-}
-
diff --git a/WAVM/ThirdParty/libunwind/src/assembly.h b/WAVM/ThirdParty/libunwind/src/assembly.h
index 07b08f94..89293a55 100644
--- a/WAVM/ThirdParty/libunwind/src/assembly.h
+++ b/WAVM/ThirdParty/libunwind/src/assembly.h
@@ -1,9 +1,8 @@
 /* ===-- assembly.h - libUnwind assembler support macros -------------------===
  *
- *                     The LLVM Compiler Infrastructure
- *
- * This file is dual licensed under the MIT and the University of Illinois Open
- * Source Licenses. See LICENSE.TXT for details.
+ * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+ * See https://llvm.org/LICENSE.txt for license information.
+ * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
  *
  * ===----------------------------------------------------------------------===
  *
@@ -16,6 +15,13 @@
 #ifndef UNWIND_ASSEMBLY_H
 #define UNWIND_ASSEMBLY_H
 
+#if defined(__linux__) && defined(__CET__)
+#include <cet.h>
+#define _LIBUNWIND_CET_ENDBR _CET_ENDBR
+#else
+#define _LIBUNWIND_CET_ENDBR
+#endif
+
 #if defined(__powerpc64__)
 #define SEPARATOR ;
 #define PPC64_OFFS_SRR0   0
@@ -26,17 +32,84 @@
 #define PPC64_OFFS_VRSAVE 304
 #define PPC64_OFFS_FP     312
 #define PPC64_OFFS_V      824
-#ifdef _ARCH_PWR8
-#define PPC64_HAS_VMX
-#endif
-#elif defined(__POWERPC__) || defined(__powerpc__) || defined(__ppc__)
-#define SEPARATOR @
-#elif defined(__arm64__)
+#elif defined(__APPLE__) && defined(__aarch64__)
 #define SEPARATOR %%
+#elif defined(__riscv)
+# define RISCV_ISIZE (__riscv_xlen / 8)
+# define RISCV_FOFFSET (RISCV_ISIZE * 32)
+# if defined(__riscv_flen)
+#  define RISCV_FSIZE (__riscv_flen / 8)
+# endif
+
+# if __riscv_xlen == 64
+#  define ILOAD ld
+#  define ISTORE sd
+# elif __riscv_xlen == 32
+#  define ILOAD lw
+#  define ISTORE sw
+# else
+#  error "Unsupported __riscv_xlen"
+# endif
+
+# if defined(__riscv_flen)
+#  if __riscv_flen == 64
+#   define FLOAD fld
+#   define FSTORE fsd
+#  elif __riscv_flen == 32
+#   define FLOAD flw
+#   define FSTORE fsw
+#  else
+#   error "Unsupported __riscv_flen"
+#  endif
+# endif
+# define SEPARATOR ;
 #else
 #define SEPARATOR ;
 #endif
 
+#if defined(__powerpc64__) && (!defined(_CALL_ELF) || _CALL_ELF == 1)
+#define PPC64_OPD1 .section .opd,"aw",@progbits SEPARATOR
+#define PPC64_OPD2 SEPARATOR \
+  .p2align 3 SEPARATOR \
+  .quad .Lfunc_begin0 SEPARATOR \
+  .quad .TOC.@tocbase SEPARATOR \
+  .quad 0 SEPARATOR \
+  .text SEPARATOR \
+.Lfunc_begin0:
+#else
+#define PPC64_OPD1
+#define PPC64_OPD2
+#endif
+
+#if defined(__aarch64__) && defined(__ARM_FEATURE_BTI_DEFAULT)
+  .pushsection ".note.gnu.property", "a" SEPARATOR                             \
+  .balign 8 SEPARATOR                                                          \
+  .long 4 SEPARATOR                                                            \
+  .long 0x10 SEPARATOR                                                         \
+  .long 0x5 SEPARATOR                                                          \
+  .asciz "GNU" SEPARATOR                                                       \
+  .long 0xc0000000 SEPARATOR /* GNU_PROPERTY_AARCH64_FEATURE_1_AND */          \
+  .long 4 SEPARATOR                                                            \
+  .long 3 SEPARATOR /* GNU_PROPERTY_AARCH64_FEATURE_1_BTI AND */               \
+                    /* GNU_PROPERTY_AARCH64_FEATURE_1_PAC */                   \
+  .long 0 SEPARATOR                                                            \
+  .popsection SEPARATOR
+#define AARCH64_BTI  bti c
+#else
+#define AARCH64_BTI
+#endif
+
+#if !defined(__aarch64__)
+#ifdef __ARM_FEATURE_PAC_DEFAULT
+  .eabi_attribute Tag_PAC_extension, 2
+  .eabi_attribute Tag_PACRET_use, 1
+#endif
+#ifdef __ARM_FEATURE_BTI_DEFAULT
+  .eabi_attribute Tag_BTI_extension, 1
+  .eabi_attribute Tag_BTI_use, 1
+#endif
+#endif
+
 #define GLUE2(a, b) a ## b
 #define GLUE(a, b) GLUE2(a, b)
 #define SYMBOL_NAME(name) GLUE(__USER_LABEL_PREFIX__, name)
@@ -45,6 +118,16 @@
 
 #define SYMBOL_IS_FUNC(name)
 #define HIDDEN_SYMBOL(name) .private_extern name
+#if defined(_LIBUNWIND_HIDE_SYMBOLS)
+#define EXPORT_SYMBOL(name) HIDDEN_SYMBOL(name)
+#else
+#define EXPORT_SYMBOL(name)
+#endif
+#define WEAK_ALIAS(name, aliasname)                                            \
+  .globl SYMBOL_NAME(aliasname) SEPARATOR                                      \
+  EXPORT_SYMBOL(SYMBOL_NAME(aliasname)) SEPARATOR                              \
+  SYMBOL_NAME(aliasname) = SYMBOL_NAME(name)
+
 #define NO_EXEC_STACK_DIRECTIVE
 
 #elif defined(__ELF__)
@@ -55,6 +138,24 @@
 #define SYMBOL_IS_FUNC(name) .type name,@function
 #endif
 #define HIDDEN_SYMBOL(name) .hidden name
+#if defined(_LIBUNWIND_HIDE_SYMBOLS)
+#define EXPORT_SYMBOL(name) HIDDEN_SYMBOL(name)
+#else
+#define EXPORT_SYMBOL(name)
+#endif
+#define WEAK_SYMBOL(name) .weak name
+
+#if defined(__hexagon__)
+#define WEAK_ALIAS(name, aliasname)                                            \
+  EXPORT_SYMBOL(SYMBOL_NAME(aliasname)) SEPARATOR                              \
+  WEAK_SYMBOL(SYMBOL_NAME(aliasname)) SEPARATOR                                \
+  .equiv SYMBOL_NAME(aliasname), SYMBOL_NAME(name)
+#else
+#define WEAK_ALIAS(name, aliasname)                                            \
+  EXPORT_SYMBOL(SYMBOL_NAME(aliasname)) SEPARATOR                              \
+  WEAK_SYMBOL(SYMBOL_NAME(aliasname)) SEPARATOR                                \
+  SYMBOL_NAME(aliasname) = SYMBOL_NAME(name)
+#endif
 
 #if defined(__GNU__) || defined(__FreeBSD__) || defined(__Fuchsia__) || \
     defined(__linux__)
@@ -70,26 +171,52 @@
     .scl 2 SEPARATOR                                                           \
     .type 32 SEPARATOR                                                         \
   .endef
+#define EXPORT_SYMBOL2(name)                                                   \
+  .section .drectve,"yn" SEPARATOR                                             \
+  .ascii "-export:", #name, "\0" SEPARATOR                                     \
+  .text
+#if defined(_LIBUNWIND_HIDE_SYMBOLS)
+#define EXPORT_SYMBOL(name)
+#else
+#define EXPORT_SYMBOL(name) EXPORT_SYMBOL2(name)
+#endif
 #define HIDDEN_SYMBOL(name)
 
+#if defined(__MINGW32__)
+#define WEAK_ALIAS(name, aliasname)                                            \
+  .globl SYMBOL_NAME(aliasname) SEPARATOR                                      \
+  EXPORT_SYMBOL(aliasname) SEPARATOR                                           \
+  SYMBOL_NAME(aliasname) = SYMBOL_NAME(name)
+#else
+#define WEAK_ALIAS3(name, aliasname)                                           \
+  .section .drectve,"yn" SEPARATOR                                             \
+  .ascii "-alternatename:", #aliasname, "=", #name, "\0" SEPARATOR             \
+  .text
+#define WEAK_ALIAS2(name, aliasname)                                           \
+  WEAK_ALIAS3(name, aliasname)
+#define WEAK_ALIAS(name, aliasname)                                            \
+  EXPORT_SYMBOL(SYMBOL_NAME(aliasname)) SEPARATOR                              \
+  WEAK_ALIAS2(SYMBOL_NAME(name), SYMBOL_NAME(aliasname))
+#endif
+
 #define NO_EXEC_STACK_DIRECTIVE
 
+#elif defined(__sparc__)
+
 #else
 
 #error Unsupported target
 
 #endif
 
-#define DEFINE_LIBUNWIND_FUNCTION(name)                   \
-  .globl SYMBOL_NAME(name) SEPARATOR                      \
-  SYMBOL_IS_FUNC(SYMBOL_NAME(name)) SEPARATOR             \
-  SYMBOL_NAME(name):
-
-#define DEFINE_LIBUNWIND_PRIVATE_FUNCTION(name)           \
-  .globl SYMBOL_NAME(name) SEPARATOR                      \
-  HIDDEN_SYMBOL(SYMBOL_NAME(name)) SEPARATOR              \
-  SYMBOL_IS_FUNC(SYMBOL_NAME(name)) SEPARATOR             \
-  SYMBOL_NAME(name):
+#define DEFINE_LIBUNWIND_FUNCTION(name)                                        \
+  .globl SYMBOL_NAME(name) SEPARATOR                                           \
+  HIDDEN_SYMBOL(SYMBOL_NAME(name)) SEPARATOR                                   \
+  SYMBOL_IS_FUNC(SYMBOL_NAME(name)) SEPARATOR                                  \
+  PPC64_OPD1                                                                   \
+  SYMBOL_NAME(name):                                                           \
+  PPC64_OPD2                                                                   \
+  AARCH64_BTI
 
 #if defined(__arm__)
 #if !defined(__ARM_ARCH)
@@ -107,4 +234,8 @@
 #endif
 #endif /* __arm__ */
 
+#if defined(__powerpc__)
+#define PPC_LEFT_SHIFT(index) << (index)
+#endif
+
 #endif /* UNWIND_ASSEMBLY_H */
diff --git a/WAVM/ThirdParty/libunwind/src/cet_unwind.h b/WAVM/ThirdParty/libunwind/src/cet_unwind.h
new file mode 100644
index 00000000..e371be20
--- /dev/null
+++ b/WAVM/ThirdParty/libunwind/src/cet_unwind.h
@@ -0,0 +1,41 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LIBUNWIND_CET_UNWIND_H
+#define LIBUNWIND_CET_UNWIND_H
+
+#include "libunwind.h"
+
+// Currently, CET is implemented on Linux x86 platforms.
+#if defined(_LIBUNWIND_TARGET_LINUX) && defined(__CET__) && defined(__SHSTK__)
+#define _LIBUNWIND_USE_CET 1
+#endif
+
+#if defined(_LIBUNWIND_USE_CET)
+#include <cet.h>
+#include <immintrin.h>
+
+#define _LIBUNWIND_POP_CET_SSP(x)                                              \
+  do {                                                                         \
+    unsigned long ssp = _get_ssp();                                            \
+    if (ssp != 0) {                                                            \
+      unsigned int tmp = (x);                                                  \
+      while (tmp > 255) {                                                      \
+        _inc_ssp(255);                                                         \
+        tmp -= 255;                                                            \
+      }                                                                        \
+      _inc_ssp(tmp);                                                           \
+    }                                                                          \
+  } while (0)
+#endif
+
+extern void *__libunwind_cet_get_registers(unw_cursor_t *);
+extern void *__libunwind_cet_get_jump_target();
+
+#endif
diff --git a/WAVM/ThirdParty/libunwind/src/config.h b/WAVM/ThirdParty/libunwind/src/config.h
index 1a7a3066..5ae1604f 100644
--- a/WAVM/ThirdParty/libunwind/src/config.h
+++ b/WAVM/ThirdParty/libunwind/src/config.h
@@ -1,9 +1,8 @@
-//===----------------------------- config.h -------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
+//===----------------------------------------------------------------------===//
 //
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //
 //  Defines macros used within libunwind project.
@@ -19,34 +18,42 @@
 #include <stdint.h>
 #include <stdlib.h>
 
-// Define static_assert() unless already defined by compiler.
-#ifndef __has_feature
-  #define __has_feature(__x) 0
-#endif
-#if !(__has_feature(cxx_static_assert)) && !defined(static_assert)
-  #define static_assert(__b, __m) \
-      extern int compile_time_assert_failed[ ( __b ) ? 1 : -1 ]  \
-                                                  __attribute__( ( unused ) );
-#endif
+#include <__libunwind_config.h>
 
 // Platform specific configuration defines.
 #ifdef __APPLE__
   #if defined(FOR_DYLD)
-    #define _LIBUNWIND_SUPPORT_COMPACT_UNWIND
+    #define _LIBUNWIND_SUPPORT_COMPACT_UNWIND 1
   #else
-    #define _LIBUNWIND_SUPPORT_COMPACT_UNWIND
-    #define _LIBUNWIND_SUPPORT_DWARF_UNWIND   1
+    #define _LIBUNWIND_SUPPORT_COMPACT_UNWIND 1
+    #define _LIBUNWIND_SUPPORT_DWARF_UNWIND 1
   #endif
 #elif defined(_WIN32)
-  #define _LIBUNWIND_SUPPORT_DWARF_UNWIND 1
+  #ifdef __SEH__
+    #define _LIBUNWIND_SUPPORT_SEH_UNWIND 1
+  #else
+    #define _LIBUNWIND_SUPPORT_DWARF_UNWIND 1
+  #endif
+#elif defined(_LIBUNWIND_IS_BAREMETAL)
+  #if !defined(_LIBUNWIND_ARM_EHABI)
+    #define _LIBUNWIND_SUPPORT_DWARF_UNWIND 1
+    #define _LIBUNWIND_SUPPORT_DWARF_INDEX 1
+  #endif
+#elif defined(__BIONIC__) && defined(_LIBUNWIND_ARM_EHABI)
+  // For ARM EHABI, Bionic didn't implement dl_iterate_phdr until API 21. After
+  // API 21, dl_iterate_phdr exists, but dl_unwind_find_exidx is much faster.
+  #define _LIBUNWIND_USE_DL_UNWIND_FIND_EXIDX 1
 #else
-  #if defined(__ARM_DWARF_EH__) || !defined(__arm__)
+  // Assume an ELF system with a dl_iterate_phdr function.
+  #define _LIBUNWIND_USE_DL_ITERATE_PHDR 1
+  #if !defined(_LIBUNWIND_ARM_EHABI)
     #define _LIBUNWIND_SUPPORT_DWARF_UNWIND 1
     #define _LIBUNWIND_SUPPORT_DWARF_INDEX 1
   #endif
 #endif
 
-#if defined(_LIBUNWIND_DISABLE_VISIBILITY_ANNOTATIONS)
+#if defined(_LIBUNWIND_HIDE_SYMBOLS)
+  // The CMake file passes -fvisibility=hidden to control ELF/Mach-O visibility.
   #define _LIBUNWIND_EXPORT
   #define _LIBUNWIND_HIDDEN
 #else
@@ -59,26 +66,79 @@
   #endif
 #endif
 
+#define STR(a) #a
+#define XSTR(a) STR(a)
+#define SYMBOL_NAME(name) XSTR(__USER_LABEL_PREFIX__) #name
+
+#if defined(__APPLE__)
+#if defined(_LIBUNWIND_HIDE_SYMBOLS)
+#define _LIBUNWIND_ALIAS_VISIBILITY(name) __asm__(".private_extern " name);
+#else
+#define _LIBUNWIND_ALIAS_VISIBILITY(name)
+#endif
+#define _LIBUNWIND_WEAK_ALIAS(name, aliasname)                                 \
+  __asm__(".globl " SYMBOL_NAME(aliasname));                                   \
+  __asm__(SYMBOL_NAME(aliasname) " = " SYMBOL_NAME(name));                     \
+  _LIBUNWIND_ALIAS_VISIBILITY(SYMBOL_NAME(aliasname))
+#elif defined(__ELF__)
+#define _LIBUNWIND_WEAK_ALIAS(name, aliasname)                                 \
+  extern "C" _LIBUNWIND_EXPORT __typeof(name) aliasname                        \
+      __attribute__((weak, alias(#name)));
+#elif defined(_WIN32)
+#if defined(__MINGW32__)
+#define _LIBUNWIND_WEAK_ALIAS(name, aliasname)                                 \
+  extern "C" _LIBUNWIND_EXPORT __typeof(name) aliasname                        \
+      __attribute__((alias(#name)));
+#else
+#define _LIBUNWIND_WEAK_ALIAS(name, aliasname)                                 \
+  __pragma(comment(linker, "/alternatename:" SYMBOL_NAME(aliasname) "="        \
+                                             SYMBOL_NAME(name)))               \
+  extern "C" _LIBUNWIND_EXPORT __typeof(name) aliasname;
+#endif
+#else
+#error Unsupported target
+#endif
+
+// Apple/armv7k defaults to DWARF/Compact unwinding, but its libunwind also
+// needs to include the SJLJ APIs.
 #if (defined(__APPLE__) && defined(__arm__)) || defined(__USING_SJLJ_EXCEPTIONS__)
 #define _LIBUNWIND_BUILD_SJLJ_APIS
 #endif
 
-#if defined(__i386__) || defined(__x86_64__) || defined(__ppc__) || defined(__ppc64__) || defined(__powerpc64__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__powerpc__)
 #define _LIBUNWIND_SUPPORT_FRAME_APIS
 #endif
 
-#if defined(__i386__) || defined(__x86_64__) ||                                \
-    defined(__ppc__) || defined(__ppc64__) || defined(__powerpc64__) ||        \
-    (!defined(__APPLE__) && defined(__arm__)) ||                               \
-    (defined(__arm64__) || defined(__aarch64__)) ||                            \
-    defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__powerpc__) ||        \
+    (!defined(__APPLE__) && defined(__arm__)) || defined(__aarch64__) ||       \
+    defined(__mips__) || defined(__riscv) || defined(__hexagon__) ||           \
+    defined(__sparc__)
 #if !defined(_LIBUNWIND_BUILD_SJLJ_APIS)
 #define _LIBUNWIND_BUILD_ZERO_COST_APIS
 #endif
 #endif
 
-#if defined(__powerpc64__) && defined(_ARCH_PWR8)
-#define PPC64_HAS_VMX
+#ifndef _LIBUNWIND_REMEMBER_HEAP_ALLOC
+#if defined(_LIBUNWIND_REMEMBER_STACK_ALLOC) || defined(__APPLE__) ||          \
+    defined(__linux__) || defined(__ANDROID__) || defined(__MINGW32__) ||      \
+    defined(_LIBUNWIND_IS_BAREMETAL)
+#define _LIBUNWIND_REMEMBER_ALLOC(_size) alloca(_size)
+#define _LIBUNWIND_REMEMBER_FREE(_ptr)                                         \
+  do {                                                                         \
+  } while (0)
+#elif defined(_WIN32)
+#define _LIBUNWIND_REMEMBER_ALLOC(_size) _malloca(_size)
+#define _LIBUNWIND_REMEMBER_FREE(_ptr) _freea(_ptr)
+#define _LIBUNWIND_REMEMBER_CLEANUP_NEEDED
+#else
+#define _LIBUNWIND_REMEMBER_ALLOC(_size) malloc(_size)
+#define _LIBUNWIND_REMEMBER_FREE(_ptr) free(_ptr)
+#define _LIBUNWIND_REMEMBER_CLEANUP_NEEDED
+#endif
+#else /* _LIBUNWIND_REMEMBER_HEAP_ALLOC */
+#define _LIBUNWIND_REMEMBER_ALLOC(_size) malloc(_size)
+#define _LIBUNWIND_REMEMBER_FREE(_ptr) free(_ptr)
+#define _LIBUNWIND_REMEMBER_CLEANUP_NEEDED
 #endif
 
 #if defined(NDEBUG) && defined(_LIBUNWIND_IS_BAREMETAL)
@@ -89,8 +149,7 @@
 #else
 #define _LIBUNWIND_ABORT(msg)                                                  \
   do {                                                                         \
-    fprintf(stderr, "libunwind: %s %s:%d - %s\n", __func__, __FILE__,          \
-            __LINE__, msg);                                                    \
+    fprintf(stderr, "libunwind: %s - %s\n", __func__, msg);                    \
     fflush(stderr);                                                            \
     abort();                                                                   \
   } while (0)
diff --git a/WAVM/ThirdParty/libunwind/src/dwarf2.h b/WAVM/ThirdParty/libunwind/src/dwarf2.h
index 0dcd2ca9..174277d5 100644
--- a/WAVM/ThirdParty/libunwind/src/dwarf2.h
+++ b/WAVM/ThirdParty/libunwind/src/dwarf2.h
@@ -1,9 +1,8 @@
-//===------------------------------- dwarf2.h -----------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
+//===----------------------------------------------------------------------===//
 //
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
@@ -49,7 +48,10 @@ enum {
   // GNU extensions
   DW_CFA_GNU_window_save              = 0x2D,
   DW_CFA_GNU_args_size                = 0x2E,
-  DW_CFA_GNU_negative_offset_extended = 0x2F
+  DW_CFA_GNU_negative_offset_extended = 0x2F,
+
+  // AARCH64 extensions
+  DW_CFA_AARCH64_negate_ra_state      = 0x2D
 };
 
 
diff --git a/WAVM/ThirdParty/libunwind/src/libunwind.cpp b/WAVM/ThirdParty/libunwind/src/libunwind.cpp
index c76efb07..03f8b75b 100644
--- a/WAVM/ThirdParty/libunwind/src/libunwind.cpp
+++ b/WAVM/ThirdParty/libunwind/src/libunwind.cpp
@@ -1,9 +1,8 @@
-//===--------------------------- libunwind.cpp ----------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
+//===----------------------------------------------------------------------===//
 //
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //
 //  Implements unw_* functions from <libunwind.h>
@@ -12,17 +11,20 @@
 
 #include <libunwind.h>
 
-#ifndef NDEBUG
-#include <cstdlib> // getenv
-#endif
-#include <new>
-#include <algorithm>
-
-#include "libunwind_ext.h"
 #include "config.h"
+#include "libunwind_ext.h"
 
 #include <stdlib.h>
 
+// Define the __has_feature extension for compilers that do not support it so
+// that we can later check for the presence of ASan in a compiler-neutral way.
+#if !defined(__has_feature)
+#define __has_feature(feature) 0
+#endif
+
+#if __has_feature(address_sanitizer) || defined(__SANITIZE_ADDRESS__)
+#include <sanitizer/asan_interface.h>
+#endif
 
 #if !defined(__USING_SJLJ_EXCEPTIONS__)
 #include "AddressSpace.hpp"
@@ -36,15 +38,11 @@ LocalAddressSpace LocalAddressSpace::sThisAddressSpace;
 _LIBUNWIND_EXPORT unw_addr_space_t unw_local_addr_space =
     (unw_addr_space_t)&LocalAddressSpace::sThisAddressSpace;
 
-/// record the registers and stack position of the caller
-extern int unw_getcontext(unw_context_t *);
-// note: unw_getcontext() implemented in assembly
-
 /// Create a cursor of a thread in this process given 'context' recorded by
-/// unw_getcontext().
-_LIBUNWIND_EXPORT int unw_init_local(unw_cursor_t *cursor,
-                                     unw_context_t *context) {
-  _LIBUNWIND_TRACE_API("unw_init_local(cursor=%p, context=%p)",
+/// __unw_getcontext().
+_LIBUNWIND_HIDDEN int __unw_init_local(unw_cursor_t *cursor,
+                                       unw_context_t *context) {
+  _LIBUNWIND_TRACE_API("__unw_init_local(cursor=%p, context=%p)",
                        static_cast<void *>(cursor),
                        static_cast<void *>(context));
 #if defined(__i386__)
@@ -53,7 +51,7 @@ _LIBUNWIND_EXPORT int unw_init_local(unw_cursor_t *cursor,
 # define REGISTER_KIND Registers_x86_64
 #elif defined(__powerpc64__)
 # define REGISTER_KIND Registers_ppc64
-#elif defined(__ppc__)
+#elif defined(__powerpc__)
 # define REGISTER_KIND Registers_ppc
 #elif defined(__aarch64__)
 # define REGISTER_KIND Registers_arm64
@@ -61,112 +59,41 @@ _LIBUNWIND_EXPORT int unw_init_local(unw_cursor_t *cursor,
 # define REGISTER_KIND Registers_arm
 #elif defined(__or1k__)
 # define REGISTER_KIND Registers_or1k
-#elif defined(__mips__) && defined(_ABIO32) && _MIPS_SIM == _ABIO32 &&         \
-    defined(__mips_soft_float)
+#elif defined(__hexagon__)
+# define REGISTER_KIND Registers_hexagon
+#elif defined(__mips__) && defined(_ABIO32) && _MIPS_SIM == _ABIO32
 # define REGISTER_KIND Registers_mips_o32
-#elif defined(__mips64) && defined(__mips_soft_float)
+#elif defined(__mips64)
 # define REGISTER_KIND Registers_mips_newabi
 #elif defined(__mips__)
 # warning The MIPS architecture is not supported with this ABI and environment!
+#elif defined(__sparc__) && defined(__arch64__)
+#define REGISTER_KIND Registers_sparc64
+#elif defined(__sparc__)
+# define REGISTER_KIND Registers_sparc
+#elif defined(__riscv)
+# define REGISTER_KIND Registers_riscv
+#elif defined(__ve__)
+# define REGISTER_KIND Registers_ve
 #else
 # error Architecture not supported
 #endif
   // Use "placement new" to allocate UnwindCursor in the cursor buffer.
-  new ((void *)cursor) UnwindCursor<LocalAddressSpace, REGISTER_KIND>(
-                                 context, LocalAddressSpace::sThisAddressSpace);
+  new (reinterpret_cast<UnwindCursor<LocalAddressSpace, REGISTER_KIND> *>(cursor))
+      UnwindCursor<LocalAddressSpace, REGISTER_KIND>(
+          context, LocalAddressSpace::sThisAddressSpace);
 #undef REGISTER_KIND
   AbstractUnwindCursor *co = (AbstractUnwindCursor *)cursor;
   co->setInfoBasedOnIPRegister();
 
   return UNW_ESUCCESS;
 }
-
-#ifdef UNW_REMOTE
-/// Create a cursor into a thread in another process.
-_LIBUNWIND_EXPORT int unw_init_remote_thread(unw_cursor_t *cursor,
-                                             unw_addr_space_t as,
-                                             void *arg) {
-  // special case: unw_init_remote(xx, unw_local_addr_space, xx)
-  if (as == (unw_addr_space_t)&LocalAddressSpace::sThisAddressSpace)
-    return unw_init_local(cursor, NULL); //FIXME
-
-  // use "placement new" to allocate UnwindCursor in the cursor buffer
-  switch (as->cpuType) {
-  case CPU_TYPE_I386:
-    new ((void *)cursor)
-        UnwindCursor<RemoteAddressSpace<Pointer32<LittleEndian>>,
-                     Registers_x86>(((unw_addr_space_i386 *)as)->oas, arg);
-    break;
-  case CPU_TYPE_X86_64:
-    new ((void *)cursor)
-        UnwindCursor<RemoteAddressSpace<Pointer64<LittleEndian>>,
-                     Registers_x86_64>(((unw_addr_space_x86_64 *)as)->oas, arg);
-    break;
-  case CPU_TYPE_POWERPC:
-    new ((void *)cursor)
-        UnwindCursor<RemoteAddressSpace<Pointer32<BigEndian>>,
-                     Registers_ppc>(((unw_addr_space_ppc *)as)->oas, arg);
-    break;
-  default:
-    return UNW_EUNSPEC;
-  }
-  return UNW_ESUCCESS;
-}
-
-
-static bool is64bit(task_t task) {
-  return false; // FIXME
-}
-
-/// Create an address_space object for use in examining another task.
-_LIBUNWIND_EXPORT unw_addr_space_t unw_create_addr_space_for_task(task_t task) {
-#if __i386__
-  if (is64bit(task)) {
-    unw_addr_space_x86_64 *as = new unw_addr_space_x86_64(task);
-    as->taskPort = task;
-    as->cpuType = CPU_TYPE_X86_64;
-    //as->oas
-  } else {
-    unw_addr_space_i386 *as = new unw_addr_space_i386(task);
-    as->taskPort = task;
-    as->cpuType = CPU_TYPE_I386;
-    //as->oas
-  }
-#else
-// FIXME
-#endif
-}
-
-
-/// Delete an address_space object.
-_LIBUNWIND_EXPORT void unw_destroy_addr_space(unw_addr_space_t asp) {
-  switch (asp->cpuType) {
-#if __i386__ || __x86_64__
-  case CPU_TYPE_I386: {
-    unw_addr_space_i386 *as = (unw_addr_space_i386 *)asp;
-    delete as;
-  }
-  break;
-  case CPU_TYPE_X86_64: {
-    unw_addr_space_x86_64 *as = (unw_addr_space_x86_64 *)asp;
-    delete as;
-  }
-  break;
-#endif
-  case CPU_TYPE_POWERPC: {
-    unw_addr_space_ppc *as = (unw_addr_space_ppc *)asp;
-    delete as;
-  }
-  break;
-  }
-}
-#endif // UNW_REMOTE
-
+_LIBUNWIND_WEAK_ALIAS(__unw_init_local, unw_init_local)
 
 /// Get value of specified register at cursor position in stack frame.
-_LIBUNWIND_EXPORT int unw_get_reg(unw_cursor_t *cursor, unw_regnum_t regNum,
-                                  unw_word_t *value) {
-  _LIBUNWIND_TRACE_API("unw_get_reg(cursor=%p, regNum=%d, &value=%p)",
+_LIBUNWIND_HIDDEN int __unw_get_reg(unw_cursor_t *cursor, unw_regnum_t regNum,
+                                    unw_word_t *value) {
+  _LIBUNWIND_TRACE_API("__unw_get_reg(cursor=%p, regNum=%d, &value=%p)",
                        static_cast<void *>(cursor), regNum,
                        static_cast<void *>(value));
   AbstractUnwindCursor *co = (AbstractUnwindCursor *)cursor;
@@ -176,12 +103,13 @@ _LIBUNWIND_EXPORT int unw_get_reg(unw_cursor_t *cursor, unw_regnum_t regNum,
   }
   return UNW_EBADREG;
 }
-
+_LIBUNWIND_WEAK_ALIAS(__unw_get_reg, unw_get_reg)
 
 /// Set value of specified register at cursor position in stack frame.
-_LIBUNWIND_EXPORT int unw_set_reg(unw_cursor_t *cursor, unw_regnum_t regNum,
-                                  unw_word_t value) {
-  _LIBUNWIND_TRACE_API("unw_set_reg(cursor=%p, regNum=%d, value=0x%" PRIxPTR ")",
+_LIBUNWIND_HIDDEN int __unw_set_reg(unw_cursor_t *cursor, unw_regnum_t regNum,
+                                    unw_word_t value) {
+  _LIBUNWIND_TRACE_API("__unw_set_reg(cursor=%p, regNum=%d, value=0x%" PRIxPTR
+                       ")",
                        static_cast<void *>(cursor), regNum, value);
   typedef LocalAddressSpace::pint_t pint_t;
   AbstractUnwindCursor *co = (AbstractUnwindCursor *)cursor;
@@ -189,18 +117,30 @@ _LIBUNWIND_EXPORT int unw_set_reg(unw_cursor_t *cursor, unw_regnum_t regNum,
     co->setReg(regNum, (pint_t)value);
     // specical case altering IP to re-find info (being called by personality
     // function)
-    if (regNum == UNW_REG_IP)
+    if (regNum == UNW_REG_IP) {
+      unw_proc_info_t info;
+      // First, get the FDE for the old location and then update it.
+      co->getInfo(&info);
       co->setInfoBasedOnIPRegister(false);
+      // If the original call expects stack adjustment, perform this now.
+      // Normal frame unwinding would have included the offset already in the
+      // CFA computation.
+      // Note: for PA-RISC and other platforms where the stack grows up,
+      // this should actually be - info.gp. LLVM doesn't currently support
+      // any such platforms and Clang doesn't export a macro for them.
+      if (info.gp)
+        co->setReg(UNW_REG_SP, co->getReg(UNW_REG_SP) + info.gp);
+    }
     return UNW_ESUCCESS;
   }
   return UNW_EBADREG;
 }
-
+_LIBUNWIND_WEAK_ALIAS(__unw_set_reg, unw_set_reg)
 
 /// Get value of specified float register at cursor position in stack frame.
-_LIBUNWIND_EXPORT int unw_get_fpreg(unw_cursor_t *cursor, unw_regnum_t regNum,
-                                    unw_fpreg_t *value) {
-  _LIBUNWIND_TRACE_API("unw_get_fpreg(cursor=%p, regNum=%d, &value=%p)",
+_LIBUNWIND_HIDDEN int __unw_get_fpreg(unw_cursor_t *cursor, unw_regnum_t regNum,
+                                      unw_fpreg_t *value) {
+  _LIBUNWIND_TRACE_API("__unw_get_fpreg(cursor=%p, regNum=%d, &value=%p)",
                        static_cast<void *>(cursor), regNum,
                        static_cast<void *>(value));
   AbstractUnwindCursor *co = (AbstractUnwindCursor *)cursor;
@@ -210,16 +150,16 @@ _LIBUNWIND_EXPORT int unw_get_fpreg(unw_cursor_t *cursor, unw_regnum_t regNum,
   }
   return UNW_EBADREG;
 }
-
+_LIBUNWIND_WEAK_ALIAS(__unw_get_fpreg, unw_get_fpreg)
 
 /// Set value of specified float register at cursor position in stack frame.
-_LIBUNWIND_EXPORT int unw_set_fpreg(unw_cursor_t *cursor, unw_regnum_t regNum,
-                                    unw_fpreg_t value) {
+_LIBUNWIND_HIDDEN int __unw_set_fpreg(unw_cursor_t *cursor, unw_regnum_t regNum,
+                                      unw_fpreg_t value) {
 #if defined(_LIBUNWIND_ARM_EHABI)
-  _LIBUNWIND_TRACE_API("unw_set_fpreg(cursor=%p, regNum=%d, value=%llX)",
+  _LIBUNWIND_TRACE_API("__unw_set_fpreg(cursor=%p, regNum=%d, value=%llX)",
                        static_cast<void *>(cursor), regNum, value);
 #else
-  _LIBUNWIND_TRACE_API("unw_set_fpreg(cursor=%p, regNum=%d, value=%g)",
+  _LIBUNWIND_TRACE_API("__unw_set_fpreg(cursor=%p, regNum=%d, value=%g)",
                        static_cast<void *>(cursor), regNum, value);
 #endif
   AbstractUnwindCursor *co = (AbstractUnwindCursor *)cursor;
@@ -229,103 +169,109 @@ _LIBUNWIND_EXPORT int unw_set_fpreg(unw_cursor_t *cursor, unw_regnum_t regNum,
   }
   return UNW_EBADREG;
 }
-
+_LIBUNWIND_WEAK_ALIAS(__unw_set_fpreg, unw_set_fpreg)
 
 /// Move cursor to next frame.
-_LIBUNWIND_EXPORT int unw_step(unw_cursor_t *cursor) {
-  _LIBUNWIND_TRACE_API("unw_step(cursor=%p)", static_cast<void *>(cursor));
+_LIBUNWIND_HIDDEN int __unw_step(unw_cursor_t *cursor) {
+  _LIBUNWIND_TRACE_API("__unw_step(cursor=%p)", static_cast<void *>(cursor));
   AbstractUnwindCursor *co = (AbstractUnwindCursor *)cursor;
   return co->step();
 }
-
+_LIBUNWIND_WEAK_ALIAS(__unw_step, unw_step)
 
 /// Get unwind info at cursor position in stack frame.
-_LIBUNWIND_EXPORT int unw_get_proc_info(unw_cursor_t *cursor,
-                                        unw_proc_info_t *info) {
-  _LIBUNWIND_TRACE_API("unw_get_proc_info(cursor=%p, &info=%p)",
+_LIBUNWIND_HIDDEN int __unw_get_proc_info(unw_cursor_t *cursor,
+                                          unw_proc_info_t *info) {
+  _LIBUNWIND_TRACE_API("__unw_get_proc_info(cursor=%p, &info=%p)",
                        static_cast<void *>(cursor), static_cast<void *>(info));
   AbstractUnwindCursor *co = (AbstractUnwindCursor *)cursor;
   co->getInfo(info);
   if (info->end_ip == 0)
     return UNW_ENOINFO;
-  else
-    return UNW_ESUCCESS;
+  return UNW_ESUCCESS;
 }
-
+_LIBUNWIND_WEAK_ALIAS(__unw_get_proc_info, unw_get_proc_info)
 
 /// Resume execution at cursor position (aka longjump).
-_LIBUNWIND_EXPORT int unw_resume(unw_cursor_t *cursor) {
-  _LIBUNWIND_TRACE_API("unw_resume(cursor=%p)", static_cast<void *>(cursor));
+_LIBUNWIND_HIDDEN int __unw_resume(unw_cursor_t *cursor) {
+  _LIBUNWIND_TRACE_API("__unw_resume(cursor=%p)", static_cast<void *>(cursor));
+#if __has_feature(address_sanitizer) || defined(__SANITIZE_ADDRESS__)
+  // Inform the ASan runtime that now might be a good time to clean stuff up.
+  __asan_handle_no_return();
+#endif
   AbstractUnwindCursor *co = (AbstractUnwindCursor *)cursor;
   co->jumpto();
   return UNW_EUNSPEC;
 }
-
+_LIBUNWIND_WEAK_ALIAS(__unw_resume, unw_resume)
 
 /// Get name of function at cursor position in stack frame.
-_LIBUNWIND_EXPORT int unw_get_proc_name(unw_cursor_t *cursor, char *buf,
-                                        size_t bufLen, unw_word_t *offset) {
-  _LIBUNWIND_TRACE_API("unw_get_proc_name(cursor=%p, &buf=%p, bufLen=%lu)",
+_LIBUNWIND_HIDDEN int __unw_get_proc_name(unw_cursor_t *cursor, char *buf,
+                                          size_t bufLen, unw_word_t *offset) {
+  _LIBUNWIND_TRACE_API("__unw_get_proc_name(cursor=%p, &buf=%p, bufLen=%lu)",
                        static_cast<void *>(cursor), static_cast<void *>(buf),
                        static_cast<unsigned long>(bufLen));
   AbstractUnwindCursor *co = (AbstractUnwindCursor *)cursor;
   if (co->getFunctionName(buf, bufLen, offset))
     return UNW_ESUCCESS;
-  else
-    return UNW_EUNSPEC;
+  return UNW_EUNSPEC;
 }
-
+_LIBUNWIND_WEAK_ALIAS(__unw_get_proc_name, unw_get_proc_name)
 
 /// Checks if a register is a floating-point register.
-_LIBUNWIND_EXPORT int unw_is_fpreg(unw_cursor_t *cursor, unw_regnum_t regNum) {
-  _LIBUNWIND_TRACE_API("unw_is_fpreg(cursor=%p, regNum=%d)",
+_LIBUNWIND_HIDDEN int __unw_is_fpreg(unw_cursor_t *cursor,
+                                     unw_regnum_t regNum) {
+  _LIBUNWIND_TRACE_API("__unw_is_fpreg(cursor=%p, regNum=%d)",
                        static_cast<void *>(cursor), regNum);
   AbstractUnwindCursor *co = (AbstractUnwindCursor *)cursor;
   return co->validFloatReg(regNum);
 }
-
+_LIBUNWIND_WEAK_ALIAS(__unw_is_fpreg, unw_is_fpreg)
 
 /// Checks if a register is a floating-point register.
-_LIBUNWIND_EXPORT const char *unw_regname(unw_cursor_t *cursor,
-                                          unw_regnum_t regNum) {
-  _LIBUNWIND_TRACE_API("unw_regname(cursor=%p, regNum=%d)",
+_LIBUNWIND_HIDDEN const char *__unw_regname(unw_cursor_t *cursor,
+                                            unw_regnum_t regNum) {
+  _LIBUNWIND_TRACE_API("__unw_regname(cursor=%p, regNum=%d)",
                        static_cast<void *>(cursor), regNum);
   AbstractUnwindCursor *co = (AbstractUnwindCursor *)cursor;
   return co->getRegisterName(regNum);
 }
-
+_LIBUNWIND_WEAK_ALIAS(__unw_regname, unw_regname)
 
 /// Checks if current frame is signal trampoline.
-_LIBUNWIND_EXPORT int unw_is_signal_frame(unw_cursor_t *cursor) {
-  _LIBUNWIND_TRACE_API("unw_is_signal_frame(cursor=%p)",
+_LIBUNWIND_HIDDEN int __unw_is_signal_frame(unw_cursor_t *cursor) {
+  _LIBUNWIND_TRACE_API("__unw_is_signal_frame(cursor=%p)",
                        static_cast<void *>(cursor));
   AbstractUnwindCursor *co = (AbstractUnwindCursor *)cursor;
   return co->isSignalFrame();
 }
+_LIBUNWIND_WEAK_ALIAS(__unw_is_signal_frame, unw_is_signal_frame)
 
 #ifdef __arm__
 // Save VFP registers d0-d15 using FSTMIADX instead of FSTMIADD
-_LIBUNWIND_EXPORT void unw_save_vfp_as_X(unw_cursor_t *cursor) {
-  _LIBUNWIND_TRACE_API("unw_fpreg_save_vfp_as_X(cursor=%p)",
+_LIBUNWIND_HIDDEN void __unw_save_vfp_as_X(unw_cursor_t *cursor) {
+  _LIBUNWIND_TRACE_API("__unw_get_fpreg_save_vfp_as_X(cursor=%p)",
                        static_cast<void *>(cursor));
   AbstractUnwindCursor *co = (AbstractUnwindCursor *)cursor;
   return co->saveVFPAsX();
 }
+_LIBUNWIND_WEAK_ALIAS(__unw_save_vfp_as_X, unw_save_vfp_as_X)
 #endif
 
 
 #if defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND)
 /// SPI: walks cached DWARF entries
-_LIBUNWIND_EXPORT void unw_iterate_dwarf_unwind_cache(void (*func)(
+_LIBUNWIND_HIDDEN void __unw_iterate_dwarf_unwind_cache(void (*func)(
     unw_word_t ip_start, unw_word_t ip_end, unw_word_t fde, unw_word_t mh)) {
-  _LIBUNWIND_TRACE_API("unw_iterate_dwarf_unwind_cache(func=%p)",
+  _LIBUNWIND_TRACE_API("__unw_iterate_dwarf_unwind_cache(func=%p)",
                        reinterpret_cast<void *>(func));
   DwarfFDECache<LocalAddressSpace>::iterateCacheEntries(func);
 }
-
+_LIBUNWIND_WEAK_ALIAS(__unw_iterate_dwarf_unwind_cache,
+                      unw_iterate_dwarf_unwind_cache)
 
 /// IPI: for __register_frame()
-void _unw_add_dynamic_fde(unw_word_t fde) {
+void __unw_add_dynamic_fde(unw_word_t fde) {
   CFI_Parser<LocalAddressSpace>::FDE_Info fdeInfo;
   CFI_Parser<LocalAddressSpace>::CIE_Info cieInfo;
   const char *message = CFI_Parser<LocalAddressSpace>::decodeFDE(
@@ -337,18 +283,46 @@ void _unw_add_dynamic_fde(unw_word_t fde) {
     unw_word_t mh_group = fdeInfo.fdeStart;
     DwarfFDECache<LocalAddressSpace>::add((LocalAddressSpace::pint_t)mh_group,
                                           fdeInfo.pcStart, fdeInfo.pcEnd,
-                                          fdeInfo.fdeStart,
-                                          true);
+                                          fdeInfo.fdeStart);
   } else {
-    _LIBUNWIND_DEBUG_LOG("_unw_add_dynamic_fde: bad fde: %s", message);
+    _LIBUNWIND_DEBUG_LOG("__unw_add_dynamic_fde: bad fde: %s", message);
   }
 }
 
 /// IPI: for __deregister_frame()
-void _unw_remove_dynamic_fde(unw_word_t fde) {
+void __unw_remove_dynamic_fde(unw_word_t fde) {
   // fde is own mh_group
   DwarfFDECache<LocalAddressSpace>::removeAllIn((LocalAddressSpace::pint_t)fde);
 }
+
+void __unw_add_dynamic_eh_frame_section(unw_word_t eh_frame_start) {
+  // The eh_frame section start serves as the mh_group
+  unw_word_t mh_group = eh_frame_start;
+  CFI_Parser<LocalAddressSpace>::CIE_Info cieInfo;
+  CFI_Parser<LocalAddressSpace>::FDE_Info fdeInfo;
+  auto p = (LocalAddressSpace::pint_t)eh_frame_start;
+  while (true) {
+    if (CFI_Parser<LocalAddressSpace>::decodeFDE(
+            LocalAddressSpace::sThisAddressSpace, p, &fdeInfo, &cieInfo,
+            true) == NULL) {
+      DwarfFDECache<LocalAddressSpace>::add((LocalAddressSpace::pint_t)mh_group,
+                                            fdeInfo.pcStart, fdeInfo.pcEnd,
+                                            fdeInfo.fdeStart);
+      p += fdeInfo.fdeLength;
+    } else if (CFI_Parser<LocalAddressSpace>::parseCIE(
+                   LocalAddressSpace::sThisAddressSpace, p, &cieInfo) == NULL) {
+      p += cieInfo.cieLength;
+    } else
+      return;
+  }
+}
+
+void __unw_remove_dynamic_eh_frame_section(unw_word_t eh_frame_start) {
+  // The eh_frame section start serves as the mh_group
+  DwarfFDECache<LocalAddressSpace>::removeAllIn(
+      (LocalAddressSpace::pint_t)eh_frame_start);
+}
+
 #endif // defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND)
 #endif // !defined(__USING_SJLJ_EXCEPTIONS__)
 
diff --git a/WAVM/ThirdParty/libunwind/src/libunwind_ext.h b/WAVM/ThirdParty/libunwind/src/libunwind_ext.h
index ec645a84..7065ffcd 100644
--- a/WAVM/ThirdParty/libunwind/src/libunwind_ext.h
+++ b/WAVM/ThirdParty/libunwind/src/libunwind_ext.h
@@ -1,9 +1,8 @@
-//===------------------------ libunwind_ext.h -----------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
+//===----------------------------------------------------------------------===//
 //
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //
 //  Extensions to libunwind API.
@@ -23,15 +22,37 @@
 #ifdef __cplusplus
 extern "C" {
 #endif
+
+extern int __unw_getcontext(unw_context_t *);
+extern int __unw_init_local(unw_cursor_t *, unw_context_t *);
+extern int __unw_step(unw_cursor_t *);
+extern int __unw_get_reg(unw_cursor_t *, unw_regnum_t, unw_word_t *);
+extern int __unw_get_fpreg(unw_cursor_t *, unw_regnum_t, unw_fpreg_t *);
+extern int __unw_set_reg(unw_cursor_t *, unw_regnum_t, unw_word_t);
+extern int __unw_set_fpreg(unw_cursor_t *, unw_regnum_t, unw_fpreg_t);
+extern int __unw_resume(unw_cursor_t *);
+
+#ifdef __arm__
+/* Save VFP registers in FSTMX format (instead of FSTMD). */
+extern void __unw_save_vfp_as_X(unw_cursor_t *);
+#endif
+
+extern const char *__unw_regname(unw_cursor_t *, unw_regnum_t);
+extern int __unw_get_proc_info(unw_cursor_t *, unw_proc_info_t *);
+extern int __unw_is_fpreg(unw_cursor_t *, unw_regnum_t);
+extern int __unw_is_signal_frame(unw_cursor_t *);
+extern int __unw_get_proc_name(unw_cursor_t *, char *, size_t, unw_word_t *);
+
 // SPI
-extern void unw_iterate_dwarf_unwind_cache(void (*func)(unw_word_t ip_start,
-                                                        unw_word_t ip_end,
-                                                        unw_word_t fde,
-                                                        unw_word_t mh));
+extern void __unw_iterate_dwarf_unwind_cache(void (*func)(
+    unw_word_t ip_start, unw_word_t ip_end, unw_word_t fde, unw_word_t mh));
 
 // IPI
-extern void _unw_add_dynamic_fde(unw_word_t fde);
-extern void _unw_remove_dynamic_fde(unw_word_t fde);
+extern void __unw_add_dynamic_fde(unw_word_t fde);
+extern void __unw_remove_dynamic_fde(unw_word_t fde);
+
+extern void __unw_add_dynamic_eh_frame_section(unw_word_t eh_frame_start);
+extern void __unw_remove_dynamic_eh_frame_section(unw_word_t eh_frame_start);
 
 #if defined(_LIBUNWIND_ARM_EHABI)
 extern const uint32_t* decode_eht_entry(const uint32_t*, size_t*, size_t*);
diff --git a/WAVM/ThirdParty/libunwind/test/CMakeLists.txt b/WAVM/ThirdParty/libunwind/test/CMakeLists.txt
index 97917b82..7e86d50a 100644
--- a/WAVM/ThirdParty/libunwind/test/CMakeLists.txt
+++ b/WAVM/ThirdParty/libunwind/test/CMakeLists.txt
@@ -11,24 +11,46 @@ if (NOT DEFINED LIBCXX_ENABLE_SHARED)
   set(LIBCXX_ENABLE_SHARED ON)
 endif()
 
-pythonize_bool(LIBUNWIND_BUILD_32_BITS)
+pythonize_bool(LIBUNWIND_ENABLE_CET)
 pythonize_bool(LIBCXX_ENABLE_SHARED)
 pythonize_bool(LIBUNWIND_ENABLE_SHARED)
 pythonize_bool(LIBUNWIND_ENABLE_THREADS)
-pythonize_bool(LIBUNWIND_ENABLE_EXCEPTIONS)
+pythonize_bool(LIBUNWIND_USES_ARM_EHABI)
+pythonize_bool(LIBUNWIND_USE_COMPILER_RT)
 pythonize_bool(LIBUNWIND_BUILD_EXTERNAL_THREAD_LIBRARY)
 set(LIBUNWIND_TARGET_INFO "libcxx.test.target_info.LocalTI" CACHE STRING
     "TargetInfo to use when setting up test environment.")
-set(LIBUNWIND_EXECUTOR "None" CACHE STRING
+set(LIBUNWIND_EXECUTOR "${Python3_EXECUTABLE} ${LIBUNWIND_LIBCXX_PATH}/utils/run.py" CACHE STRING
     "Executor to use when running tests.")
 
 set(AUTO_GEN_COMMENT "## Autogenerated by libunwind configuration.\n# Do not edit!")
-configure_file(
-  ${CMAKE_CURRENT_SOURCE_DIR}/lit.site.cfg.in
+set(SERIALIZED_LIT_PARAMS "# Lit parameters serialized here for llvm-lit to pick them up\n")
+
+macro(serialize_lit_param param value)
+  string(APPEND SERIALIZED_LIT_PARAMS "config.${param} = ${value}\n")
+endmacro()
+
+serialize_lit_param(enable_experimental False)
+
+if (LLVM_USE_SANITIZER)
+  serialize_lit_param(use_sanitizer "\"${LLVM_USE_SANITIZER}\"")
+endif()
+
+if (LIBUNWIND_TARGET_TRIPLE)
+  serialize_lit_param(target_triple "\"${LIBUNWIND_TARGET_TRIPLE}\"")
+endif()
+
+foreach(param IN LISTS LIBUNWIND_TEST_PARAMS)
+  string(REGEX REPLACE "(.+)=(.+)" "\\1" name "${param}")
+  string(REGEX REPLACE "(.+)=(.+)" "\\2" value "${param}")
+  serialize_lit_param("${name}" "\"${value}\"")
+endforeach()
+
+configure_lit_site_cfg(
+  "${LIBUNWIND_TEST_CONFIG}"
   ${CMAKE_CURRENT_BINARY_DIR}/lit.site.cfg
-  @ONLY)
+  MAIN_CONFIG "${CMAKE_CURRENT_SOURCE_DIR}/lit.cfg.py")
 
 add_lit_testsuite(check-unwind "Running libunwind tests"
   ${CMAKE_CURRENT_BINARY_DIR}
-  DEPENDS ${LIBUNWIND_TEST_DEPS}
-  )
+  DEPENDS unwind ${LIBUNWIND_TEST_DEPS})
diff --git a/WAVM/ThirdParty/libunwind/test/alignment.pass.cpp b/WAVM/ThirdParty/libunwind/test/alignment.compile.pass.cpp
similarity index 77%
rename from WAVM/ThirdParty/libunwind/test/alignment.pass.cpp
rename to WAVM/ThirdParty/libunwind/test/alignment.compile.pass.cpp
index 1a3ca5a9..4606dc5e 100644
--- a/WAVM/ThirdParty/libunwind/test/alignment.pass.cpp
+++ b/WAVM/ThirdParty/libunwind/test/alignment.compile.pass.cpp
@@ -1,10 +1,9 @@
 // -*- C++ -*-
 //===----------------------------------------------------------------------===//
 //
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 
@@ -23,7 +22,3 @@ struct MaxAligned {} __attribute__((__aligned__));
 static_assert(alignof(_Unwind_Exception) == alignof(MaxAligned),
               "_Unwind_Exception must be maximally aligned");
 #endif
-
-int main()
-{
-}
diff --git a/WAVM/ThirdParty/libunwind/test/configs/llvm-libunwind-shared.cfg.in b/WAVM/ThirdParty/libunwind/test/configs/llvm-libunwind-shared.cfg.in
new file mode 100644
index 00000000..9de82e9d
--- /dev/null
+++ b/WAVM/ThirdParty/libunwind/test/configs/llvm-libunwind-shared.cfg.in
@@ -0,0 +1,62 @@
+@AUTO_GEN_COMMENT@
+
+@SERIALIZED_LIT_PARAMS@
+
+#
+# Configuration file for running the libunwind tests against the shared library.
+#
+# This file is a lot simpler than the ones for libc++ and libc++abi because
+# while libunwind is written in C++, it doesn't use the C++ Standard Library
+# so we don't need to set that up to run the tests correctly.
+#
+
+import os, site
+site.addsitedir(os.path.join('@LIBUNWIND_LIBCXX_PATH@', 'utils'))
+import libcxx.test.format
+
+# Basic configuration of the test suite
+config.name = os.path.basename('@LIBUNWIND_TEST_CONFIG@')
+config.test_source_root = os.path.join('@LIBUNWIND_SOURCE_DIR@', 'test')
+config.test_format = libcxx.test.format.CxxStandardLibraryTest()
+config.recursiveExpansionLimit = 10
+config.test_exec_root = '@CMAKE_BINARY_DIR@'
+
+compile_flags = []
+link_flags = []
+if @LIBUNWIND_USES_ARM_EHABI@:
+    config.available_features.add('libunwind-arm-ehabi')
+
+if not @LIBUNWIND_ENABLE_THREADS@:
+    compile_flags.append('-D_LIBUNWIND_HAS_NO_THREADS')
+    config.available_features.add('libunwind-no-threads')
+
+if @LIBUNWIND_ENABLE_CET@:
+    compile_flags.append('-fcf-protection=full')
+
+if '@CMAKE_SYSTEM_NAME@' == 'Linux':
+    link_flags.append('-Wl,--export-dynamic')
+
+# Stack unwinding tests need unwinding tables and these are not generated by default on all targets.
+compile_flags.append('-funwind-tables')
+
+config.substitutions.append(('%{cxx}', '@CMAKE_CXX_COMPILER@'))
+config.substitutions.append(('%{flags}',
+    '-isysroot {}'.format('@CMAKE_OSX_SYSROOT@') if '@CMAKE_OSX_SYSROOT@' else ''
+))
+config.substitutions.append(('%{compile_flags}',
+    '-nostdinc++ -I {}/include {}'.format('@LIBUNWIND_SOURCE_DIR@', ' '.join(compile_flags))
+))
+config.substitutions.append(('%{link_flags}',
+    '-L {0} -Wl,-rpath,{0} -lunwind -ldl {1}'.format('@LIBUNWIND_LIBRARY_DIR@', ' '.join(link_flags))
+))
+config.substitutions.append(('%{exec}', ''))
+
+import os, site
+site.addsitedir(os.path.join('@LIBUNWIND_LIBCXX_PATH@', 'utils'))
+import libcxx.test.params, libcxx.test.newconfig, libcxx.test.newconfig
+libcxx.test.newconfig.configure(
+    libcxx.test.params.DEFAULT_PARAMETERS,
+    libcxx.test.features.DEFAULT_FEATURES,
+    config,
+    lit_config
+)
diff --git a/WAVM/ThirdParty/libunwind/test/configs/llvm-libunwind-static.cfg.in b/WAVM/ThirdParty/libunwind/test/configs/llvm-libunwind-static.cfg.in
new file mode 100644
index 00000000..9382ad3f
--- /dev/null
+++ b/WAVM/ThirdParty/libunwind/test/configs/llvm-libunwind-static.cfg.in
@@ -0,0 +1,64 @@
+@AUTO_GEN_COMMENT@
+
+@SERIALIZED_LIT_PARAMS@
+
+#
+# Configuration file for running the libunwind tests against the static library.
+#
+# This file is a lot simpler than the ones for libc++ and libc++abi because
+# while libunwind is written in C++, it doesn't use the C++ Standard Library
+# so we don't need to set that up to run the tests correctly.
+#
+
+import os, site
+site.addsitedir(os.path.join('@LIBUNWIND_LIBCXX_PATH@', 'utils'))
+import libcxx.test.format
+
+# Basic configuration of the test suite
+config.name = os.path.basename('@LIBUNWIND_TEST_CONFIG@')
+config.test_source_root = os.path.join('@LIBUNWIND_SOURCE_DIR@', 'test')
+config.test_format = libcxx.test.format.CxxStandardLibraryTest()
+config.recursiveExpansionLimit = 10
+config.test_exec_root = '@CMAKE_BINARY_DIR@'
+
+compile_flags = []
+link_flags = []
+if @LIBUNWIND_USES_ARM_EHABI@:
+    config.available_features.add('libunwind-arm-ehabi')
+
+if not @LIBUNWIND_ENABLE_THREADS@:
+    compile_flags.append('-D_LIBUNWIND_HAS_NO_THREADS')
+    config.available_features.add('libunwind-no-threads')
+else:
+    link_flags.append('-lpthread')
+
+if @LIBUNWIND_ENABLE_CET@:
+    compile_flags.append('-fcf-protection=full')
+
+if '@CMAKE_SYSTEM_NAME@' == 'Linux':
+    link_flags.append('-Wl,--export-dynamic')
+
+# Stack unwinding tests need unwinding tables and these are not generated by default on all targets.
+compile_flags.append('-funwind-tables')
+
+config.substitutions.append(('%{cxx}', '@CMAKE_CXX_COMPILER@'))
+config.substitutions.append(('%{flags}',
+    '-isysroot {}'.format('@CMAKE_OSX_SYSROOT@') if '@CMAKE_OSX_SYSROOT@' else ''
+))
+config.substitutions.append(('%{compile_flags}',
+    '-nostdinc++ -I {}/include {}'.format('@LIBUNWIND_SOURCE_DIR@', ' '.join(compile_flags))
+))
+config.substitutions.append(('%{link_flags}',
+    '{}/libunwind.a -ldl {}'.format('@LIBUNWIND_LIBRARY_DIR@', ' '.join(link_flags))
+))
+config.substitutions.append(('%{exec}', ''))
+
+import os, site
+site.addsitedir(os.path.join('@LIBUNWIND_LIBCXX_PATH@', 'utils'))
+import libcxx.test.params, libcxx.test.newconfig, libcxx.test.newconfig
+libcxx.test.newconfig.configure(
+    libcxx.test.params.DEFAULT_PARAMETERS,
+    libcxx.test.features.DEFAULT_FEATURES,
+    config,
+    lit_config
+)
diff --git a/WAVM/ThirdParty/libunwind/test/floatregister.pass.cpp b/WAVM/ThirdParty/libunwind/test/floatregister.pass.cpp
new file mode 100644
index 00000000..64107e6d
--- /dev/null
+++ b/WAVM/ThirdParty/libunwind/test/floatregister.pass.cpp
@@ -0,0 +1,51 @@
+// -*- C++ -*-
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// REQUIRES: linux && target={{aarch64-.+}}
+
+// Basic test for float registers number are accepted.
+
+#include <dlfcn.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unwind.h>
+
+_Unwind_Reason_Code frame_handler(struct _Unwind_Context *ctx, void *arg) {
+  (void)arg;
+  Dl_info info = {0, 0, 0, 0};
+
+  // Unwind util the main is reached, above frames depend on the platform and
+  // architecture.
+  if (dladdr(reinterpret_cast<void *>(_Unwind_GetIP(ctx)), &info) &&
+      info.dli_sname && !strcmp("main", info.dli_sname))
+    _Exit(0);
+
+  return _URC_NO_REASON;
+}
+
+__attribute__((noinline)) void foo() {
+  // Provide some CFI directives that instructs the unwinder where given
+  // float register is.
+#if defined(__aarch64__)
+  // DWARF register number for V0-V31 registers are 64-95.
+  // Previous value of V0 is saved at offset 0 from CFA.
+  asm volatile(".cfi_offset 64, 0");
+  // From now on the previous value of register can't be restored anymore.
+  asm volatile(".cfi_undefined 65");
+  asm volatile(".cfi_undefined 95");
+  // Previous value of V2 is in V30.
+  asm volatile(".cfi_register  66, 94");
+#endif
+  _Unwind_Backtrace(frame_handler, NULL);
+}
+
+int main() {
+  foo();
+  return -2;
+}
diff --git a/WAVM/ThirdParty/libunwind/test/forceunwind.pass.cpp b/WAVM/ThirdParty/libunwind/test/forceunwind.pass.cpp
new file mode 100644
index 00000000..46669726
--- /dev/null
+++ b/WAVM/ThirdParty/libunwind/test/forceunwind.pass.cpp
@@ -0,0 +1,68 @@
+// -*- C++ -*-
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// REQUIRES: linux
+
+// Basic test for _Unwind_ForcedUnwind.
+// See libcxxabi/test/forced_unwind* tests too.
+
+#include <assert.h>
+#include <dlfcn.h>
+#include <signal.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <unwind.h>
+
+void foo();
+_Unwind_Exception ex;
+
+_Unwind_Reason_Code stop(int version, _Unwind_Action actions,
+                         _Unwind_Exception_Class exceptionClass,
+                         _Unwind_Exception *exceptionObject,
+                         struct _Unwind_Context *context,
+                         void *stop_parameter) {
+  assert(version == 1);
+  assert((actions & _UA_FORCE_UNWIND) != 0);
+  (void)exceptionClass;
+  assert(exceptionObject == &ex);
+  assert(stop_parameter == &foo);
+
+  Dl_info info = {0, 0, 0, 0};
+
+  // Unwind util the main is reached, above frames depend on the platform and
+  // architecture.
+  if (dladdr(reinterpret_cast<void *>(_Unwind_GetIP(context)), &info) &&
+      info.dli_sname && !strcmp("main", info.dli_sname)) {
+    _Exit(0);
+  }
+  return _URC_NO_REASON;
+}
+
+__attribute__((noinline)) void foo() {
+
+  // Arm EHABI defines struct _Unwind_Control_Block as exception
+  // object. Ensure struct _Unwind_Exception* work there too,
+  // because _Unwind_Exception in this case is just an alias.
+  struct _Unwind_Exception *e = &ex;
+#if defined(_LIBUNWIND_ARM_EHABI)
+  // Create a mock exception object.
+  memset(e, '\0', sizeof(*e));
+  strcpy(reinterpret_cast<char *>(&e->exception_class), "CLNGUNW");
+#endif
+  _Unwind_ForcedUnwind(e, stop, (void *)&foo);
+}
+
+int main() {
+  foo();
+  return -2;
+}
diff --git a/WAVM/ThirdParty/libunwind/test/frameheadercache_test.pass.cpp b/WAVM/ThirdParty/libunwind/test/frameheadercache_test.pass.cpp
new file mode 100644
index 00000000..9abff5e8
--- /dev/null
+++ b/WAVM/ThirdParty/libunwind/test/frameheadercache_test.pass.cpp
@@ -0,0 +1,72 @@
+// The other libunwind tests don't test internal interfaces, so the include path
+// is a little wonky.
+#include "../src/config.h"
+
+// Only run this test under supported configurations.
+
+#if defined(_LIBUNWIND_USE_DL_ITERATE_PHDR) &&                                 \
+    defined(_LIBUNWIND_USE_FRAME_HEADER_CACHE)
+
+#include <link.h>
+#include <stdio.h>
+
+// This file defines several of the data structures needed here,
+// and includes FrameHeaderCache.hpp as well.
+#include "../src/AddressSpace.hpp"
+
+#define kBaseAddr 0xFFF000
+#define kTextSegmentLength 0xFF
+
+using namespace libunwind;
+
+int main(int, char**) {
+  FrameHeaderCache FHC;
+  struct dl_phdr_info PInfo;
+  memset(&PInfo, 0, sizeof(PInfo));
+  // The cache itself should only care about these two fields--they
+  // tell the cache to invalidate or not; everything else is handled
+  // by AddressSpace.hpp.
+  PInfo.dlpi_adds = 6;
+  PInfo.dlpi_subs = 7;
+
+  UnwindInfoSections UIS;
+  UIS.dso_base = kBaseAddr;
+  UIS.text_segment_length = kTextSegmentLength;
+  dl_iterate_cb_data CBData;
+  // Unused by the cache.
+  CBData.addressSpace = nullptr;
+  CBData.sects = &UIS;
+  CBData.targetAddr = kBaseAddr + 1;
+
+  // Nothing present, shouldn't find.
+  if (FHC.find(&PInfo, 0, &CBData))
+    abort();
+  FHC.add(&UIS);
+  // Just added. Should find.
+  if (!FHC.find(&PInfo, 0, &CBData))
+    abort();
+  // Cache is invalid. Shouldn't find.
+  PInfo.dlpi_adds++;
+  if (FHC.find(&PInfo, 0, &CBData))
+    abort();
+
+  FHC.add(&UIS);
+  CBData.targetAddr = kBaseAddr - 1;
+  // Shouldn't find something outside of the addresses.
+  if (FHC.find(&PInfo, 0, &CBData))
+    abort();
+  // Add enough things to the cache that the entry is evicted.
+  for (int i = 0; i < 9; i++) {
+    UIS.dso_base = kBaseAddr + (kTextSegmentLength * i);
+    FHC.add(&UIS);
+  }
+  CBData.targetAddr = kBaseAddr;
+  // Should have been evicted.
+  if (FHC.find(&PInfo, 0, &CBData))
+    abort();
+  return 0;
+}
+
+#else
+int main(int, char**) { return 0;}
+#endif
diff --git a/WAVM/ThirdParty/libunwind/test/libunwind/test/config.py b/WAVM/ThirdParty/libunwind/test/libunwind/test/config.py
index 2a0c8283..87a810b4 100644
--- a/WAVM/ThirdParty/libunwind/test/libunwind/test/config.py
+++ b/WAVM/ThirdParty/libunwind/test/libunwind/test/config.py
@@ -1,9 +1,8 @@
 #===----------------------------------------------------------------------===##
 #
-#                     The LLVM Compiler Infrastructure
-#
-# This file is dual licensed under the MIT and the University of Illinois Open
-# Source Licenses. See LICENSE.TXT for details.
+# Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+# See https://llvm.org/LICENSE.txt for license information.
+# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 #
 #===----------------------------------------------------------------------===##
 import os
@@ -18,16 +17,14 @@ class Configuration(LibcxxConfiguration):
         super(Configuration, self).__init__(lit_config, config)
         self.libunwind_src_root = None
         self.libunwind_obj_root = None
-        self.abi_library_path = None
+        self.abi_library_root = None
         self.libcxx_src_root = None
 
     def configure_src_root(self):
-        self.libunwind_src_root = self.get_lit_conf(
-            'libunwind_src_root',
-            os.path.dirname(self.config.test_source_root))
-        self.libcxx_src_root = self.get_lit_conf(
-            'libcxx_src_root',
-            os.path.join(self.libunwind_src_root, '/../libcxx'))
+        self.libunwind_src_root = (self.get_lit_conf('libunwind_src_root')
+            or os.path.dirname(self.config.test_source_root))
+        self.libcxx_src_root = (self.get_lit_conf('libcxx_src_root')
+            or os.path.join(self.libunwind_src_root, '..', 'libcxx'))
 
     def configure_obj_root(self):
         self.libunwind_obj_root = self.get_lit_conf('libunwind_obj_root')
@@ -38,24 +35,25 @@ class Configuration(LibcxxConfiguration):
 
     def configure_features(self):
         super(Configuration, self).configure_features()
-        if not self.get_lit_bool('enable_exceptions', True):
-            self.config.available_features.add('libcxxabi-no-exceptions')
+        if self.get_lit_bool('arm_ehabi', False):
+            self.config.available_features.add('libunwind-arm-ehabi')
 
     def configure_compile_flags(self):
-        self.cxx.compile_flags += ['-DLIBUNWIND_NO_TIMER']
-        if not self.get_lit_bool('enable_exceptions', True):
-            self.cxx.compile_flags += ['-fno-exceptions', '-DLIBUNWIND_HAS_NO_EXCEPTIONS']
         # Stack unwinding tests need unwinding tables and these are not
         # generated by default on all Targets.
         self.cxx.compile_flags += ['-funwind-tables']
+        # Make symbols available in the tests.
+        triple = self.get_lit_conf('target_triple', None)
+        if triple is not None and 'linux' in triple:
+            self.cxx.link_flags += ['-Wl,--export-dynamic']
         if not self.get_lit_bool('enable_threads', True):
             self.cxx.compile_flags += ['-D_LIBUNWIND_HAS_NO_THREADS']
             self.config.available_features.add('libunwind-no-threads')
+        if self.get_lit_bool('x86_cet', False):
+            self.cxx.compile_flags += ['-fcf-protection=full']
         super(Configuration, self).configure_compile_flags()
 
     def configure_compile_flags_header_includes(self):
-        self.configure_config_site_header()
-
         libunwind_headers = self.get_lit_conf(
             'libunwind_headers',
             os.path.join(self.libunwind_src_root, 'include'))
@@ -64,8 +62,10 @@ class Configuration(LibcxxConfiguration):
                                   % libunwind_headers)
         self.cxx.compile_flags += ['-I' + libunwind_headers]
 
-    def configure_compile_flags_exceptions(self):
+    def configure_link_flags_cxx_library(self):
+        # libunwind tests should not link with libc++
         pass
 
-    def configure_compile_flags_rtti(self):
+    def configure_link_flags_abi_library(self):
+        # libunwind tests should not link with libc++abi
         pass
diff --git a/WAVM/ThirdParty/libunwind/test/libunwind_01.pass.cpp b/WAVM/ThirdParty/libunwind/test/libunwind_01.pass.cpp
index 6957d98f..e5737450 100644
--- a/WAVM/ThirdParty/libunwind/test/libunwind_01.pass.cpp
+++ b/WAVM/ThirdParty/libunwind/test/libunwind_01.pass.cpp
@@ -1,5 +1,9 @@
+// TODO: Investigate these failures on x86_64 macOS back deployment
+// UNSUPPORTED: target=x86_64-apple-darwin{{.+}}
+
 #include <libunwind.h>
 #include <stdlib.h>
+#include <string.h>
 
 void backtrace(int lower_bound) {
   unw_context_t context;
@@ -35,8 +39,103 @@ void test3(int i, int j, int k) {
   test2(j, k);
 }
 
-int main() {
+void test_no_info() {
+  unw_context_t context;
+  unw_getcontext(&context);
+
+  unw_cursor_t cursor;
+  unw_init_local(&cursor, &context);
+
+  unw_proc_info_t info;
+  int ret = unw_get_proc_info(&cursor, &info);
+  if (ret != UNW_ESUCCESS)
+    abort();
+
+  // Set the IP to an address clearly outside any function.
+  unw_set_reg(&cursor, UNW_REG_IP, (unw_word_t)0);
+
+  ret = unw_get_proc_info(&cursor, &info);
+  if (ret != UNW_ENOINFO)
+    abort();
+}
+
+void test_reg_names() {
+  unw_context_t context;
+  unw_getcontext(&context);
+
+  unw_cursor_t cursor;
+  unw_init_local(&cursor, &context);
+
+  int max_reg_num = -100;
+#if defined(__i386__)
+  max_reg_num = 7;
+#elif defined(__x86_64__)
+  max_reg_num = 32;
+#endif
+
+  const char prefix[] = "unknown";
+  for (int i = -2; i < max_reg_num; ++i) {
+    if (strncmp(prefix, unw_regname(&cursor, i), sizeof(prefix) - 1) == 0)
+      abort();
+  }
+
+  if (strncmp(prefix, unw_regname(&cursor, max_reg_num + 1),
+              sizeof(prefix) - 1) != 0)
+    abort();
+}
+
+#if defined(__x86_64__)
+void test_reg_get_set() {
+  unw_context_t context;
+  unw_getcontext(&context);
+
+  unw_cursor_t cursor;
+  unw_init_local(&cursor, &context);
+
+  for (int i = 0; i < 17; ++i) {
+    const unw_word_t set_value = 7;
+    if (unw_set_reg(&cursor, i, set_value) != UNW_ESUCCESS)
+      abort();
+
+    unw_word_t get_value = 0;
+    if (unw_get_reg(&cursor, i, &get_value) != UNW_ESUCCESS)
+      abort();
+
+    if (set_value != get_value)
+      abort();
+  }
+}
+
+void test_fpreg_get_set() {
+  unw_context_t context;
+  unw_getcontext(&context);
+
+  unw_cursor_t cursor;
+  unw_init_local(&cursor, &context);
+
+  // get/set is not implemented for x86_64 fpregs.
+  for (int i = 17; i < 33; ++i) {
+    const unw_fpreg_t set_value = 7;
+    if (unw_set_fpreg(&cursor, i, set_value) != UNW_EBADREG)
+      abort();
+
+    unw_fpreg_t get_value = 0;
+    if (unw_get_fpreg(&cursor, i, &get_value) != UNW_EBADREG)
+      abort();
+  }
+}
+#else
+void test_reg_get_set() {}
+void test_fpreg_get_set() {}
+#endif
+
+int main(int, char**) {
   test1(1);
   test2(1, 2);
   test3(1, 2, 3);
+  test_no_info();
+  test_reg_names();
+  test_reg_get_set();
+  test_fpreg_get_set();
+  return 0;
 }
diff --git a/WAVM/ThirdParty/libunwind/test/libunwind_02.pass.cpp b/WAVM/ThirdParty/libunwind/test/libunwind_02.pass.cpp
index a0efd1df..b188fad8 100644
--- a/WAVM/ThirdParty/libunwind/test/libunwind_02.pass.cpp
+++ b/WAVM/ThirdParty/libunwind/test/libunwind_02.pass.cpp
@@ -32,7 +32,8 @@ int test(int i) {
   }
 }
 
-int main() {
+int main(int, char**) {
   int total = test(50);
   assert(total == 1275);
+  return 0;
 }
diff --git a/WAVM/ThirdParty/libunwind/test/lit.cfg b/WAVM/ThirdParty/libunwind/test/lit.cfg
deleted file mode 100644
index 272bc163..00000000
--- a/WAVM/ThirdParty/libunwind/test/lit.cfg
+++ /dev/null
@@ -1,67 +0,0 @@
-# -*- Python -*- vim: set ft=python ts=4 sw=4 expandtab tw=79:
-
-# Configuration file for the 'lit' test runner.
-
-
-import os
-import site
-
-site.addsitedir(os.path.dirname(__file__))
-
-
-# Tell pylint that we know config and lit_config exist somewhere.
-if 'PYLINT_IMPORT' in os.environ:
-    config = object()
-    lit_config = object()
-
-# name: The name of this test suite.
-config.name = 'libunwind'
-
-# suffixes: A list of file extensions to treat as test files.
-config.suffixes = ['.cpp', '.s']
-
-# test_source_root: The root path where tests are located.
-config.test_source_root = os.path.dirname(__file__)
-
-# Infer the libcxx_test_source_root for configuration import.
-# If libcxx_source_root isn't specified in the config, assume that the libcxx
-# and libunwind source directories are sibling directories.
-libcxx_src_root = getattr(config, 'libcxx_src_root', None)
-if not libcxx_src_root:
-    libcxx_src_root = os.path.join(config.test_source_root, '../../libcxx')
-libcxx_test_src_root = os.path.join(libcxx_src_root, 'utils')
-if os.path.isfile(os.path.join(libcxx_test_src_root, 'libcxx', '__init__.py')):
-    site.addsitedir(libcxx_test_src_root)
-else:
-    lit_config.fatal('Could not find libcxx test directory for test imports'
-                     ' in: %s' % libcxx_test_src_root)
-
-# Infer the test_exec_root from the libcxx_object root.
-obj_root = getattr(config, 'libunwind_obj_root', None)
-
-# Check that the test exec root is known.
-if obj_root is None:
-    import libcxx.test.config
-    libcxx.test.config.loadSiteConfig(
-        lit_config, config, 'libunwind_site_config', 'LIBUNWIND_SITE_CONFIG')
-    obj_root = getattr(config, 'libunwind_obj_root', None)
-    if obj_root is None:
-        import tempfile
-        obj_root = tempfile.mkdtemp(prefix='libunwind-testsuite-')
-        lit_config.warning('Creating temporary directory for object root: %s' %
-                           obj_root)
-
-config.test_exec_root = os.path.join(obj_root, 'test')
-
-cfg_variant = getattr(config, 'configuration_variant', 'libunwind')
-if cfg_variant:
-    lit_config.note('Using configuration variant: %s' % cfg_variant)
-
-# Load the Configuration class from the module name <cfg_variant>.test.config.
-config_module_name = '.'.join([cfg_variant, 'test', 'config'])
-config_module = __import__(config_module_name, fromlist=['Configuration'])
-
-configuration = config_module.Configuration(lit_config, config)
-configuration.configure()
-configuration.print_config_info()
-config.test_format = configuration.get_test_format()
diff --git a/WAVM/ThirdParty/libunwind/test/lit.cfg.py b/WAVM/ThirdParty/libunwind/test/lit.cfg.py
new file mode 100644
index 00000000..647464ab
--- /dev/null
+++ b/WAVM/ThirdParty/libunwind/test/lit.cfg.py
@@ -0,0 +1,10 @@
+# All the Lit configuration is handled in the site configs -- this file is only
+# left as a canary to catch invocations of Lit that do not go through llvm-lit.
+#
+# Invocations that go through llvm-lit will automatically use the right Lit
+# site configuration inside the build directory.
+
+lit_config.fatal(
+    "You seem to be running Lit directly -- you should be running Lit through "
+    "<build>/bin/llvm-lit, which will ensure that the right Lit configuration "
+    "file is used.")
diff --git a/WAVM/ThirdParty/libunwind/test/lit.site.cfg.in b/WAVM/ThirdParty/libunwind/test/lit.site.cfg.in
index 8e3bb72e..4fd633f8 100644
--- a/WAVM/ThirdParty/libunwind/test/lit.site.cfg.in
+++ b/WAVM/ThirdParty/libunwind/test/lit.site.cfg.in
@@ -1,29 +1,58 @@
 @AUTO_GEN_COMMENT@
-config.cxx_under_test           = "@LIBUNWIND_COMPILER@"
+
+@SERIALIZED_LIT_PARAMS@
+
+import os
+import site
+
+config.cxx_under_test           = "@CMAKE_CXX_COMPILER@"
 config.project_obj_root         = "@CMAKE_BINARY_DIR@"
+config.install_root             = "@CMAKE_BINARY_DIR@"
 config.libunwind_src_root       = "@LIBUNWIND_SOURCE_DIR@"
 config.libunwind_obj_root       = "@LIBUNWIND_BINARY_DIR@"
-config.abi_library_path         = "@LIBUNWIND_LIBRARY_DIR@"
+config.abi_library_root         = "@LIBUNWIND_LIBRARY_DIR@"
 config.libcxx_src_root          = "@LIBUNWIND_LIBCXX_PATH@"
 config.libunwind_headers        = "@LIBUNWIND_SOURCE_DIR@/include"
 config.cxx_library_root         = "@LIBUNWIND_LIBCXX_LIBRARY_PATH@"
-config.llvm_unwinder            = "1"
-config.enable_threads           = "@LIBUNWIND_ENABLE_THREADS@"
-config.use_sanitizer            = "@LLVM_USE_SANITIZER@"
-config.enable_32bit             = "@LIBUNWIND_BUILD_32_BITS@"
+config.llvm_unwinder            = True
+config.builtins_library         = "@LIBUNWIND_BUILTINS_LIBRARY@"
+config.enable_threads           = @LIBUNWIND_ENABLE_THREADS@
 config.target_info              = "@LIBUNWIND_TARGET_INFO@"
 config.test_linker_flags        = "@LIBUNWIND_TEST_LINKER_FLAGS@"
 config.test_compiler_flags      = "@LIBUNWIND_TEST_COMPILER_FLAGS@"
 config.executor                 = "@LIBUNWIND_EXECUTOR@"
-config.libunwind_shared         = "@LIBUNWIND_ENABLE_SHARED@"
-config.enable_shared            = "@LIBCXX_ENABLE_SHARED@"
-config.enable_exceptions        = "@LIBUNWIND_ENABLE_EXCEPTIONS@"
+config.libunwind_shared         = @LIBUNWIND_ENABLE_SHARED@
+config.enable_shared            = @LIBCXX_ENABLE_SHARED@
+config.arm_ehabi                = @LIBUNWIND_USES_ARM_EHABI@
 config.host_triple              = "@LLVM_HOST_TRIPLE@"
-config.target_triple            = "@TARGET_TRIPLE@"
-config.use_target               = len("@LIBUNWIND_TARGET_TRIPLE@") > 0
 config.sysroot                  = "@LIBUNWIND_SYSROOT@"
 config.gcc_toolchain            = "@LIBUNWIND_GCC_TOOLCHAIN@"
-config.cxx_ext_threads          = "@LIBUNWIND_BUILD_EXTERNAL_THREAD_LIBRARY@"
+config.cxx_ext_threads          = @LIBUNWIND_BUILD_EXTERNAL_THREAD_LIBRARY@
+config.x86_cet                  = @LIBUNWIND_ENABLE_CET@
+
+site.addsitedir(os.path.join(config.libunwind_src_root, 'test'))
+site.addsitedir(os.path.join(config.libcxx_src_root, 'utils'))
+
+# name: The name of this test suite.
+config.name = 'libunwind'
+
+# suffixes: A list of file extensions to treat as test files.
+config.suffixes = ['.cpp', '.s']
+
+# test_source_root: The root path where tests are located.
+config.test_source_root = os.path.join(config.libunwind_src_root, 'test')
+
+# Allow expanding substitutions that are based on other substitutions
+config.recursiveExpansionLimit = 10
+
+# Infer the test_exec_root from the build directory.
+config.test_exec_root = os.path.join(config.libunwind_obj_root, 'test')
+
+import libcxx.test.format
+config.test_format = libcxx.test.format.CxxStandardLibraryTest()
 
-# Let the main config do the real work.
-lit_config.load_config(config, "@LIBUNWIND_SOURCE_DIR@/test/lit.cfg")
+lit_config.note('Using configuration variant: libunwind')
+import libunwind.test.config
+configuration = libunwind.test.config.Configuration(lit_config, config)
+configuration.configure()
+configuration.print_config_info()
diff --git a/WAVM/ThirdParty/libunwind/test/remember_state_leak.pass.sh.s b/WAVM/ThirdParty/libunwind/test/remember_state_leak.pass.sh.s
new file mode 100644
index 00000000..590653e2
--- /dev/null
+++ b/WAVM/ThirdParty/libunwind/test/remember_state_leak.pass.sh.s
@@ -0,0 +1,56 @@
+# REQUIRES: target={{x86_64-.+-linux-gnu}}
+# RUN: %{build} -no-pie
+# RUN: %{run}
+
+# The following assembly is a translation of this code:
+#
+#   _Unwind_Reason_Code callback(int, _Unwind_Action, long unsigned int,
+#                                _Unwind_Exception*, _Unwind_Context*, void*) {
+#     return _Unwind_Reason_Code(0);
+#   }
+#
+#   int main() {
+#     asm(".cfi_remember_state\n\t");
+#     _Unwind_Exception exc;
+#     _Unwind_ForcedUnwind(&exc, callback, 0);
+#     asm(".cfi_restore_state\n\t");
+#   }
+#
+# When unwinding, the CFI parser will stop parsing opcodes after the current PC,
+# so in this case the DW_CFA_restore_state opcode will never be processed and,
+# if the library doesn't clean up properly, the store allocated by
+# DW_CFA_remember_state will be leaked.
+#
+# This test will fail when linked with an asan-enabled libunwind if the
+# remembered state is leaked.
+
+    SIZEOF_UNWIND_EXCEPTION = 32
+
+    .text
+callback:
+    xorl    %eax, %eax
+    retq
+
+    .globl    main                    # -- Begin function main
+    .p2align    4, 0x90
+    .type    main,@function
+main:                                   # @main
+    .cfi_startproc
+    subq    $8, %rsp   # Adjust stack alignment
+    subq    $SIZEOF_UNWIND_EXCEPTION, %rsp
+    .cfi_def_cfa_offset 48
+    .cfi_remember_state
+    movq    %rsp, %rdi
+    movabsq $callback, %rsi
+    xorl    %edx, %edx
+    callq    _Unwind_ForcedUnwind
+    .cfi_restore_state
+    xorl    %eax, %eax
+    addq    $SIZEOF_UNWIND_EXCEPTION, %rsp
+    addq    $8, %rsp   # Undo stack alignment adjustment
+    .cfi_def_cfa_offset 8
+    retq
+.Lfunc_end1:
+    .size    main, .Lfunc_end1-main
+    .cfi_endproc
+                                        # -- End function
diff --git a/WAVM/ThirdParty/libunwind/test/signal_frame.pass.cpp b/WAVM/ThirdParty/libunwind/test/signal_frame.pass.cpp
new file mode 100644
index 00000000..85a883be
--- /dev/null
+++ b/WAVM/ThirdParty/libunwind/test/signal_frame.pass.cpp
@@ -0,0 +1,38 @@
+// -*- C++ -*-
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// Ensure that functions marked as signal frames are reported as such.
+
+// TODO: Investigate this failure on macOS
+// XFAIL: target={{.+}}-apple-darwin{{.+}}
+
+// UNSUPPORTED: libunwind-arm-ehabi
+
+// The AIX assembler does not support CFI directives, which
+// are necessary to run this test.
+// UNSUPPORTED: target=powerpc{{(64)?}}-ibm-aix
+
+#include <assert.h>
+#include <stdlib.h>
+#include <libunwind.h>
+
+void test() {
+  asm(".cfi_signal_frame");
+  unw_cursor_t cursor;
+  unw_context_t uc;
+  unw_getcontext(&uc);
+  unw_init_local(&cursor, &uc);
+  assert(unw_step(&cursor) > 0);
+  assert(unw_is_signal_frame(&cursor));
+}
+
+int main(int, char**) {
+  test();
+  return 0;
+}
diff --git a/WAVM/ThirdParty/libunwind/test/signal_unwind.pass.cpp b/WAVM/ThirdParty/libunwind/test/signal_unwind.pass.cpp
new file mode 100644
index 00000000..c16adeb4
--- /dev/null
+++ b/WAVM/ThirdParty/libunwind/test/signal_unwind.pass.cpp
@@ -0,0 +1,46 @@
+// -*- C++ -*-
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// Ensure that the unwinder can cope with the signal handler.
+// REQUIRES: linux && (target={{aarch64-.+}} || target={{x86_64-.+}})
+
+#include <assert.h>
+#include <dlfcn.h>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <unwind.h>
+
+_Unwind_Reason_Code frame_handler(struct _Unwind_Context* ctx, void* arg) {
+  (void)arg;
+  Dl_info info = { 0, 0, 0, 0 };
+
+  // Unwind util the main is reached, above frames depend on the platform and
+  // architecture.
+  if (dladdr(reinterpret_cast<void *>(_Unwind_GetIP(ctx)), &info) &&
+      info.dli_sname && !strcmp("main", info.dli_sname)) {
+    _Exit(0);
+  }
+  return _URC_NO_REASON;
+}
+
+void signal_handler(int signum) {
+  (void)signum;
+  _Unwind_Backtrace(frame_handler, NULL);
+  _Exit(-1);
+}
+
+int main(int, char**) {
+  signal(SIGUSR1, signal_handler);
+  kill(getpid(), SIGUSR1);
+  return -2;
+}
diff --git a/WAVM/ThirdParty/libunwind/test/unw_getcontext.pass.cpp b/WAVM/ThirdParty/libunwind/test/unw_getcontext.pass.cpp
index b012706a..a1f2baee 100644
--- a/WAVM/ThirdParty/libunwind/test/unw_getcontext.pass.cpp
+++ b/WAVM/ThirdParty/libunwind/test/unw_getcontext.pass.cpp
@@ -1,8 +1,9 @@
 #include <assert.h>
 #include <libunwind.h>
 
-int main() {
+int main(int, char**) {
   unw_context_t context;
   int ret = unw_getcontext(&context);
   assert(ret == UNW_ESUCCESS);
+  return 0;
 }
diff --git a/WAVM/ThirdParty/libunwind/test/unwind_leaffunction.pass.cpp b/WAVM/ThirdParty/libunwind/test/unwind_leaffunction.pass.cpp
new file mode 100644
index 00000000..8ff21dd3
--- /dev/null
+++ b/WAVM/ThirdParty/libunwind/test/unwind_leaffunction.pass.cpp
@@ -0,0 +1,55 @@
+// -*- C++ -*-
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// Ensure that leaf function can be unwund.
+// REQUIRES: linux && (target={{aarch64-.+}} || target={{x86_64-.+}})
+
+#include <assert.h>
+#include <dlfcn.h>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <unwind.h>
+
+_Unwind_Reason_Code frame_handler(struct _Unwind_Context* ctx, void* arg) {
+  (void)arg;
+  Dl_info info = { 0, 0, 0, 0 };
+
+  // Unwind util the main is reached, above frames deeped on the platfrom and architecture.
+  if (dladdr(reinterpret_cast<void *>(_Unwind_GetIP(ctx)), &info) &&
+      info.dli_sname && !strcmp("main", info.dli_sname)) {
+    _Exit(0);
+  }
+  return _URC_NO_REASON;
+}
+
+void signal_handler(int signum) {
+  (void)signum;
+  _Unwind_Backtrace(frame_handler, NULL);
+  _Exit(-1);
+}
+
+__attribute__((noinline)) void crashing_leaf_func(void) {
+  // libunwind searches for the address before the return address which points
+  // to the trap instruction. NOP guarantees the trap instruction is not the
+  // first instruction of the function.
+  // We should keep this here for other unwinders that also decrement pc.
+  __asm__ __volatile__("nop");
+  __builtin_trap();
+}
+
+int main(int, char**) {
+  signal(SIGTRAP, signal_handler);
+  signal(SIGILL, signal_handler);
+  crashing_leaf_func();
+  return -2;
+}
